<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match Live - Jen et ses Saints</title>
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;600;700&family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="match-live.css">
</head>
<body class="classic-mode">
    <div class="layout-wrapper" id="layoutWrapper">
    <div class="app-container">
        <!-- Score Header -->
        <header class="score-header">
            <div class="score-header-row-top">
                <div class="score-header-left">
                    <button class="back-btn" onclick="handleBack()">
                        <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                        </svg>
                    </button>
                    <span class="set-indicator" id="setIndicator">SET 1</span>
                </div>
                <div class="score-display">
                    <div class="team-score" id="homeScoreDisplay">
                        <div class="team-name">Jen et ses Saints</div>
                        <div class="team-points" id="homePoints">0</div>
                    </div>
                    <span class="score-separator">-</span>
                    <div class="team-score" id="awayScoreDisplay">
                        <div class="team-name" id="awayTeamName">Adversaire</div>
                        <div class="team-points" id="awayPoints">0</div>
                    </div>
                </div>
                <div class="score-header-right-placeholder"></div>
            </div>
            <div class="score-header-row-bottom">
                <div class="header-controls-left">
                    <button class="header-ctrl-btn substitute" id="btnSubstitute" onclick="openSubModal()" title="Changement" style="display: none;">
                        <svg width="12" height="12" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M16 17.01V10h-2v7.01h-3L15 21l4-3.99h-3zM9 3L5 6.99h3V14h2V6.99h3L9 3z"/>
                        </svg>
                        Changement
                    </button>
                    <button class="header-ctrl-btn end-set" id="btnEndSet" onclick="openEndSetModal('manual')" title="Terminer le set" style="display: none;">
                        <svg width="12" height="12" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"/>
                        </svg>
                        Fin du Set
                    </button>
                </div>
                <div class="header-controls-center">
                    <button class="header-ctrl-btn youtube-link" id="btnYoutubeLink" onclick="openYoutubeModal()" title="Lien YouTube">
                        <svg width="12" height="12" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M10 15l5.19-3L10 9v6m11.56-7.83c.13.47.22 1.1.28 1.9.07.8.1 1.49.1 2.09L22 12c0 2.19-.16 3.8-.44 4.83-.25.9-.83 1.48-1.73 1.73-.47.13-1.33.22-2.65.28-1.3.07-2.49.1-3.59.1L12 19c-4.19 0-6.8-.16-7.83-.44-.9-.25-1.48-.83-1.73-1.73-.13-.47-.22-1.1-.28-1.9-.07-.8-.1-1.49-.1-2.09L2 12c0-2.19.16-3.8.44-4.83.25-.9.83-1.48 1.73-1.73.47-.13 1.33-.22 2.65-.28 1.3-.07 2.49-.1 3.59-.1L12 5c4.19 0 6.8.16 7.83.44.9.25 1.48.83 1.73 1.73z"/>
                        </svg>
                        YouTube
                    </button>
                </div>
                <div class="header-controls-right">
                    <button class="header-ctrl-btn undo" onclick="undoLastAction()" title="Retour">
                        <svg width="12" height="12" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>
                        </svg>
                        Retour
                    </button>
                    <button class="header-ctrl-btn cancel" onclick="cancelPoint()" title="Annuler le point">
                        <svg width="12" height="12" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                        </svg>
                        Annuler point
                    </button>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Overlay pr√©-match : cam√©ra + service (affich√© avant le 1er point) -->
            <div class="pre-match-overlay" id="preMatchOverlay">
                <div class="pre-match-card">
                    <div class="pre-match-section">
                        <div class="pre-match-label">
                            <svg fill="currentColor" viewBox="0 0 24 24" width="18" height="18">
                                <path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/>
                            </svg>
                            √âquipe c√¥t√© cam√©ra (terrain du bas)
                        </div>
                        <div class="pre-match-toggle" id="preMatchCameraToggle">
                            <button class="pre-match-option selected" data-value="home" onclick="preMatchSelect('camera', 'home')">Jen et ses Saints</button>
                            <button class="pre-match-option" data-value="away" onclick="preMatchSelect('camera', 'away')" id="preMatchCameraAway">Adversaire</button>
                        </div>
                    </div>
                    <div class="pre-match-section">
                        <div class="pre-match-label">
                            <svg fill="currentColor" viewBox="0 0 24 24" width="18" height="18">
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                            </svg>
                            Qui sert ?
                        </div>
                        <div class="pre-match-toggle" id="preMatchServingToggle">
                            <button class="pre-match-option" data-value="home" onclick="preMatchSelect('serving', 'home')">Jen et ses Saints</button>
                            <button class="pre-match-option selected" data-value="away" onclick="preMatchSelect('serving', 'away')" id="preMatchServingAway">Adversaire</button>
                        </div>
                    </div>
                    <button class="pre-match-start-btn" onclick="confirmPreMatch()">
                        <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        D√©marrer le Set
                    </button>
                </div>
            </div>

            <!-- Phase Indicator -->
            <div class="phase-indicator" id="phaseIndicator">
                <span class="highlight">Service</span> ‚Äî S√©lectionnez le serveur
            </div>

            <!-- Court -->
            <div class="court-container" id="courtContainer">
                <!-- Zone out cliquable (visible pendant serve_end) -->
                <div class="out-area" id="outArea">
                    <span class="out-area-label top" id="outLabelTop">OUT</span>
                    <span class="out-area-label bottom" id="outLabelBottom">OUT</span>
                    <span class="out-area-label left">OUT</span>
                    <span class="out-area-label right">OUT</span>
                </div>
                
                <div class="court" id="court">
                    <!-- Zone de service haut -->
                    <div class="service-zone top" id="serviceZoneTop">
                        <span class="service-zone-label">Zone de service</span>
                    </div>
                    
                    <div class="team-label" id="topTeamLabel">Adversaire</div>
                    <div class="court-half away" id="courtTop" data-team="away">
                        <!-- Zones de position (pour auto-s√©lection r√©ception) -->
                        <div class="position-zones" id="positionZonesTop">
                            <div class="position-zone" data-zone="left"></div>
                            <div class="position-zone" data-zone="center"></div>
                            <div class="position-zone" data-zone="right"></div>
                        </div>
                        <!-- Zones d'attaque (pour auto-s√©lection attaquant) -->
                        <div class="attack-zones" id="attackZonesTop">
                            <div class="attack-zone" data-zone="left"></div>
                            <div class="attack-zone" data-zone="center"></div>
                            <div class="attack-zone" data-zone="right"></div>
                        </div>
                        <!-- Zones de d√©fense (pour auto-s√©lection d√©fenseur) -->
                        <div class="defense-zones" id="defenseZonesTop">
                            <div class="defense-zone" data-zone="line"></div>
                            <div class="defense-zone" data-zone="diagonal"></div>
                            <div class="defense-zone" data-zone="short"></div>
                            <div class="defense-zone" data-zone="extra"></div>
                        </div>
                        <!-- Zones de qualit√© de r√©ception -->
                        <div class="reception-quality-zones" id="qualityZonesTop">
                            <div class="quality-zone average"></div>
                            <div class="quality-zone good"></div>
                            <div class="quality-zone perfect"></div>
                        </div>
                        <!-- Zone de qualit√© de d√©fense (D+) -->
                        <div class="defense-quality-zones" id="defQualityZonesTop">
                            <div class="defense-quality-zone positive"></div>
                        </div>
                        <!-- Zone debug qualit√© de passe (V19.1d) -->
                        <div class="pass-quality-grid" id="passGridTop"></div>
                    </div>
                    <div class="net" id="netZone">
                        <div class="net-click-zone" id="netClickZone">
                            <div class="net-zone-half" id="netZoneLeft"></div>
                            <div class="net-zone-half" id="netZoneRight"></div>
                        </div>
                    </div>
                    <div class="court-half home" id="courtBottom" data-team="home">
                        <!-- Zones de position (pour auto-s√©lection r√©ception) -->
                        <div class="position-zones" id="positionZonesBottom">
                            <div class="position-zone" data-zone="left"></div>
                            <div class="position-zone" data-zone="center"></div>
                            <div class="position-zone" data-zone="right"></div>
                        </div>
                        <!-- Zones d'attaque (pour auto-s√©lection attaquant) -->
                        <div class="attack-zones" id="attackZonesBottom">
                            <div class="attack-zone" data-zone="left"></div>
                            <div class="attack-zone" data-zone="center"></div>
                            <div class="attack-zone" data-zone="right"></div>
                        </div>
                        <!-- Zones de d√©fense (pour auto-s√©lection d√©fenseur) -->
                        <div class="defense-zones" id="defenseZonesBottom">
                            <div class="defense-zone" data-zone="line"></div>
                            <div class="defense-zone" data-zone="diagonal"></div>
                            <div class="defense-zone" data-zone="short"></div>
                            <div class="defense-zone" data-zone="extra"></div>
                        </div>
                        <!-- Zones de qualit√© de r√©ception -->
                        <div class="reception-quality-zones" id="qualityZonesBottom">
                            <div class="quality-zone average"></div>
                            <div class="quality-zone good"></div>
                            <div class="quality-zone perfect"></div>
                        </div>
                        <!-- Zone de qualit√© de d√©fense (D+) -->
                        <div class="defense-quality-zones" id="defQualityZonesBottom">
                            <div class="defense-quality-zone positive"></div>
                        </div>
                        <!-- Zone debug qualit√© de passe (V19.1d) -->
                        <div class="pass-quality-grid" id="passGridBottom"></div>
                    </div>
                    <div class="team-label" id="bottomTeamLabel">Jen et ses Saints</div>
                    
                    <!-- Zone de service bas -->
                    <div class="service-zone bottom" id="serviceZoneBottom">
                        <span class="service-zone-label">Zone de service</span>
                    </div>
                </div>
                
                <!-- SVG for arrows (dans court-container pour couvrir la zone out) -->
                <svg class="arrow-svg" id="arrowSvg">
                    <defs>
                        <marker id="arrowhead-service" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-service" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-reception" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-reception" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-pass" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-pass" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-attack" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-attack" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-attack-feinte" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-attack-feinte" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-attack-relance" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-attack-relance" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-attack-second" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-attack-second" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-defense" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-defense" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-block" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-block" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-block-touch" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-block-touch" points="0 0, 10 3.5, 0 7" />
                        </marker>
                    </defs>
                </svg>
            </div>

            <!-- Tags Container -->
            <div class="tags-container" id="tagsContainer">
                <!-- Server selection (initial) -->
                <div id="serverSelection">
                    <div class="tags-title">Qui sert ?</div>
                    <div class="tags-grid" id="serverTags">
                        <!-- Generated dynamically -->
                    </div>
                </div>

                <!-- Server continue indicator -->
                <div id="serverContinue" class="hidden">
                    <div class="server-continue-banner" id="serverContinueBanner">
                        üèê <span class="server-name" id="serverContinueName">Joueur</span> toujours au service
                    </div>
                </div>

                <!-- Options 2√®me touche (visible uniquement pendant la phase passe) -->
                <div id="secondTouchOptions" class="hidden">
                    <div class="tags-title">Ou action en 2√®me touche</div>
                    <div class="tags-grid">
                        <button class="action-tag second-touch" onclick="WorkflowEngine.handleButton('secondTouch', 'deuxieme_main')">‚úã Deuxi√®me main</button>
                        <button class="action-tag second-touch" onclick="WorkflowEngine.handleButton('secondTouch', 'attaque_directe')">‚ö° Attaque directe</button>
                        <button class="action-tag relance" onclick="WorkflowEngine.handleButton('secondTouch', 'relance')">‚Ü©Ô∏è Relance</button>
                        <button class="action-tag faute" onclick="WorkflowEngine.handleButton('passFault')">‚úñ Faute passe</button>
                    </div>
                </div>

                <!-- Choix retour direct passe (passe qui va chez l'adversaire) -->
                <div id="passDirectReturnChoice" class="hidden">
                    <div class="tags-title">Passe chez l'adversaire ‚Äî Que se passe-t-il ?</div>
                    <div class="tags-grid">
                        <button class="action-tag direct-return" onclick="WorkflowEngine.handleButton('defense')">üõ°Ô∏è D√©fendu</button>
                        <button class="action-tag direct-return" onclick="WorkflowEngine.handleButton('direct_attack')">‚ö° Attaque directe</button>
                        <button class="action-tag direct-return-winner" onclick="WorkflowEngine.handleButton('winner')">‚úÖ Point direct</button>
                    </div>
                </div>

                <!-- Attack type selection -->
                <div id="attackTypeSelection" class="hidden">
                    <div class="tags-title">Type d'attaque</div>
                    <div class="tags-grid">
                        <button class="action-tag feinte" onclick="WorkflowEngine.handleButton('selectAttackType', 'feinte')">üéØ Feinte</button>
                        <button class="action-tag relance" onclick="WorkflowEngine.handleButton('selectAttackType', 'relance')">‚Ü©Ô∏è¬è Relance</button>
                    </div>
                </div>

                <!-- Result selection -->
                <div id="resultSelection" class="hidden">
                    <div class="tags-title">R√©sultat de l'attaque</div>
                    <div class="tags-grid">
                        <button class="action-tag point" onclick="WorkflowEngine.handleButton('point')">‚úî Point</button>
                        <button class="action-tag faute" onclick="WorkflowEngine.handleButton('defenseFault')">‚ùå D√©fense faute</button>
                    </div>
                </div>

                <!-- Faute de r√©ception + Ace -->
                <div id="receptionFaultSection" class="hidden">
                    <div class="tags-grid">
                        <button class="action-tag ace" onclick="WorkflowEngine.handleButton('ace')">üéØ Ace</button>
                        <button class="action-tag faute" onclick="WorkflowEngine.handleButton('receptionFault')">‚ùå Faute r√©ception</button>
                    </div>
                    <div class="quality-legend">
                        <span class="legend-item"><span class="legend-dot perfect"></span>Excellente 4/4</span>
                        <span class="legend-item"><span class="legend-dot good"></span>Positive 3/4</span>
                        <span class="legend-item"><span class="legend-dot average"></span>Jouable 2/4</span>
                        <span class="legend-item"><span class="legend-dot poor"></span>N√©gative 1/4</span>
                    </div>
                </div>

                <!-- Choix retour terrain adverse (r√©ception qui va chez l'adversaire) -->
                <div id="receptionOpponentChoice" class="hidden">
                    <div class="tags-title">Retour direct ‚Äî Que se passe-t-il ?</div>
                    <div class="tags-grid">
                        <button class="action-tag direct-return" onclick="WorkflowEngine.handleButton('defense')">üõ°Ô∏è¬è D√©fendu</button>
                        <button class="action-tag direct-return" onclick="WorkflowEngine.handleButton('direct_attack')">‚ö° Attaque directe</button>
                        <button class="action-tag direct-return-winner" onclick="WorkflowEngine.handleButton('winner')">‚úÖ Retour gagnant</button>
                    </div>
                </div>

                <!-- Choix r√©ception dans le filet -->
                <div id="receptionNetChoice" class="hidden">
                    <div class="tags-title">R√©ception filet ‚Äî Attaque directe ou cliquez le terrain = block</div>
                    <div class="tags-grid">
                        <button class="action-tag direct-return-winner" onclick="WorkflowEngine.handleButton('direct_attack')">‚ö° Attaque directe</button>
                    </div>
                </div>

                <!-- Choix passe dans le filet -->
                <div id="passNetChoice" class="hidden">
                    <div class="tags-title">Passe filet ‚Äî Attaque directe ou cliquez le terrain = block</div>
                    <div class="tags-grid">
                        <button class="action-tag direct-return-winner" onclick="WorkflowEngine.handleButton('direct_attack')">‚ö° Attaque directe</button>
                    </div>
                </div>

                <!-- Choix attaque dans le filet -->
                <div id="attackNetChoice" class="hidden">
                    <div class="tags-title">Attaque dans le filet ‚Äî Faute ou cliquez le terrain = block</div>
                    <div class="tags-grid">
                        <button class="action-tag faute" onclick="WorkflowEngine.handleButton('faute')">‚ùå Faute (filet)</button>
                        <button class="action-tag bloc-out" onclick="WorkflowEngine.handleButton('bloc_out')">üí• Bloc out</button>
                    </div>
                </div>

                <!-- Actions sp√©ciales depuis d√©fense (visible apr√®s block ou en contexte adapt√©) -->
                <div id="defenseDirectAttackSection" class="hidden">
                    <div class="tags-grid">
                        <button class="action-tag direct-return" onclick="WorkflowEngine.handleButton('directAttack')">‚ö° Attaque directe</button>
                        <button id="blockKillBtn" class="action-tag point hidden" onclick="WorkflowEngine.handleButton('blockKill')">üíÄ Bloc Kill</button>
                    </div>
                </div>


                <!-- Choix retour direct d√©fense (d√©fense qui va chez l'adversaire) -->
                <div id="defenseDirectReturnChoice" class="hidden">
                    <div class="tags-title">Retour direct d√©fense ‚Äî Que se passe-t-il ?</div>
                    <div class="tags-grid">
                        <button class="action-tag direct-return" onclick="WorkflowEngine.handleButton('defense')">üõ°Ô∏è D√©fendu</button>
                        <button class="action-tag direct-return" onclick="WorkflowEngine.handleButton('direct_attack')">‚ö° Attaque directe</button>
                        <button class="action-tag direct-return-winner" onclick="WorkflowEngine.handleButton('winner')">‚úÖ Retour gagnant</button>
                    </div>
                </div>
                <!-- D√©fense faute / Point block (visible pendant defense_end) -->
                <div id="defenseFaultSection" class="hidden">
                    <div class="tags-grid">
                        <button class="action-tag point" onclick="WorkflowEngine.handleButton('defensePoint')">‚úî Point</button>
                        <button class="action-tag faute" onclick="WorkflowEngine.handleButton('defenseFault')">‚ùå D√©fense faute</button>
                    </div>
                </div>

                <!-- Phase trajectoire bloc out -->
                <div id="blocOutTrajectory" class="hidden">
                    <div class="tags-title">Cliquez o√π va la balle (trajectoire du bloc out)</div>
                    <div class="tags-grid">
                        <button class="action-tag" onclick="WorkflowEngine.handleButton('skip')">‚è© Passer</button>
                    </div>
                </div>

                <!-- Phase trajectoire faute d√©fense -->
                <div id="defenseFaultTrajectory" class="hidden">
                    <div class="tags-title">Cliquez o√π va la balle (trajectoire de la faute)</div>
                    <div class="tags-grid">
                        <button class="action-tag" onclick="WorkflowEngine.handleButton('skip')">‚è© Passer</button>
                    </div>
                </div>

                <!-- Phase trajectoire faute de passe (V19.3) -->
                <div id="passFaultTrajectory" class="hidden">
                    <div class="tags-title">Cliquez o√π va la balle (trajectoire faute passe)</div>
                    <div class="tags-grid">
                        <button class="action-tag" onclick="WorkflowEngine.handleButton('skip')">‚è© Passer</button>
                    </div>
                </div>

                <!-- Phase trajectoire faute r√©ception -->
                <div id="receptionFaultTrajectory" class="hidden">
                    <div class="tags-title">Cliquez o√π va la balle (trajectoire de la faute)</div>
                    <div class="tags-grid">
                        <button class="action-tag" onclick="WorkflowEngine.handleButton('skip')">‚è© Passer</button>
                    </div>
                </div>

                <!-- Player override/selection tags (en bas pour priorit√© visuelle aux boutons d'action) -->
                <div id="playerSelection" class="hidden">
                    <div class="tags-title" id="playerSelectionTitle">S√©lectionnez le joueur</div>
                    <div class="tags-grid" id="playerTags">
                        <!-- Generated dynamically -->
                    </div>
                </div>

            </div>
        </main>

        <!-- Tableau de statistiques du set -->
        <div class="stats-section">
            <!-- Tableau √©quipe domicile -->
            <div class="stats-table-container">
                <div class="stats-table-title">üìä <span id="homeTeamStatsTitle">Jen et ses Saints</span></div>
                <div class="stats-tables-container" id="homeStatsContainer">
                    <!-- G√©n√©r√© dynamiquement par renderStatsTable() -->
                </div>
            </div>

            <!-- Tableau √©quipe adverse -->
            <div class="stats-table-container">
                <div class="stats-table-title">üìä <span id="awayTeamStatsTitle">Adversaire</span></div>
                <div class="stats-tables-container" id="awayStatsContainer">
                    <!-- G√©n√©r√© dynamiquement par renderStatsTable() -->
                </div>
            </div>
        </div>

        <!-- Tableau passe d√©taill√©e (V19.2) -->
        <div id="passDetailContainer"></div>

        <!-- Mini-timeline du set en cours -->
        <div class="mini-timeline-section" id="miniTimelineSection">
            <div class="mini-timeline-title">S√©ries de points</div>
            <div class="mini-timeline-chart" id="miniTimelineChart"></div>
        </div>

        <!-- Modal de changement -->
        <div class="sub-modal-overlay" id="subModalOverlay" onclick="closeSubModal(event)">
            <div class="sub-modal" onclick="event.stopPropagation()">
                <div class="sub-modal-title">üîÑ Changement / Positions</div>
                
                <div class="sub-modal-tabs">
                    <button class="sub-modal-tab home active" id="subTabHome" onclick="switchSubTeam('home')">Jen et ses Saints</button>
                    <button class="sub-modal-tab away" id="subTabAway" onclick="switchSubTeam('away')">Adversaire</button>
                </div>

                <div class="sub-modal-hint">Cliquez 2 joueurs sur le terrain pour √©changer leurs positions.<br>Cliquez un rempla√ßant puis un joueur sur le terrain pour substituer.</div>
                
                <!-- Mini court -->
                <div class="sub-mini-court" id="subMiniCourt">
                    <div class="sub-court-row front">
                        <div class="sub-court-slot" id="subSlotPasseur" onclick="subSlotClick('Passeur')">
                            <span class="slot-role">Passeur</span>
                            <span class="slot-player">‚Äî</span>
                        </div>
                    </div>
                    <div class="sub-court-row">
                        <div class="sub-court-slot" id="subSlotR4" onclick="subSlotClick('R4')">
                            <span class="slot-role">R4</span>
                            <span class="slot-player">‚Äî</span>
                        </div>
                        <div class="sub-court-slot" id="subSlotCentre" onclick="subSlotClick('Centre')">
                            <span class="slot-role">Centre</span>
                            <span class="slot-player">‚Äî</span>
                        </div>
                        <div class="sub-court-slot" id="subSlotPointu" onclick="subSlotClick('Pointu')">
                            <span class="slot-role">Pointu</span>
                            <span class="slot-player">‚Äî</span>
                        </div>
                    </div>
                </div>

                <!-- Bench -->
                <div class="sub-bench-section">
                    <div class="sub-bench-label">ü™ë Rempla√ßants :</div>
                    <div class="sub-bench-grid" id="subBenchGrid">
                        <!-- Generated dynamically -->
                    </div>
                </div>

                <!-- Blocker config -->
                <div class="sub-bench-section">
                    <div class="sub-bench-label">üõ°Ô∏è Qui bloque (face au R4) :</div>
                    <div class="sub-blocker-toggle" id="subBlockerRightToggle">
                        <!-- Generated dynamically -->
                    </div>
                </div>
                <div class="sub-bench-section">
                    <div class="sub-bench-label">üõ°Ô∏è Bloqueur principal (2/3 filet) :</div>
                    <div class="sub-blocker-toggle" id="subPrimaryBlockerToggle">
                        <!-- Generated dynamically -->
                    </div>
                </div>

                <!-- Mixit√© -->
                <div class="sub-bench-section" id="subMixiteSection">
                    <div class="sub-bench-label">‚öñÔ∏è Points de mixit√© :</div>
                    <div class="sub-mixite-row">
                        <span class="sub-mixite-team">Jen</span>
                        <input type="number" class="sub-mixite-input" id="subMixiteHome" value="0" min="0" max="10" oninput="setMixite()">
                        <span class="sub-mixite-pts">pts</span>
                        <span class="sub-mixite-sep">‚Äî</span>
                        <span class="sub-mixite-team" id="subMixiteAwayLabel">Adv</span>
                        <input type="number" class="sub-mixite-input" id="subMixiteAway" value="0" min="0" max="10" oninput="setMixite()">
                        <span class="sub-mixite-pts">pts</span>
                    </div>
                </div>

                <div class="sub-modal-actions">
                    <button class="sub-modal-btn cancel" onclick="closeSubModal()">Fermer</button>
                </div>
            </div>
        </div>

        <!-- Modal annuler dernier point -->
        <div class="undo-point-overlay" id="undoPointOverlay" onclick="closeUndoPointModal(event)">
            <div class="undo-point-modal" onclick="event.stopPropagation()">
                <div class="undo-point-title">‚ö†¬†Ô∏è Annuler le dernier point ?</div>
                <div class="undo-point-summary" id="undoPointSummary">
                    <!-- Rempli dynamiquement -->
                </div>
                <div class="undo-point-actions">
                    <button class="undo-point-btn keep" onclick="closeUndoPointModal()">Garder</button>
                    <button class="undo-point-btn remove" onclick="confirmUndoLastPoint()">Supprimer ce point</button>
                </div>
            </div>
        </div>

        <!-- V20.183 : Modal revenir dans le point pr√©c√©dent -->
        <div class="undo-point-overlay" id="resumePointOverlay" onclick="closeResumePointModal(event)">
            <div class="undo-point-modal" onclick="event.stopPropagation()">
                <div class="undo-point-title" style="color: #2563eb;">‚Ü©Ô∏è Revenir dans le point pr√©c√©dent ?</div>
                <div class="undo-point-summary" id="resumePointSummary">
                    <!-- Rempli dynamiquement -->
                </div>
                <div class="undo-point-actions">
                    <button class="undo-point-btn keep" onclick="closeResumePointModal()">Non</button>
                    <button class="undo-point-btn remove" style="background: #2563eb;" onclick="confirmResumeLastPoint()">Oui, revenir</button>
                </div>
            </div>
        </div>

        <!-- Modal fin de set -->
        <div class="end-set-overlay" id="endSetOverlay">
            <div class="end-set-modal" onclick="event.stopPropagation()">
                <div class="end-set-icon" id="endSetIcon">üèÜ</div>
                <div class="end-set-title" id="endSetTitle">Fin du Set</div>
                <div class="end-set-subtitle" id="endSetSubtitle"></div>
                
                <!-- Score actuel -->
                <div class="end-set-score-display" id="endSetScoreDisplay">
                    <div class="team">
                        <div class="team-name">Jen et ses Saints</div>
                        <div class="team-pts" id="endSetHomeScore">0</div>
                    </div>
                    <div class="vs">‚Äî</div>
                    <div class="team">
                        <div class="team-name" id="endSetAwayName">Adversaire</div>
                        <div class="team-pts" id="endSetAwayScore">0</div>
                    </div>
                </div>
                
                <div class="end-set-winner" id="endSetWinner"></div>

                <!-- Choix raison (mode manuel uniquement) -->
                <div class="end-set-reasons" id="endSetReasons" style="display:none;">
                    <button class="end-set-reason-btn" onclick="selectEndReason('camera')">
                        <span class="reason-icon">üîπ</span>
                        <div class="reason-text">
                            <div class="reason-title">Probl√®me cam√©ra</div>
                            <div class="reason-desc">Batterie, chute, obstruction"¬¶ Saisir le score r√©el</div>
                        </div>
                    </button>
                    <button class="end-set-reason-btn" onclick="selectEndReason('time')">
                        <span class="reason-icon">‚è±Ô∏è</span>
                        <div class="reason-text">
                            <div class="reason-title">Fin du cr√©neau</div>
                            <div class="reason-desc">Le set se termine sur le score actuel</div>
                        </div>
                    </button>
                </div>

                <!-- Score r√©el (mode cam√©ra) -->
                <div class="end-set-real-score" id="endSetRealScore">
                    <div class="end-set-real-score-title">Score r√©el de fin de set</div>
                    <div class="end-set-real-score-inputs">
                        <div class="team-input">
                            <label>Jen et ses Saints</label>
                            <input type="number" id="realScoreHome" min="0" max="99" value="0">
                        </div>
                        <div class="input-sep">‚Äî</div>
                        <div class="team-input">
                            <label id="realScoreAwayLabel">Adversaire</label>
                            <input type="number" id="realScoreAway" min="0" max="99" value="0">
                        </div>
                    </div>
                </div>

                <!-- Recap stats -->
                <div class="end-set-stats-recap" id="endSetStatsRecap"></div>

                <!-- Actions -->
                <div class="end-set-actions">
                    <button class="end-set-btn cancel" id="endSetCancelBtn" onclick="closeEndSetModal()">Annuler</button>
                    <button class="end-set-btn cancel" id="endSetBackBtn" onclick="returnToGameForCorrection()">‚Üê¬ê Corriger</button>
                    <button class="end-set-btn confirm" id="endSetConfirmBtn" onclick="confirmEndSet()">Valider</button>
                </div>
            </div>
        </div>

        <!-- ==================== MODAL FIN DE MATCH ==================== -->
        <div class="end-match-overlay" id="endMatchOverlay" onclick="event.stopPropagation()">
            <div class="end-match-modal" onclick="event.stopPropagation()">
                <div class="end-match-icon" id="endMatchIcon">üèÜ</div>
                <div class="end-match-title" id="endMatchTitle">Match termin√© !</div>

                <!-- R√©sultat -->
                <div class="end-match-result">
                    <span class="match-final-score" id="endMatchFinalScore">3 ‚Äì 0</span>
                    <span class="match-final-vs" id="endMatchVs">Jen et ses Saints vs Adversaire</span>
                </div>

                <!-- D√©tail des sets -->
                <div class="end-match-sets-detail" id="endMatchSetsDetail"></div>

                <!-- Stats r√©sum√© du match -->
                <div class="end-match-stats-summary" id="endMatchStatsSummary">
                    <div class="match-stats-grid" id="endMatchStatsGrid"></div>
                </div>

                <!-- Actions -->
                <div class="end-match-actions">
                    <button class="end-set-btn cancel" onclick="returnToGameFromEndMatch()">‚Üê Corriger</button>
                    <button class="end-set-btn confirm" onclick="confirmEndMatch()">Cl√¥turer le match ‚úì</button>
                </div>
            </div>
        </div>

        <!-- ==================== MODAL FIN DE CR√âNEAU (temps √©coul√©) ==================== -->
        <div class="end-match-overlay" id="timeEndOverlay" onclick="event.stopPropagation()">
            <div class="end-match-modal" onclick="event.stopPropagation()">
                <div class="end-match-icon">‚è±Ô∏è</div>
                <div class="end-match-title">Fin du cr√©neau</div>
                <div class="time-end-subtitle">Le match se termine sur le score actuel</div>

                <!-- Score sets -->
                <div class="end-match-result">
                    <span class="match-final-score" id="timeEndFinalScore">0 ‚Äì 0</span>
                    <span class="match-final-vs" id="timeEndVs">Jen et ses Saints vs Adversaire</span>
                </div>

                <!-- D√©tail des sets (avec set en cours) -->
                <div class="end-match-sets-detail" id="timeEndSetsDetail"></div>

                <!-- Stats r√©sum√© du match -->
                <div class="end-match-stats-summary">
                    <div class="match-stats-grid" id="timeEndStatsGrid"></div>
                </div>

                <!-- Actions -->
                <div class="end-match-actions">
                    <button class="end-set-btn cancel" onclick="closeTimeEndModal()">‚Üê Annuler</button>
                    <button class="end-set-btn confirm" onclick="confirmTimeEndMatch()">Cl√¥turer le match ‚úì</button>
                </div>
            </div>
        </div>
    </div>

    <!-- YouTube Panel -->
    <div class="youtube-panel" id="youtubePanel">
        <div class="youtube-player-wrapper" id="youtubePlayerWrapper">
            <div id="youtubePlayer"></div>
            <div class="yt-zoom-overlay" id="ytZoomOverlay"></div>
        </div>
        <div class="youtube-controls" id="youtubeControls">
            <button class="yt-ctrl-btn" onclick="ytRewind()" title="Reculer 2s (‚Üê)">
                <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/></svg>
                ‚àí2s
            </button>
            <button class="yt-ctrl-btn play-pause" onclick="ytTogglePlayPause()" title="Lecture/Pause (Espace)">
                <svg width="18" height="18" fill="currentColor" viewBox="0 0 24 24" id="ytPlayPauseIcon"><path d="M8 5v14l11-7z"/></svg>
            </button>
            <button class="yt-ctrl-btn" onclick="ytForward()" title="Avancer 2s (‚Üí)">
                <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg>
                +2s
            </button>
            <span class="yt-time" id="ytTimeDisplay">0:00 / 0:00</span>
            <div class="yt-volume">
                <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
                <input type="range" class="yt-volume-slider" id="ytVolumeSlider" min="0" max="100" value="100" oninput="ytSetVolume(this.value)">
            </div>
            <button class="yt-ctrl-btn" onclick="ytToggleZoom()" title="Zoom vid√©o (Z)" id="ytZoomBtn">
                <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
            </button>
        </div>
    </div>

    </div><!-- /layout-wrapper -->

    <!-- Modal YouTube URL -->
    <div class="yt-url-overlay" id="ytUrlOverlay" onclick="closeYoutubeModal(event)">
        <div class="yt-url-modal" onclick="event.stopPropagation()">
            <div class="yt-url-title">Lien YouTube</div>
            <input type="url" id="ytUrlInput" class="yt-url-input" placeholder="https://www.youtube.com/watch?v=...">
            <div class="yt-url-actions">
                <button class="yt-url-btn cancel" onclick="closeYoutubeModal()">Annuler</button>
                <button class="yt-url-btn confirm" onclick="confirmYoutubeUrl()">Valider</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK (compat CDN) ‚Äî pour upload du match √† la finalisation -->
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
    <script src="firebase-config.js"></script>
    <script src="admin-config.js"></script>
    <script src="firebase-sync.js"></script>

    <script src="storage.js"></script>
    <script src="match-live-helpers.js"></script>
    <script src="match-live-undo.js"></script>
    <script src="match-live-workflow.js?v=18.0"></script>

    <!-- YouTube iframe API (charg√© dynamiquement) -->
    <script>
        // ==================== YOUTUBE PLAYER ====================
        let ytPlayer = null;
        let ytReady = false;
        let ytTimeInterval = null;

        function loadYouTubeAPI() {
            if (window.YT && window.YT.Player) return Promise.resolve();
            return new Promise((resolve) => {
                window.onYouTubeIframeAPIReady = resolve;
                const tag = document.createElement('script');
                tag.src = 'https://www.youtube.com/iframe_api';
                document.head.appendChild(tag);
            });
        }

        // Parse une URL YouTube et retourne { videoId, playlistId, index }
        function parseYouTubeUrl(url) {
            if (!url) return null;
            const result = { videoId: null, playlistId: null, index: 0 };

            // Playlist URL: youtube.com/playlist?list=PLxxx
            const plMatch = url.match(/[?&]list=([a-zA-Z0-9_-]+)/);
            if (plMatch) result.playlistId = plMatch[1];

            // Video index in playlist: &index=N (1-based dans l'URL)
            const idxMatch = url.match(/[?&]index=(\d+)/);
            if (idxMatch) result.index = Math.max(0, parseInt(idxMatch[1]) - 1);

            // Video ID
            const vidPatterns = [
                /(?:youtube\.com\/watch\?.*v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/)([a-zA-Z0-9_-]{11})/,
                /^([a-zA-Z0-9_-]{11})$/
            ];
            for (const pattern of vidPatterns) {
                const match = url.match(pattern);
                if (match) { result.videoId = match[1]; break; }
            }

            // Au moins un des deux doit √™tre pr√©sent
            if (!result.videoId && !result.playlistId) return null;
            return result;
        }

        async function initYouTubePlayer(parsed) {
            if (!parsed) return;

            document.body.classList.remove('classic-mode');
            document.body.classList.add('video-mode');

            await loadYouTubeAPI();

            const playerVars = {
                autoplay: 0,
                controls: 1,
                modestbranding: 1,
                rel: 0,
                fs: 1,
                iv_load_policy: 3,
                disablekb: 1
            };

            // Si playlist, charger via listType/list
            if (parsed.playlistId) {
                playerVars.listType = 'playlist';
                playerVars.list = parsed.playlistId;
                playerVars.index = parsed.index;
            }

            const opts = {
                playerVars: playerVars,
                events: {
                    onReady: onYTPlayerReady,
                    onStateChange: onYTStateChange
                }
            };

            // Si vid√©o individuelle (sans playlist), sp√©cifier videoId
            if (parsed.videoId && !parsed.playlistId) {
                opts.videoId = parsed.videoId;
            }

            ytPlayer = new YT.Player('youtubePlayer', opts);
        }

        function onYTPlayerReady(event) {
            ytReady = true;
            updateYTTimeDisplay();
            ytTimeInterval = setInterval(updateYTTimeDisplay, 500);
        }

        function onYTStateChange(event) {
            const iconEl = document.getElementById('ytPlayPauseIcon');
            if (!iconEl) return;
            if (event.data === YT.PlayerState.PLAYING) {
                iconEl.innerHTML = '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>';
            } else {
                iconEl.innerHTML = '<path d="M8 5v14l11-7z"/>';
            }
        }

        function ytTogglePlayPause() {
            if (!ytPlayer || !ytReady) return;
            const state = ytPlayer.getPlayerState();
            if (state === YT.PlayerState.PLAYING) {
                ytPlayer.pauseVideo();
            } else {
                ytPlayer.playVideo();
            }
        }

        function ytSetVolume(val) {
            if (!ytPlayer || !ytReady) return;
            ytPlayer.setVolume(parseInt(val));
        }

        function ytRewind() {
            if (!ytPlayer || !ytReady) return;
            const t = ytPlayer.getCurrentTime();
            ytPlayer.seekTo(Math.max(0, t - 2), true);
        }

        function ytForward() {
            if (!ytPlayer || !ytReady) return;
            const t = ytPlayer.getCurrentTime();
            ytPlayer.seekTo(t + 2, true);
        }

        function updateYTTimeDisplay() {
            if (!ytPlayer || !ytReady) return;
            const current = ytPlayer.getCurrentTime() || 0;
            const duration = ytPlayer.getDuration() || 0;
            const fmt = (s) => {
                const m = Math.floor(s / 60);
                const sec = Math.floor(s % 60);
                return `${m}:${sec.toString().padStart(2, '0')}`;
            };
            const el = document.getElementById('ytTimeDisplay');
            if (el) el.textContent = `${fmt(current)} / ${fmt(duration)}`;
        }

        function loadYouTubeForCurrentSet() {
            const match = Storage.getCurrentMatch();
            if (!match) return;
            const si = (match.sets?.length || 1) - 1;
            const set = match.sets?.[si];
            const parsed = parseYouTubeUrl(set?.youtubeUrl);

            if (!parsed) {
                document.body.classList.add('classic-mode');
                document.body.classList.remove('video-mode');
                return;
            }

            if (ytPlayer && ytReady) {
                if (parsed.playlistId) {
                    ytPlayer.loadPlaylist({ list: parsed.playlistId, listType: 'playlist', index: parsed.index });
                } else if (parsed.videoId) {
                    ytPlayer.loadVideoById(parsed.videoId);
                }
            } else {
                initYouTubePlayer(parsed);
            }
        }

        // ==================== MODAL YOUTUBE URL ====================
        function openYoutubeModal() {
            const match = Storage.getCurrentMatch();
            const si = (match?.sets?.length || 1) - 1;
            const currentUrl = match?.sets?.[si]?.youtubeUrl || '';
            const input = document.getElementById('ytUrlInput');
            input.value = currentUrl;
            document.getElementById('ytUrlOverlay').classList.add('active');
            input.focus();
            input.select();
        }

        document.getElementById('ytUrlInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') { e.preventDefault(); confirmYoutubeUrl(); }
            if (e.key === 'Escape') { e.preventDefault(); closeYoutubeModal(); }
        });

        function closeYoutubeModal(e) {
            if (e && e.target !== e.currentTarget) return;
            document.getElementById('ytUrlOverlay').classList.remove('active');
        }

        function confirmYoutubeUrl() {
            const url = document.getElementById('ytUrlInput').value.trim();

            // Mettre √† jour la variable en m√©moire ET le localStorage
            currentSet.youtubeUrl = url;
            currentMatch.sets[setIndex] = currentSet;
            Storage.saveCurrentMatch(currentMatch);

            closeYoutubeModal();

            if (url) {
                loadYouTubeForCurrentSet();
            } else {
                document.body.classList.add('classic-mode');
                document.body.classList.remove('video-mode');
            }
        }

        function updateYoutubeButtonState() {
            // Fonction conserv√©e pour coh√©rence d'appel (init + confirm)
        }

        // Zoom vid√©o : masque l'app pour agrandir la vid√©o
        function ytToggleZoom() {
            if (!document.body.classList.contains('video-mode')) return;
            document.body.classList.toggle('video-zoom');
            // Ic√¥ne : plein √©cran ‚Üî r√©duire
            const btn = document.getElementById('ytZoomBtn');
            if (btn) {
                const isZoomed = document.body.classList.contains('video-zoom');
                btn.innerHTML = isZoomed
                    ? '<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/></svg>'
                    : '<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>';
            }
        }

        // Raccourcis clavier pour le player YouTube
        document.addEventListener('keydown', function(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

            // Z = zoom vid√©o (fonctionne m√™me sans player pr√™t)
            if (e.key === 'z' || e.key === 'Z') {
                e.preventDefault();
                ytToggleZoom();
                return;
            }

            if (!ytPlayer || !ytReady) return;

            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    ytTogglePlayPause();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    ytRewind();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    ytForward();
                    break;
            }
        });
    </script>

    <script>
        // ==================== DONN√âES ====================
        const currentMatch = Storage.getCurrentMatch();
        let currentSet = null;
        let setIndex = 0;

        // √âtat du jeu
        let gameState = {
            phase: 'server_selection', // server_selection, serve_start, serve_end, reception, pass, attack_player, attack_type, attack_start, attack_end, result, defense, defense_end, etc.
            servingTeam: 'away', // qui sert actuellement
            attackingTeam: 'home', // qui attaque actuellement
            currentServer: null,
            clicks: [], // positions cliqu√©es
            currentAction: {}, // action en cours
            rally: [], // toutes les actions du point en cours
            homeScore: 0,
            awayScore: 0,
            setEnded: false,
            receptionAutoSelected: false, // true si le r√©ceptionneur a √©t√© auto-s√©lectionn√© via zone pendant serve_end
            passAutoSelected: false, // true si le passeur a √©t√© auto-s√©lectionn√© (r√©ception excellente)
            attackAutoSelected: false, // true si l'attaquant a √©t√© auto-s√©lectionn√© via zone pendant pass
            receptionOpponentClickData: null, // donn√©es du clic terrain adverse pendant reception_end
            overridePlayer: null, // joueur manuellement overrid√© via tag (Phase 2)
            autoSelectedPlayer: null, // joueur auto-s√©lectionn√© par zone/logique (Phase 2)
            overrideTagsTeam: null, // √©quipe des tags override affich√©s (Phase 2)
            context: null // Objet contexte structur√© (V18.0 ‚Äî initialis√© par WorkflowEngine)
        };

        // Statistiques du set (format unifi√© avec historique)
        let setStats = {
            home: {}, // { playerName: { service: {...}, reception: {...}, attack: {...}, relance: {tot, relplus, relminus, frel}, defense: {...}, block: {...} } }
            away: {}
        };

        function _passCtx() { return { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0 }; }

        function initPlayerStats() {
            return {
                service:   { tot: 0, ace: 0, splus: 0, fser: 0, recSumAdv: 0, recCountAdv: 0 },
                reception: { tot: 0, r4: 0, r3: 0, r2: 0, r1: 0, frec: 0 },
                pass: {
                    tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0,
                    passeur: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0,
                        confort: _passCtx(), contraint: _passCtx(), transition: _passCtx() },
                    autre: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0,
                        contraint: _passCtx(), transition: _passCtx() }
                },
                attack:    { tot: 0, attplus: 0, attminus: 0, bp: 0, fatt: 0 },
                relance:   { tot: 0, relplus: 0, relminus: 0, frel: 0 },
                defense:   { tot: 0, defplus: 0, defneutral: 0, defminus: 0, fdef: 0 },
                block:     { tot: 0, blcplus: 0, blcminus: 0, fblc: 0 }
            };
        }

        function initSetStats() {
            setStats = { home: {}, away: {} };
            
            // Initialiser les stats pour les joueurs de l'√©quipe home
            if (currentSet && currentSet.homeLineup) {
                Object.values(currentSet.homeLineup).forEach(name => {
                    if (name) setStats.home[name] = initPlayerStats(name);
                });
            }
            
            // Initialiser les stats pour les joueurs de l'√©quipe adverse
            if (currentSet && currentSet.awayLineup) {
                Object.values(currentSet.awayLineup).forEach(name => {
                    if (name) setStats.away[name] = initPlayerStats(name);
                });
            }
            
            renderStatsTables();
        }

        function renderStatsTables() {
            renderStatsTable('home', 'homeStatsContainer');
            renderStatsTable('away', 'awayStatsContainer');
            renderPassDetailTable();
        }

        function renderStatsTable(team, containerId) {
            const container = document.getElementById(containerId);
            const stats = setStats[team];
            const players = Object.keys(stats);

            if (players.length === 0) {
                container.innerHTML = '';
                return;
            }

            // Helper pour g√©n√©rer une cellule avec couleur conditionnelle
            function cell(val, cls) {
                return '<td class="' + (val > 0 ? cls : '') + '">' + (val || '-') + '</td>';
            }

            // Calculer les totaux
            const totals = {
                service:   { tot: 0, ace: 0, splus: 0, fser: 0, recSumAdv: 0, recCountAdv: 0 },
                reception: { tot: 0, r4: 0, r3: 0, r2: 0, r1: 0, frec: 0 },
                pass:      { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0 },
                attack:    { tot: 0, attplus: 0, attminus: 0, bp: 0, fatt: 0 },
                relance:   { tot: 0, relplus: 0, relminus: 0, frel: 0 },
                defense:   { tot: 0, defplus: 0, defneutral: 0, defminus: 0, fdef: 0 },
                block:     { tot: 0, blcplus: 0, blcminus: 0, fblc: 0 }
            };

            players.forEach(name => {
                const p = stats[name];
                totals.service.tot += p.service.tot;
                totals.service.ace += p.service.ace;
                totals.service.splus += p.service.splus;
                totals.service.fser += p.service.fser;
                totals.service.recSumAdv += p.service.recSumAdv;
                totals.service.recCountAdv += p.service.recCountAdv;
                totals.reception.tot += p.reception.tot;
                totals.reception.r4 += p.reception.r4;
                totals.reception.r3 += p.reception.r3;
                totals.reception.r2 += p.reception.r2;
                totals.reception.r1 += p.reception.r1;
                totals.reception.frec += p.reception.frec;
                totals.pass.tot += p.pass.tot;
                totals.pass.p4 += p.pass.p4;
                totals.pass.p3 += p.pass.p3;
                totals.pass.p2 += p.pass.p2;
                totals.pass.p1 += p.pass.p1;
                totals.pass.fp += p.pass.fp;
                totals.attack.tot += p.attack.tot;
                totals.attack.attplus += p.attack.attplus;
                totals.attack.attminus += p.attack.attminus;
                totals.attack.bp += p.attack.bp;
                totals.attack.fatt += p.attack.fatt;
                totals.relance.tot += p.relance.tot;
                totals.relance.relplus += p.relance.relplus;
                totals.relance.relminus += p.relance.relminus;
                totals.relance.frel += p.relance.frel;
                totals.defense.tot += p.defense.tot;
                totals.defense.defplus += p.defense.defplus;
                totals.defense.defneutral += p.defense.defneutral;
                totals.defense.defminus += p.defense.defminus;
                totals.defense.fdef += p.defense.fdef;
                totals.block.tot += p.block.tot;
                totals.block.blcplus += p.block.blcplus;
                totals.block.blcminus += p.block.blcminus;
                totals.block.fblc += p.block.fblc;
            });

            let html = '';

            // ===== COLONNE DES NOMS =====
            html += '<div class="stats-players-col">' +
                '<div class="player-header">Joueur</div>' +
                '<div class="player-subheader"></div>';
            players.forEach(name => {
                html += '<div class="player-name">' + name + '</div>';
            });
            html += '<div class="player-name total-row">Total</div></div>';

            // Helper pour calculer la moyenne service (Moy)
            // recCountAdv inclut les r√©ceptions sur ace (note 0)
            function srvMoy(p) {
                const count = p.service.recCountAdv;
                if (count === 0) return '-';
                const moy = p.service.recSumAdv / count;
                return moy.toFixed(1);
            }
            function srvMoyClass(p) {
                const count = p.service.recCountAdv;
                if (count === 0) return '';
                const moy = p.service.recSumAdv / count;
                if (moy <= 1.5) return 'positive';
                if (moy >= 3.0) return 'negative';
                return '';
            }

            // ===== SERVICE =====
            html += '<div class="stat-table-card">' +
                '<div class="stat-table-header service">Service</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th>Tot</th><th>Ace</th><th>S+</th><th>FS</th><th>Moy</th>' +
                '</tr></thead><tbody>';
            players.forEach(name => {
                const p = stats[name];
                html += '<tr>' +
                    '<td>' + (p.service.tot || '-') + '</td>' +
                    cell(p.service.ace, 'positive') +
                    cell(p.service.splus, 'positive') +
                    cell(p.service.fser, 'negative') +
                    '<td class="' + srvMoyClass(p) + '">' + srvMoy(p) + '</td>' +
                '</tr>';
            });
            html += '<tr class="total-row">' +
                '<td>' + (totals.service.tot || '-') + '</td>' +
                cell(totals.service.ace, 'positive') +
                cell(totals.service.splus, 'positive') +
                cell(totals.service.fser, 'negative') +
                '<td class="' + srvMoyClass({ service: totals.service }) + '">' + srvMoy({ service: totals.service }) + '</td>' +
            '</tr></tbody></table></div>';

            // ===== R√âCEPTION =====
            html += '<div class="stat-table-card">' +
                '<div class="stat-table-header reception">R√©ception</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th>Tot</th><th>R4</th><th>R3</th><th>R2</th><th>R1</th><th>FR</th>' +
                '</tr></thead><tbody>';
            players.forEach(name => {
                const p = stats[name];
                html += '<tr>' +
                    '<td>' + (p.reception.tot || '-') + '</td>' +
                    cell(p.reception.r4, 'positive') +
                    cell(p.reception.r3, 'positive') +
                    cell(p.reception.r2, 'neutral') +
                    cell(p.reception.r1, 'negative') +
                    cell(p.reception.frec, 'negative') +
                '</tr>';
            });
            html += '<tr class="total-row">' +
                '<td>' + (totals.reception.tot || '-') + '</td>' +
                cell(totals.reception.r4, 'positive') +
                cell(totals.reception.r3, 'positive') +
                cell(totals.reception.r2, 'neutral') +
                cell(totals.reception.r1, 'negative') +
                cell(totals.reception.frec, 'negative') +
            '</tr></tbody></table></div>';

            // ===== PASSE =====
            html += '<div class="stat-table-card">' +
                '<div class="stat-table-header passe">Passe</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th>Tot</th><th>P4</th><th>P3</th><th>P2</th><th>P1</th><th>FP</th>' +
                '</tr></thead><tbody>';
            players.forEach(name => {
                const p = stats[name];
                html += '<tr>' +
                    '<td>' + (p.pass.tot || '-') + '</td>' +
                    cell(p.pass.p4, 'positive') +
                    cell(p.pass.p3, 'positive') +
                    cell(p.pass.p2, 'neutral') +
                    cell(p.pass.p1, 'negative') +
                    cell(p.pass.fp, 'negative') +
                '</tr>';
            });
            html += '<tr class="total-row">' +
                '<td>' + (totals.pass.tot || '-') + '</td>' +
                cell(totals.pass.p4, 'positive') +
                cell(totals.pass.p3, 'positive') +
                cell(totals.pass.p2, 'neutral') +
                cell(totals.pass.p1, 'negative') +
                cell(totals.pass.fp, 'negative') +
            '</tr></tbody></table></div>';

            // ===== ATTAQUE =====
            html += '<div class="stat-table-card">' +
                '<div class="stat-table-header attack">Attaque</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th>Tot</th><th>A+</th><th>A-</th><th>BP</th><th>FA</th>' +
                '</tr></thead><tbody>';
            players.forEach(name => {
                const p = stats[name];
                html += '<tr>' +
                    '<td>' + (p.attack.tot || '-') + '</td>' +
                    cell(p.attack.attplus, 'positive') +
                    cell(p.attack.attminus, 'neutral') +
                    cell(p.attack.bp, 'negative') +
                    cell(p.attack.fatt, 'negative') +
                '</tr>';
            });
            html += '<tr class="total-row">' +
                '<td>' + (totals.attack.tot || '-') + '</td>' +
                cell(totals.attack.attplus, 'positive') +
                cell(totals.attack.attminus, 'neutral') +
                cell(totals.attack.bp, 'negative') +
                cell(totals.attack.fatt, 'negative') +
            '</tr></tbody></table></div>';

            // ===== RELANCE =====
            html += '<div class="stat-table-card">' +
                '<div class="stat-table-header relance">Relance</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th>Tot</th><th>R+</th><th>R-</th><th>FRel</th>' +
                '</tr></thead><tbody>';
            players.forEach(name => {
                const p = stats[name];
                html += '<tr>' +
                    '<td>' + (p.relance.tot || '-') + '</td>' +
                    cell(p.relance.relplus, 'positive') +
                    cell(p.relance.relminus, 'neutral') +
                    cell(p.relance.frel, 'negative') +
                '</tr>';
            });
            html += '<tr class="total-row">' +
                '<td>' + (totals.relance.tot || '-') + '</td>' +
                cell(totals.relance.relplus, 'positive') +
                cell(totals.relance.relminus, 'neutral') +
                cell(totals.relance.frel, 'negative') +
            '</tr></tbody></table></div>';

            // ===== D√âFENSE (V20.15 : D+/D/D-/FD) =====
            html += '<div class="stat-table-card">' +
                '<div class="stat-table-header defense">D√©fense</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th>Tot</th><th>D+</th><th>D</th><th>D-</th><th>FD</th>' +
                '</tr></thead><tbody>';
            players.forEach(name => {
                const p = stats[name];
                html += '<tr>' +
                    '<td>' + (p.defense.tot || '-') + '</td>' +
                    cell(p.defense.defplus, 'positive') +
                    cell(p.defense.defneutral, 'neutral') +
                    cell(p.defense.defminus, 'negative') +
                    cell(p.defense.fdef, 'negative') +
                '</tr>';
            });
            html += '<tr class="total-row">' +
                '<td>' + (totals.defense.tot || '-') + '</td>' +
                cell(totals.defense.defplus, 'positive') +
                cell(totals.defense.defneutral, 'neutral') +
                cell(totals.defense.defminus, 'negative') +
                cell(totals.defense.fdef, 'negative') +
            '</tr></tbody></table></div>';

            // ===== BLOC =====
            html += '<div class="stat-table-card">' +
                '<div class="stat-table-header block">Bloc</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th>Tot</th><th>B+</th><th>B-</th><th>FB</th>' +
                '</tr></thead><tbody>';
            players.forEach(name => {
                const p = stats[name];
                html += '<tr>' +
                    '<td>' + (p.block.tot || '-') + '</td>' +
                    cell(p.block.blcplus, 'positive') +
                    cell(p.block.blcminus, 'neutral') +
                    cell(p.block.fblc, 'negative') +
                '</tr>';
            });
            html += '<tr class="total-row">' +
                '<td>' + (totals.block.tot || '-') + '</td>' +
                cell(totals.block.blcplus, 'positive') +
                cell(totals.block.blcminus, 'neutral') +
                cell(totals.block.fblc, 'negative') +
            '</tr></tbody></table></div>';

            container.innerHTML = html;
        }

        // V19.2 : Tableau passe detaillee (ventilation Passeur/Autre + contexte)
        function renderPassDetailTable() {
            const container = document.getElementById('passDetailContainer');
            if (!container) return;

            // Agreger les stats pass de tous les joueurs home
            const homeStats = setStats.home;
            const players = Object.keys(homeStats);
            if (players.length === 0) { container.innerHTML = ''; return; }

            // Agreger passeur et autre sur tous les joueurs
            const agg = {
                passeur: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0,
                    confort: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0 },
                    contraint: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0 },
                    transition: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0 } },
                autre: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0,
                    contraint: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0 },
                    transition: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0 } }
            };
            const keys = ['tot', 'p4', 'p3', 'p2', 'p1', 'fp'];
            players.forEach(function(name) {
                const p = homeStats[name].pass;
                if (!p) return;
                ['passeur', 'autre'].forEach(function(pType) {
                    if (!p[pType]) return;
                    keys.forEach(function(k) { agg[pType][k] += (p[pType][k] || 0); });
                    var ctxs = pType === 'passeur' ? ['confort', 'contraint', 'transition'] : ['contraint', 'transition'];
                    ctxs.forEach(function(ctx) {
                        if (!p[pType][ctx]) return;
                        keys.forEach(function(k) { agg[pType][ctx][k] += (p[pType][ctx][k] || 0); });
                    });
                });
            });

            var totalPasses = (agg.passeur.tot || 0) + (agg.autre.tot || 0);
            if (totalPasses === 0) { container.innerHTML = ''; return; }

            function cell(val, cls) {
                return '<td class="' + (val > 0 ? cls : '') + '">' + (val || '-') + '</td>';
            }
            function passRow(label, data, cls) {
                return '<tr class="' + cls + '">' +
                    '<td>' + label + '</td>' +
                    '<td>' + (data.tot || '-') + '</td>' +
                    cell(data.p4, 'positive') +
                    cell(data.p3, 'positive') +
                    cell(data.p2, 'neutral') +
                    cell(data.p1, 'negative') +
                    cell(data.fp, 'negative') +
                '</tr>';
            }

            var html = '<div class="stat-table-card pass-detail-card">' +
                '<div class="stat-table-header passe">Passe d\u00e9taill\u00e9e</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th></th><th>Tot</th><th>P4</th><th>P3</th><th>P2</th><th>P1</th><th>FP</th>' +
                '</tr></thead><tbody>';

            // Passeur
            if (agg.passeur.tot > 0) {
                html += passRow('Passeur', agg.passeur, 'pass-type-row');
                if (agg.passeur.confort.tot > 0) html += passRow('\u2514 Confort', agg.passeur.confort, 'pass-ctx-row');
                if (agg.passeur.contraint.tot > 0) html += passRow('\u2514 Contraint', agg.passeur.contraint, 'pass-ctx-row');
                if (agg.passeur.transition.tot > 0) html += passRow('\u2514 Transition', agg.passeur.transition, 'pass-ctx-row');
            }
            // Autres
            if (agg.autre.tot > 0) {
                html += passRow('Autres', agg.autre, 'pass-type-row');
                if (agg.autre.contraint.tot > 0) html += passRow('\u2514 Contraint', agg.autre.contraint, 'pass-ctx-row');
                if (agg.autre.transition.tot > 0) html += passRow('\u2514 Transition', agg.autre.transition, 'pass-ctx-row');
            }

            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

        // Configuration cam√©ra (qui est en bas)
        let cameraSide = 'home'; // 'home' = Jen en bas, 'away' = adversaire en bas

        // ==================== V18.0 BRIDGE FUNCTIONS ====================
        // Undo = WorkflowEngine.popState()
        function undoLastAction() {
            if (WorkflowEngine.popState()) return;
            // V20.183 : stack vide ‚Üí proposer retour dans le point pr√©c√©dent
            if (currentSet.points && currentSet.points.length > 0) {
                showResumePointModal();
            }
        }

        // Cancel point : en d√©but de point ‚Üí undo dernier point valid√©, sinon ‚Üí annuler le rally en cours
        function cancelPoint() {
            if (gameState.phase === 'server_selection' ||
                (gameState.phase === 'serve_start' && gameState.currentServer && gameState.rally.length === 0)) {
                if (currentSet.points && currentSet.points.length > 0) {
                    showUndoPointModal();
                } else {
                    alert('Aucun point √† annuler.');
                }
                return;
            }
            // En cours de rally ‚Üí annuler le rally complet
            if (!confirm('Annuler ce point et recommencer ?')) return;
            WorkflowEngine._resetRallyState();
            WorkflowEngine.clearStack();
            gameState.currentServer = null;
            WorkflowEngine.transition('server_selection');
        }

        // Bridge pour les anciennes fonctions appel√©es par les handlers HTML
        // Ces fonctions ne sont plus directement utilis√©es mais certains onclick les r√©f√©rencent encore
        function handleAceFromReception() { WorkflowEngine.handleButton('ace'); }
        function handleReceptionFault() { WorkflowEngine.handleButton('receptionFault'); }
        function handleReceptionFaultFromTags() { WorkflowEngine.handleButton('receptionFault'); }

        // ==================== INITIALISATION ====================
        function init() {
            // V19.1 : charger les grilles de passe calibr√©es depuis localStorage
            if (typeof loadPassGridsFromStorage === 'function') loadPassGridsFromStorage();

            // V19.23 : Tenter de charger les grilles depuis Firebase (async, non-bloquant)
            // Firebase fait autorite si les grilles locales sont vides/default
            // Seuil : v > 2 (P3/P4) = donnees reellement calibrees
            if (typeof FirebaseSync !== 'undefined' && FirebaseSync.isConfigured()) {
                FirebaseSync.getPassGrids().then(remoteGrids => {
                    if (!remoteGrids) return;
                    const hasRemoteData = Object.values(remoteGrids).some(zone =>
                        zone && Object.values(zone).some(ctx =>
                            Array.isArray(ctx) && ctx.some(row =>
                                Array.isArray(row) && row.some(v => v > 2)
                            )
                        )
                    );
                    if (!hasRemoteData) return;
                    const localRaw = localStorage.getItem('volleyball_pass_grids');
                    let hasLocalData = false;
                    if (localRaw) {
                        try {
                            const local = JSON.parse(localRaw);
                            hasLocalData = Object.values(local).some(zone =>
                                zone && Object.values(zone).some(ctx =>
                                    Array.isArray(ctx) && ctx.some(row =>
                                        Array.isArray(row) && row.some(v => v > 2)
                                    )
                                )
                            );
                        } catch(e) {}
                    }
                    if (!hasLocalData) {
                        localStorage.setItem('volleyball_pass_grids', JSON.stringify(remoteGrids));
                        if (typeof loadPassGridsFromStorage === 'function') loadPassGridsFromStorage();
                    }
                }).catch(() => {});
            }

            if (!currentMatch) {
                window.location.href = 'nouveau-match.html';
                return;
            }

            // R√©cup√©rer le set actuel
            setIndex = (currentMatch.sets?.length || 1) - 1;
            currentSet = currentMatch.sets?.[setIndex];

            if (!currentSet) {
                window.location.href = 'match-set-composition.html';
                return;
            }

            // Defaults bloqueur (backward compat)
            if (!currentSet.homeBlockerRight) currentSet.homeBlockerRight = 'Pointu';
            if (!currentSet.awayBlockerRight) currentSet.awayBlockerRight = 'Pointu';
            // Migration : ancien format 'Pointu'/'Passeur' ‚Üí nouveau format 'right'/'R4'
            if (currentSet.homePrimaryBlocker === 'Pointu' || currentSet.homePrimaryBlocker === 'Passeur') {
                currentSet.homePrimaryBlocker = 'right';
            }
            if (currentSet.awayPrimaryBlocker === 'Pointu' || currentSet.awayPrimaryBlocker === 'Passeur') {
                currentSet.awayPrimaryBlocker = 'right';
            }
            if (!currentSet.homePrimaryBlocker) currentSet.homePrimaryBlocker = 'right';
            if (!currentSet.awayPrimaryBlocker) currentSet.awayPrimaryBlocker = 'right';
            gameState.homeScore = currentSet.homeScore || 0;
            gameState.awayScore = currentSet.awayScore || 0;

            // Sauvegarder le score initial (bonus) si pas encore fait
            if (currentSet.initialHomeScore === undefined) {
                currentSet.initialHomeScore = gameState.homeScore;
                currentSet.initialAwayScore = gameState.awayScore;
            }

            // Set frais (aucun point), film√©, ET pas encore confirm√© ‚Üí afficher overlay pr√©-match
            const isFilmedSet = currentSet.isFilmed !== false; // par d√©faut film√©
            const isFreshSet = isFilmedSet && (!currentSet.points || currentSet.points.length === 0) && !currentSet.preMatchConfirmed;
            if (isFreshSet) {
                showPreMatchOverlay();
                // On ne d√©marre PAS le workflow ‚Äî on attend confirmPreMatch()
            } else {
                // Configuration d√©j√† d√©finie (reprise ou confirm√©e)
                cameraSide = currentSet.cameraSide || 'home';
                gameState.servingTeam = currentSet.servingTeam || 'away';
                startMatch();
            }

            // Mettre √† jour l'affichage de base (score header, labels)
            updateLabels();
            updateScore();

            // Mettre √† jour les titres des tableaux de stats
            const opponent = currentMatch.opponent || 'Adversaire';
            document.getElementById('homeTeamStatsTitle').textContent = 'Jen et ses Saints';
            document.getElementById('awayTeamStatsTitle').textContent = opponent;

            // Initialiser le lecteur YouTube si URL disponible
            loadYouTubeForCurrentSet();
            updateYoutubeButtonState();
        }

        // D√©marrer le match (apr√®s confirmation pr√©-match ou en reprise)
        function startMatch() {
            updatePhase();
            // V18.0 : WorkflowEngine remplace renderServerSelection() + setupCourtListeners()
            WorkflowEngine.start();

            // Initialiser les statistiques du set
            initSetStats();

            // Reprise d'un set en cours : recalculer depuis les points
            if (currentSet.points && currentSet.points.length > 0) {
                const lastPt = currentSet.points[currentSet.points.length - 1];
                gameState.homeScore = lastPt.homeScore;
                gameState.awayScore = lastPt.awayScore;
                const prevHome = currentSet.points.length >= 2
                    ? currentSet.points[currentSet.points.length - 2].homeScore
                    : (currentSet.initialHomeScore || 0);
                if (lastPt.homeScore > prevHome) {
                    gameState.servingTeam = 'home';
                } else {
                    gameState.servingTeam = 'away';
                }
                gameState.currentServer = null;
                updateScore();
                recalculateAllStats();
            }
        }

        // ==================== PRE-MATCH OVERLAY ====================
        function showPreMatchOverlay() {
            const overlay = document.getElementById('preMatchOverlay');
            const opponent = currentMatch.opponent || 'Adversaire';

            // Labels adversaire
            document.getElementById('preMatchCameraAway').textContent = opponent;
            document.getElementById('preMatchServingAway').textContent = opponent;

            // Pr√©-s√©lection : valeurs du set (auto-flip entre sets) ou d√©fauts
            const defaultCamera = currentSet.cameraSide || 'home';
            const defaultServing = currentSet.servingTeam || 'away';
            preMatchSelect('camera', defaultCamera);
            preMatchSelect('serving', defaultServing);

            overlay.classList.add('active');

            // Masquer les √©l√©ments du workflow (phase indicator, tags)
            document.getElementById('phaseIndicator').style.display = 'none';
            document.getElementById('tagsContainer').style.display = 'none';
        }

        function preMatchSelect(type, value) {
            const toggleId = type === 'camera' ? 'preMatchCameraToggle' : 'preMatchServingToggle';
            const toggle = document.getElementById(toggleId);
            toggle.querySelectorAll('.pre-match-option').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.value === value);
            });
        }

        function confirmPreMatch() {
            const cameraToggle = document.getElementById('preMatchCameraToggle');
            const servingToggle = document.getElementById('preMatchServingToggle');

            const selectedCamera = cameraToggle.querySelector('.pre-match-option.selected')?.dataset.value || 'home';
            const selectedServing = servingToggle.querySelector('.pre-match-option.selected')?.dataset.value || 'away';

            // Appliquer au set et au gameState
            currentSet.cameraSide = selectedCamera;
            currentSet.servingTeam = selectedServing;
            currentSet.preMatchConfirmed = true;
            cameraSide = selectedCamera;
            gameState.servingTeam = selectedServing;

            // Sauvegarder
            Storage.saveCurrentMatch(currentMatch);

            // Masquer l'overlay, r√©afficher le workflow
            document.getElementById('preMatchOverlay').classList.remove('active');
            document.getElementById('phaseIndicator').style.display = '';
            document.getElementById('tagsContainer').style.display = '';

            // Mettre √† jour les labels du terrain (cam√©ra d√©termine qui est en haut/bas)
            updateLabels();
            updateScore();

            // D√©marrer le workflow
            startMatch();
        }

        // ==================== INITIALISATION (suite) ====================
        // (vide ‚Äî la logique de reprise est dans startMatch via le bloc existant dans init)

        // ==================== AFFICHAGE ====================
        function updateLabels() {
            const opponent = currentMatch.opponent || 'Adversaire';
            
            document.getElementById('awayTeamName').textContent = opponent;
            document.getElementById('setIndicator').textContent = `SET ${setIndex + 1}`;

            // Labels du terrain selon c√¥t√© cam√©ra
            if (cameraSide === 'home') {
                document.getElementById('topTeamLabel').textContent = opponent;
                document.getElementById('bottomTeamLabel').textContent = 'Jen et ses Saints';
            } else {
                document.getElementById('topTeamLabel').textContent = 'Jen et ses Saints';
                document.getElementById('bottomTeamLabel').textContent = opponent;
            }
        }

        function updateScore() {
            document.getElementById('homePoints').textContent = gameState.homeScore;
            document.getElementById('awayPoints').textContent = gameState.awayScore;

            const homeDisplay = document.getElementById('homeScoreDisplay');
            const awayDisplay = document.getElementById('awayScoreDisplay');

            if (gameState.servingTeam === 'home') {
                homeDisplay.style.opacity = '1';
                awayDisplay.style.opacity = '0.6';
            } else {
                homeDisplay.style.opacity = '0.6';
                awayDisplay.style.opacity = '1';
            }
        }

        function updatePhase() {
            const phaseEl = document.getElementById('phaseIndicator');
            const phases = {
                'server_selection': '<span class="highlight">Service</span> ‚Äî S√©lectionnez le serveur',
                'serve_start': '<span class="highlight">Service</span> ‚Äî Cliquez le point de d√©part',
                'serve_end': '<span class="highlight">Service</span> ‚Äî Cliquez le point d\'arriv√©e',
                'reception': '<span class="highlight">R√©ception</span> ‚Äî S√©lectionnez le r√©ceptionneur',
                'reception_end': '<span class="highlight">R√©ception</span> ‚Äî _RECEIVER_ Cliquez o√π arrive la r√©ception',
                'reception_fault_trajectory': '<span class="highlight">Faute r√©ception</span> ‚Äî Cliquez o√π va la balle',
                'reception_opponent_choice': '<span class="highlight">R√©ception</span> ‚Äî Que se passe-t-il ?',
                'reception_net_choice': '<span class="highlight">R√©ception filet</span> ‚Äî Att. directe ou cliquez le terrain = block',
                'reception_net_block_player': '<span class="highlight">Block au filet</span> ‚Äî Qui block ?',
                'reception_net_block_end': '<span class="highlight">Block au filet</span> ‚Äî Cliquez o√π arrive le block',
                'pass_net_choice': '<span class="highlight">Passe filet</span> ‚Äî Att. directe ou cliquez le terrain = block',
                'pass_net_block_player': '<span class="highlight">Block au filet</span> ‚Äî Qui block ?',
                'pass_net_block_end': '<span class="highlight">Block au filet</span> ‚Äî Cliquez o√π arrive le block',
                'attack_net_choice': '<span class="highlight">Attaque filet</span> ‚Äî Faute ou cliquez le terrain = block',
                'attack_net_block_player': '<span class="highlight">Block au filet</span> ‚Äî Qui block ?',
                'attack_net_block_end': '<span class="highlight">Block au filet</span> ‚Äî Cliquez o√π arrive le block',
                'bloc_out_player': '<span class="highlight">Bloc out</span> ‚Äî Qui a bloqu√© ?',
                'bloc_out_trajectory': '<span class="highlight">Bloc out</span> ‚Äî Cliquez o√π va la balle',
                'direct_return_end': '<span class="highlight">Retour direct</span> ‚Äî Cliquez o√π arrive le retour',
                'defense_direct_return_choice': '<span class="highlight">D√©fense</span> ‚Äî Retour direct, que se passe-t-il ?',
                'pass': '<span class="highlight">Passe</span> ‚Äî Cliquez le terrain (= _AUTOPASS_) ou s√©lectionnez un joueur',
                'pass_end': '<span class="highlight">Passe</span> ‚Äî _PASSER_ Cliquez o√π arrive la passe',
                'pass_direct_return_choice': '<span class="highlight">Passe</span> ‚Äî Passe chez l\'adversaire, que se passe-t-il ?',
                'attack_player': '<span class="highlight">Attaque</span> ‚Äî Cliquez le terrain ou s√©lectionnez un joueur',
                'attack_type': '<span class="highlight">Attaque</span> ‚Äî _ATTACKER_ Type ou cliquez = <span class="phase-smash-badge">üí™ Smash</span>',
                'attack_end': '<span class="highlight">Attaque</span> ‚Äî _ATTACKER_ Cliquez o√π arrive l\'attaque',
                'result': '<span class="highlight">R√©sultat</span> ‚Äî Cliquez le terrain = <span class="phase-defended-badge">üõ°Ô∏è D√©fendu</span>',
                'block_end': '<span class="highlight">Block</span> ‚Äî Cliquez o√π arrive le block',
                'defense': '<span class="highlight">D√©fense</span> ‚Äî S√©lectionnez le d√©fenseur',
                'defense_end': '<span class="highlight">D√©fense</span> ‚Äî _DEFENDER_ Cliquez o√π arrive la d√©fense',
                'defense_fault_trajectory': '<span class="highlight">Faute d√©fense</span> ‚Äî Cliquez o√π va la balle',
                'ace_reception': '<span class="highlight">Ace !</span> ‚Äî Qui a rat√© la r√©ception ?',
                'net_block_player': '<span class="highlight">Block au filet</span> ‚Äî Qui block ?',
                'net_block_end': '<span class="highlight">Block au filet</span> ‚Äî Cliquez o√π arrive le block'
            };
            let phaseText = phases[gameState.phase] || '';

            // Helper : g√©n√®re un badge joueur color√© par r√¥le
            function playerBadge(playerName, role) {
                const color = ROLE_COLORS[role] || '#8b5cf6';
                return '<span class="phase-player-badge" style="background:' + color + '">' + playerName + '</span> ‚Äî';
            }

            // Injecter le nom de l'attaquant dans le bandeau
            if (phaseText.includes('_ATTACKER_')) {
                const player = gameState.currentAction && gameState.currentAction.player;
                const role = gameState.currentAction && gameState.currentAction.role;
                phaseText = phaseText.replace('_ATTACKER_', player ? playerBadge(player, role) : '');
            }

            // Injecter le nom du d√©fenseur dans le bandeau
            if (phaseText.includes('_DEFENDER_')) {
                const player = gameState.currentAction && gameState.currentAction.player;
                const role = gameState.currentAction && gameState.currentAction.role;
                phaseText = phaseText.replace('_DEFENDER_', player ? playerBadge(player, role) : '');
            }

            // Injecter le nom du r√©ceptionneur dans le bandeau
            if (phaseText.includes('_RECEIVER_')) {
                const player = gameState.currentAction && gameState.currentAction.player;
                const role = gameState.currentAction && gameState.currentAction.role;
                phaseText = phaseText.replace('_RECEIVER_', player ? playerBadge(player, role) : '');
            }

            // Injecter le nom du passeur dans le bandeau
            if (phaseText.includes('_PASSER_')) {
                const player = gameState.currentAction && gameState.currentAction.player;
                const role = gameState.currentAction && gameState.currentAction.role;
                phaseText = phaseText.replace('_PASSER_', player ? playerBadge(player, role) : '');
            }

            // Injecter le joueur auto-s√©lectionn√© pour la passe (toujours le Passeur)
            if (phaseText.includes('_AUTOPASS_')) {
                const team = gameState.attackingTeam;
                const passeur = getPlayerByRole(team, 'Passeur');
                const autoPassName = passeur || 'Passeur';
                const autoPassRole = 'Passeur';
                phaseText = phaseText.replace('_AUTOPASS_', '<span class="phase-player-badge" style="background:' + (ROLE_COLORS[autoPassRole] || '#8b5cf6') + '">' + autoPassName + '</span>');
            }

            phaseEl.innerHTML = phaseText;

            // Afficher le bouton Changement pendant la s√©lection du serveur ou au d√©but du service
            const btnSub = document.getElementById('btnSubstitute');
            if (btnSub) {
                btnSub.style.display = (gameState.phase === 'server_selection' || gameState.phase === 'serve_start') ? 'flex' : 'none';
            }
            
            // Afficher le bouton Fin du Set pendant la s√©lection du serveur ou au d√©but du service
            const btnEnd = document.getElementById('btnEndSet');
            if (btnEnd) {
                btnEnd.style.display = (gameState.phase === 'server_selection' || gameState.phase === 'serve_start') ? 'flex' : 'none';
            }
        }

        // ==================== S√âLECTION SERVEUR ====================
        function renderServerSelection() {
            const container = document.getElementById('serverTags');
            const servingTeam = gameState.servingTeam;
            
            let players = [];
            if (servingTeam === 'home') {
                players = currentMatch.players || [];
            } else {
                players = (currentMatch.adversePlayers || []).map(name => ({ prenom: name }));
            }

            // Filtrer pour n'avoir que les 4 joueurs sur le terrain
            const lineup = servingTeam === 'home' 
                ? currentSet.homeLineup 
                : currentSet.awayLineup;
            
            const onCourtPlayers = Object.values(lineup).filter(p => p !== null);

            container.innerHTML = onCourtPlayers.map((playerName, idx) => `
                <button class="player-tag ${servingTeam}" onclick="selectServer('${playerName}')">
                    ${playerName}
                </button>
            `).join('');

            showSection('serverSelection');
        }

        function selectServer(playerName) {
            gameState.currentServer = playerName;
            gameState.currentAction = {
                type: 'service',
                player: playerName,
                team: gameState.servingTeam,
                role: getPlayerRole(gameState.servingTeam, playerName)
            };
            gameState.phase = 'serve_start';
            updatePhase();
            hideAllSections();
            highlightCourt(null);
            showServiceZone();
        }

        function showServerContinueBanner() {
            const banner = document.getElementById('serverContinue');
            const bannerInner = document.getElementById('serverContinueBanner');
            const nameSpan = document.getElementById('serverContinueName');
            
            nameSpan.textContent = gameState.currentServer;
            
            // Style selon l'√©quipe
            if (gameState.servingTeam === 'away') {
                bannerInner.classList.add('away');
            } else {
                bannerInner.classList.remove('away');
            }
            
            banner.classList.remove('hidden');
        }

        // ==================== GESTION DU TERRAIN ====================

        // ==================== FONCTIONS UI TERRAIN ====================

        function showServiceZone() {
            const serviceZoneTop = document.getElementById('serviceZoneTop');
            const serviceZoneBottom = document.getElementById('serviceZoneBottom');
            
            // Masquer les deux d'abord
            serviceZoneTop.classList.remove('active');
            serviceZoneBottom.classList.remove('active');

            // Afficher la bonne zone selon l'√©quipe qui sert
            const servingCourtSide = getCourtSideForTeam(gameState.servingTeam);
            
            if (servingCourtSide === 'top') {
                serviceZoneTop.classList.add('active');
            } else {
                serviceZoneBottom.classList.add('active');
            }
        }

        function hideServiceZones() {
            document.getElementById('serviceZoneTop').classList.remove('active');
            document.getElementById('serviceZoneBottom').classList.remove('active');
        }

        function calculateReceptionQuality(clickData) {
            // Calculer la distance par rapport au filet
            const courtSide = getCourtSideForTeam(gameState.attackingTeam);
            
            // Distance depuis le filet (en %)
            let distanceFromNet;
            if (courtSide === 'top') {
                // Terrain du haut : filet en bas (y=100%)
                distanceFromNet = 100 - clickData.y;
            } else {
                // Terrain du bas : filet en haut (y=0%)
                distanceFromNet = clickData.y;
            }
            
            // Distance horizontale depuis le centre (en %)
            const distX = Math.abs(clickData.x - 50);
            
            // Calcul bas√© sur la forme elliptique des demi-cercles (75% de l'original)
            // Zone parfaite: width 30%, height 22.5% ‚Üí ratio x/15, y/22.5
            // Zone correcte: width 52.5%, height 41% ‚Üí ratio x/26.25, y/41
            // Zone moyenne: width 75%, height 60% ‚Üí ratio x/37.5, y/60

            const perfectRatio = Math.sqrt(Math.pow(distX / 15, 2) + Math.pow(distanceFromNet / 22.5, 2));
            const goodRatio = Math.sqrt(Math.pow(distX / 26.25, 2) + Math.pow(distanceFromNet / 41, 2));
            const averageRatio = Math.sqrt(Math.pow(distX / 37.5, 2) + Math.pow(distanceFromNet / 60, 2));
            
            if (perfectRatio <= 1) {
                return { score: 4, label: 'Excellente' };
            } else if (goodRatio <= 1) {
                return { score: 3, label: 'Positive' };
            } else if (averageRatio <= 1) {
                return { score: 2, label: 'Jouable' };
            } else {
                return { score: 1, label: 'N√©gative' };
            }
        }

        function showReceptionQualityZones() {
            const courtSide = getCourtSideForTeam(gameState.attackingTeam);
            if (courtSide === 'top') {
                document.getElementById('qualityZonesTop').classList.add('active');
            } else {
                document.getElementById('qualityZonesBottom').classList.add('active');
            }
        }

        function hideReceptionQualityZones() {
            document.getElementById('qualityZonesTop').classList.remove('active');
            document.getElementById('qualityZonesBottom').classList.remove('active');
        }

        function showDefenseQualityZones(team) {
            // Afficher la zone D+ sur le terrain de l'√©quipe qui d√©fend
            const defendingTeam = team || gameState.attackingTeam;
            const courtSide = getCourtSideForTeam(defendingTeam);

            // Zone D+ r√©duite si relance (m√™me taille que R√©ception 4/4 : 40% √ó 30%)
            const lastAttack = gameState.rally.slice().reverse().find(a => a.type === 'attack');
            const isRelance = lastAttack && lastAttack.attackType === 'relance';
            const zoneWidth = isRelance ? '40%' : '43%';
            const zoneHeight = isRelance ? '30%' : '50%';

            // Couleur bleu clair pour relance, bleu normal sinon
            const zoneColor = isRelance ? '#60a5fa' : '';

            // Appliquer les dimensions et couleur dynamiques sur les deux zones
            document.querySelectorAll('.defense-quality-zone.positive').forEach(z => {
                z.style.width = zoneWidth;
                z.style.height = zoneHeight;
                z.style.background = zoneColor;
            });

            if (courtSide === 'top') {
                document.getElementById('defQualityZonesTop').classList.add('active');
            } else {
                document.getElementById('defQualityZonesBottom').classList.add('active');
            }
        }

        function hideDefenseQualityZones() {
            document.getElementById('defQualityZonesTop').classList.remove('active');
            document.getElementById('defQualityZonesBottom').classList.remove('active');
            // Reset les dimensions au d√©faut CSS
            const zones = document.querySelectorAll('.defense-quality-zone.positive');
            zones.forEach(z => { z.style.width = ''; z.style.height = ''; z.style.background = ''; });
        }

        function calculateDefenseQuality(clickData) {
            // Calculer si le clic est dans la zone D+ (demi-cercle proche du filet)
            const courtSide = getCourtSideForTeam(gameState.attackingTeam);

            // Distance depuis le filet (en %)
            let distanceFromNet;
            if (courtSide === 'top') {
                distanceFromNet = 100 - clickData.y;
            } else {
                distanceFromNet = clickData.y;
            }

            // Distance horizontale depuis le centre (en %)
            const distX = Math.abs(clickData.x - 50);

            // Relance ‚Üí zone D+ r√©duite (m√™me taille que R√©ception 4/4 : 40%√ó30%)
            const lastAttack = gameState.rally.slice().reverse().find(a => a.type === 'attack');
            const isRelance = lastAttack && lastAttack.attackType === 'relance';
            const semiAxisX = isRelance ? 20 : 21.5;
            const semiAxisY = isRelance ? 30 : 50;

            // Zone D+ : demi-ellipse (semi-axes variables selon type d'attaque)
            const ratio = Math.sqrt(Math.pow(distX / semiAxisX, 2) + Math.pow(distanceFromNet / semiAxisY, 2));

            if (ratio <= 1) {
                return 'positive'; // D+
            } else {
                return 'negative'; // D-
            }
        }

        // ==================== DEBUG : GRILLE QUALITE PASSE (V19.1d) ====================
        // Affiche l'overlay colore sur le terrain (touche G)
        let passGridDebugActive = false;

        function togglePassQualityGrid() {
            if (passGridDebugActive) {
                hidePassQualityGrid();
            } else {
                showPassQualityGrid(gameState.attackingTeam);
            }
        }

        function showPassQualityGrid(team) {
            if (!team) return;

            const courtSide = getCourtSideForTeam(team);
            const gridId = courtSide === 'top' ? 'passGridTop' : 'passGridBottom';
            const gridEl = document.getElementById(gridId);
            if (!gridEl) return;

            // Determiner le contexte depuis le rally en cours
            const passeur = getPlayerByRole(team, 'Passeur');
            const effectivePlayer = getEffectivePlayer && getEffectivePlayer();
            const passer = effectivePlayer || passeur;
            const passerRole = passer ? (getPlayerRole(team, passer) || 'transition') : 'transition';
            const contextObj = getPassContext(gameState.rally || [], passerRole);
            const context = contextObj.context;

            const colors = {
                4: '#22c55e',  // Vert ‚Äî Optimale
                3: '#a3e635',  // Vert-jaune ‚Äî Bonne
                2: '#f97316',  // Orange ‚Äî Jouable
                1: '#ef4444'   // Rouge ‚Äî Mauvaise
            };

            let html = '';
            const cellHeight = PASS_GRID_DEPTH / PASS_GRID_ROWS;

            // Chaque grille (R4/Centre/Pointu) couvre les 9m COMPLETS du terrain (18 cols de 50cm)
            // R4 et Pointu ont 4 cols extra (2m) hors-terrain ‚Üí 22 cols = 11m
            // L'overlay composite montre le TIERS pertinent de chaque grille + le debordement hors-terrain
            //
            // Pour le tiers R4 (bottom=gauche, top=droite) : on affiche les colonnes de la grille R4
            //   qui correspondent a x ‚àà [0%, 33.33%] du terrain, + les cols hors-terrain
            // Pour le tiers Centre : colonnes de la grille Centre pour x ‚àà [33.33%, 66.67%]
            // Pour le tiers Pointu : colonnes de la grille Pointu pour x ‚àà [66.67%, 100%] + hors-terrain

            const zones = courtSide === 'bottom'
                ? [{ zone: 'R4', xStart: 0, xEnd: 33.33 }, { zone: 'Centre', xStart: 33.33, xEnd: 66.67 }, { zone: 'Pointu', xStart: 66.67, xEnd: 100 }]
                : [{ zone: 'Pointu', xStart: 0, xEnd: 33.33 }, { zone: 'Centre', xStart: 33.33, xEnd: 66.67 }, { zone: 'R4', xStart: 66.67, xEnd: 100 }];

            zones.forEach(function(zoneInfo) {
                const zoneGrid = PASS_GRIDS[zoneInfo.zone] && PASS_GRIDS[zoneInfo.zone][context];
                if (!zoneGrid) return;

                const totalCols = getPassGridCols(zoneInfo.zone);
                const isExtended = (zoneInfo.zone === 'R4' || zoneInfo.zone === 'Pointu');

                // Largeur d'une colonne en % du terrain = largeur grille / nb cols
                // Grille couvre 100% (18 cols) ou 122.22% (22 cols) du terrain
                const totalGridWidth = 100 + (isExtended ? PASS_GRID_OVERFLOW : 0); // 122.22 ou 100
                const colWidthPct = totalGridWidth / totalCols; // % du terrain par colonne

                // Debut X de la grille complete en % du terrain
                // R4 bottom / Pointu top : debordement a GAUCHE ‚Üí grille commence a -22.22%
                // Pointu bottom / R4 top : debordement a DROITE ‚Üí grille commence a 0%
                const overflowLeft = isExtended && (
                    (zoneInfo.zone === 'R4' && courtSide === 'bottom') ||
                    (zoneInfo.zone === 'Pointu' && courtSide === 'top')
                );
                const gridXStart = overflowLeft ? -PASS_GRID_OVERFLOW : 0;

                // Determiner quelles colonnes tombent dans le tiers [xStart, xEnd] + hors-terrain
                for (let ci = 0; ci < totalCols; ci++) {
                    const cellLeft = gridXStart + ci * colWidthPct;
                    const cellRight = cellLeft + colWidthPct;

                    // La colonne est-elle dans le tiers visible ou dans le debordement hors-terrain ?
                    const inThird = (cellRight > zoneInfo.xStart && cellLeft < zoneInfo.xEnd);
                    const isOffCourt = (cellLeft < 0 || cellRight > 100);

                    if (!inThird && !isOffCourt) continue; // Hors du tiers et pas hors-terrain ‚Üí skip

                    // Miroir top court : les grilles sont calibrees en perspective bottom
                    // col 0 = gauche ‚Üí en top court gauche/droite inverses ‚Üí lire colonnes a l'envers
                    // row 0 = filet ‚Üí en top court le filet est en bas ‚Üí lire rows a l'envers
                    const gridCol = (courtSide === 'top') ? (totalCols - 1 - ci) : ci;

                    for (let row = 0; row < PASS_GRID_ROWS; row++) {
                        const gridRow = (courtSide === 'top') ? (PASS_GRID_ROWS - 1 - row) : row;
                        const score = zoneGrid[gridRow] ? (zoneGrid[gridRow][gridCol] || 1) : 1;
                        const color = colors[score];

                        const left = cellLeft.toFixed(2) + '%';
                        const width = colWidthPct.toFixed(2) + '%';
                        let top;
                        if (courtSide === 'bottom') {
                            top = (row * cellHeight).toFixed(2) + '%';
                        } else {
                            top = (100 - PASS_GRID_DEPTH + row * cellHeight).toFixed(2) + '%';
                        }
                        const height = cellHeight.toFixed(2) + '%';

                        // Hachures diagonales pour les zones hors-terrain
                        const offCourtStyle = isOffCourt
                            ? 'background-image:repeating-linear-gradient(45deg,transparent,transparent 2px,rgba(0,0,0,0.15) 2px,rgba(0,0,0,0.15) 4px);'
                            : '';

                        html += '<div style="position:absolute;left:' + left + ';top:' + top +
                            ';width:' + width + ';height:' + height +
                            ';background-color:' + color + ';' + offCourtStyle +
                            'border:1px solid rgba(255,255,255,0.3);' +
                            'font-size:8px;font-weight:bold;display:flex;align-items:center;justify-content:center;color:rgba(255,255,255,0.85);">' +
                            score + '</div>';
                    }
                }
            });

            gridEl.innerHTML = html;
            gridEl.classList.add('active');
            passGridDebugActive = true;

            // √âlever .court au-dessus de svg.arrow-svg pour que l'overlay soit visible
            const courtEl = document.querySelector('.court');
            if (courtEl) courtEl.classList.add('pass-grid-debug-active');
        }

        function hidePassQualityGrid() {
            const top = document.getElementById('passGridTop');
            const bottom = document.getElementById('passGridBottom');
            if (top) { top.classList.remove('active'); top.innerHTML = ''; }
            if (bottom) { bottom.classList.remove('active'); bottom.innerHTML = ''; }
            passGridDebugActive = false;

            // Remettre .court √† son z-index normal
            const courtEl = document.querySelector('.court');
            if (courtEl) courtEl.classList.remove('pass-grid-debug-active');
        }

        // Touche G pour toggle l'overlay grille passe
        // Active en phase pass/pass_end, masque automatiquement sinon
        document.addEventListener('keydown', function(e) {
            if (e.key === 'g' || e.key === 'G') {
                if (gameState.phase === 'pass' || gameState.phase === 'pass_end') {
                    togglePassQualityGrid();
                } else if (passGridDebugActive) {
                    // Auto-masquer si on appuie G hors phase pass
                    hidePassQualityGrid();
                }
            }
        });

        // Masquer l'overlay automatiquement quand la phase change (clic terrain, bouton, etc.)
        // On observe les changements via un poll l√©ger sur requestAnimationFrame
        (function autoHidePassGrid() {
            let lastPhase = '';
            function checkPhase() {
                if (passGridDebugActive && gameState.phase !== 'pass' && gameState.phase !== 'pass_end') {
                    hidePassQualityGrid();
                }
                lastPhase = gameState.phase;
                requestAnimationFrame(checkPhase);
            }
            requestAnimationFrame(checkPhase);
        })();


        function getAttackerFromClickX(clickData, excludePlayer) {
            const team = gameState.attackingTeam;
            const courtSide = getCourtSideForTeam(team);

            // Config attaque centre pour cette √©quipe
            const centreAttackEnabled = team === 'home'
                ? (currentSet.homeCentreAttack === true)
                : (currentSet.awayCentreAttack !== false);

            // D√©terminer la position X et Y relative au terrain de l'√©quipe
            let xPercent, yPercent;
            if (clickData.courtSide === 'out') {
                // Clic out : calculer X/Y par rapport au court-half de l'√©quipe
                const courtId = courtSide === 'top' ? 'courtTop' : 'courtBottom';
                const courtEl = document.getElementById(courtId);
                const container = document.getElementById('courtContainer');
                const containerRect = container.getBoundingClientRect();
                const courtRect = courtEl.getBoundingClientRect();
                const clickAbsX = (clickData.x / 100) * containerRect.width + containerRect.left;
                xPercent = ((clickAbsX - courtRect.left) / courtRect.width) * 100;
                yPercent = ((clickData.y / 100) * containerRect.height + containerRect.top - courtRect.top) / courtRect.height * 100;
            } else {
                xPercent = clickData.x;
                yPercent = clickData.y;
            }

            let role;

            // Si attaque centre activ√©e, tester d'abord le demi-cercle
            if (centreAttackEnabled) {
                // Demi-cercle centr√© au milieu du filet, rayon 16.65% en X et Y
                // Bottom court : filet en Y=0%, Top court : filet en Y=100%
                const filetY = courtSide === 'bottom' ? 0 : 100;
                const dx = (xPercent - 50) / 16.65;
                const dy = (yPercent - filetY) / 16.65;
                // V√©rifier que le clic est dans le demi-cercle ET du bon c√¥t√© du filet
                const inSemiCircle = (dx * dx + dy * dy <= 1) &&
                    (courtSide === 'bottom' ? yPercent >= 0 : yPercent <= 100);

                if (inSemiCircle) {
                    role = 'Centre';
                }
            }

            // Sinon : gauche/droite classique
            if (!role) {
                if (courtSide === 'bottom') {
                    role = xPercent < 50 ? 'R4' : 'Pointu';
                } else {
                    role = xPercent < 50 ? 'Pointu' : 'R4';
                }
            }

            let player = getPlayerByRole(team, role);

            // Si le joueur trouv√© est celui qui a fait la passe, il ne peut pas attaquer
            if (player && excludePlayer && player === excludePlayer) {
                if (role === 'Pointu') {
                    // Pointu exclu c√¥t√© droit ‚Üí Passeur prend sa place
                    player = getPlayerByRole(team, 'Passeur');
                } else {
                    // R4 ou Centre exclu ‚Üí pas d'auto-s√©lection
                    player = null;
                }
            }

            return player;
        }

        // Convertit un clic outArea (coordonn√©es courtContainer %) en coordonn√©es court-half
        // Retourne { x, y, courtSide } si le clic tombe dans la bande Y d'un court-half, null sinon
        function convertOutToCourtHalf(containerClickData) {
            const container = document.getElementById('courtContainer');
            const courtTop = document.getElementById('courtTop');
            const courtBottom = document.getElementById('courtBottom');
            const containerRect = container.getBoundingClientRect();
            const topRect = courtTop.getBoundingClientRect();
            const bottomRect = courtBottom.getBoundingClientRect();

            // Position du clic en pixels absolus dans le container
            const clickPxX = containerClickData.x / 100 * containerRect.width;
            const clickPxY = containerClickData.y / 100 * containerRect.height;

            // Positions relatives des court-halves dans le container
            const topRelY = topRect.top - containerRect.top;
            const topH = topRect.height;
            const bottomRelY = bottomRect.top - containerRect.top;
            const bottomH = bottomRect.height;

            // X relatif au court (centr√© dans le container)
            const court = document.getElementById('court');
            const courtRect = court.getBoundingClientRect();
            const courtRelX = courtRect.left - containerRect.left;
            const xInCourt = (clickPxX - courtRelX) / courtRect.width * 100;

            if (clickPxY >= topRelY && clickPxY <= topRelY + topH) {
                const yInHalf = (clickPxY - topRelY) / topH * 100;
                return { x: xInCourt, y: yInHalf, courtSide: 'top' };
            } else if (clickPxY >= bottomRelY && clickPxY <= bottomRelY + bottomH) {
                const yInHalf = (clickPxY - bottomRelY) / bottomH * 100;
                return { x: xInCourt, y: yInHalf, courtSide: 'bottom' };
            }

            return null; // Vraiment hors zone (au-dessus ou en-dessous des deux terrains)
        }

        // ==================== GESTION DES POINTS ====================

        function checkSetEnd() {
            const home = gameState.homeScore;
            const away = gameState.awayScore;

            // Tie-break (set 5 quand 2-2) = 15 pts, sinon 25 pts
            const target = Storage.getTargetScore(currentMatch);

            // Set gagn√© √† 25 avec 2 points d'√©cart
            if ((home >= target || away >= target) && Math.abs(home - away) >= 2) {
                gameState.setEnded = true;
                openEndSetModal('auto');
            }
        }

        // ==================== FIN DU SET ====================
        let endSetState = {
            mode: null,     // 'auto', 'manual'
            reason: null,   // null, 'camera', 'time'
        };

        function openEndSetModal(mode) {
            endSetState.mode = mode;
            endSetState.reason = null;

            const opponent = currentMatch.opponent || 'Adversaire';
            const home = gameState.homeScore;
            const away = gameState.awayScore;

            // Mettre √† jour les noms
            document.getElementById('endSetAwayName').textContent = opponent;
            document.getElementById('realScoreAwayLabel').textContent = opponent;

            // Score
            const homeEl = document.getElementById('endSetHomeScore');
            const awayEl = document.getElementById('endSetAwayScore');
            homeEl.textContent = home;
            awayEl.textContent = away;

            // Reset des classes winner/loser
            homeEl.classList.remove('winner', 'loser');
            awayEl.classList.remove('winner', 'loser');

            if (mode === 'auto') {
                // Fin automatique ‚Äî on sait qui a gagn√©
                const winner = home > away ? 'home' : 'away';
                const winnerName = winner === 'home' ? 'Jen et ses Saints' : opponent;
                
                homeEl.classList.add(home > away ? 'winner' : 'loser');
                awayEl.classList.add(away > home ? 'winner' : 'loser');

                document.getElementById('endSetIcon').textContent = 'üèÜ';
                document.getElementById('endSetTitle').textContent = 'Fin du Set !';
                document.getElementById('endSetSubtitle').textContent = `Set ${setIndex + 1} termin√© ‚Äî ${Storage.getTargetScore(currentMatch)} points atteints`;
                document.getElementById('endSetWinner').textContent = `üéâ ${winnerName} remporte le set`;
                document.getElementById('endSetWinner').style.display = 'block';
                document.getElementById('endSetReasons').style.display = 'none';
                document.getElementById('endSetRealScore').classList.remove('visible');
                document.getElementById('endSetCancelBtn').style.display = 'none';
                document.getElementById('endSetBackBtn').style.display = 'block';
                // Match termin√© ?
            const tempSet = { ...currentSet, completed: true, winner: home > away ? 'home' : 'away', finalHomeScore: home, finalAwayScore: away };
            const tempMatch = { ...currentMatch, sets: currentMatch.sets.map((s, i) => i === setIndex ? tempSet : s) };
            if (Storage.isMatchOver(tempMatch)) {
                document.getElementById('endSetConfirmBtn').textContent = 'Fin du match \u2192';
            } else if (Storage.isTieBreak(tempMatch)) {
                document.getElementById('endSetConfirmBtn').textContent = 'Tie-break \u2192';
            } else {
                document.getElementById('endSetConfirmBtn').textContent = 'Set suivant \u2192';
            }
                document.getElementById('endSetConfirmBtn').disabled = false;
            } else {
                // Mode manuel
                document.getElementById('endSetIcon').textContent = 'üëç';
                document.getElementById('endSetTitle').textContent = 'Terminer le set ?';
                document.getElementById('endSetSubtitle').textContent = `Set ${setIndex + 1} ‚Äî Score actuel`;
                document.getElementById('endSetWinner').style.display = 'none';
                document.getElementById('endSetReasons').style.display = 'flex';
                document.getElementById('endSetRealScore').classList.remove('visible');
                document.getElementById('endSetCancelBtn').style.display = 'block';
                document.getElementById('endSetBackBtn').style.display = 'none';
                document.getElementById('endSetConfirmBtn').textContent = 'Terminer le set';
                document.getElementById('endSetConfirmBtn').disabled = true; // Attendre le choix de raison

                // Reset les boutons raison
                document.querySelectorAll('.end-set-reason-btn').forEach(b => b.classList.remove('selected'));
            }

            // Stats recap
            buildEndSetStatsRecap();

            // Pr√©-remplir score r√©el avec score actuel
            document.getElementById('realScoreHome').value = home;
            document.getElementById('realScoreAway').value = away;

            document.getElementById('endSetOverlay').classList.add('active');
        }

        function selectEndReason(reason) {
            endSetState.reason = reason;

            // Highlight du bouton
            document.querySelectorAll('.end-set-reason-btn').forEach(b => b.classList.remove('selected'));
            event.currentTarget.classList.add('selected');

            if (reason === 'camera') {
                document.getElementById('endSetRealScore').classList.add('visible');
                document.getElementById('endSetConfirmBtn').textContent = 'Terminer avec score r√©el';
                document.getElementById('endSetConfirmBtn').disabled = false;
            } else if (reason === 'time') {
                // Fin du cr√©neau = fin du match imm√©diate
                // Fermer le modal de fin de set et ouvrir le modal de fin de cr√©neau
                closeEndSetModal();
                showTimeEndModal();
            }
        }

        function closeEndSetModal() {
            document.getElementById('endSetOverlay').classList.remove('active');
        }

        function returnToGameForCorrection() {
            // Fermer la modal
            closeEndSetModal();
            
            // R√©initialiser le flag de fin de set
            gameState.setEnded = false;
            
            // Retour √† la s√©lection du serveur pour pouvoir utiliser "Annuler point"
            gameState.rally = [];
            gameState.currentAction = {};
            gameState.currentServer = null;
            
            clearMarkers();
            clearArrows();
            hideServiceZones();
            hideReceptionQualityZones();
            highlightCourt(null);
            
            gameState.phase = 'server_selection';
            updatePhase();
            renderServerSelection();
        }

        // ==================== MODAL FIN DE MATCH ====================

        function showEndMatchModal() {
            const sc = Storage.getSetScore(currentMatch);
            const opponent = currentMatch.opponent || 'Adversaire';
            const isWin = sc.homeWins > sc.awayWins;
            const isDraw = sc.homeWins === sc.awayWins;

            // Ic√¥ne et titre
            document.getElementById('endMatchIcon').textContent = isWin ? 'üèÜ' : (isDraw ? 'ü§ù' : 'üòî');
            document.getElementById('endMatchTitle').textContent = isWin ? 'Victoire !' : (isDraw ? 'Match nul' : 'D√©faite');

            // Score sets
            const scoreEl = document.getElementById('endMatchFinalScore');
            scoreEl.textContent = sc.homeWins + ' ‚Äì ' + sc.awayWins;
            scoreEl.className = 'match-final-score ' + (isWin ? 'win' : (isDraw ? 'draw' : 'loss'));

            // Versus
            document.getElementById('endMatchVs').textContent = 'Jen et ses Saints vs ' + opponent;

            // D√©tail des sets
            const setsDetail = document.getElementById('endMatchSetsDetail');
            let setsHtml = '';
            currentMatch.sets.forEach((s, i) => {
                if (s.completed) {
                    const h = s.finalHomeScore || 0;
                    const a = s.finalAwayScore || 0;
                    const won = h > a;
                    setsHtml += '<div>Set ' + (i + 1) + ' : <span class="' + (won ? 'set-won' : 'set-lost') + '">' + h + ' ‚Äì ' + a + '</span></div>';
                }
            });
            setsDetail.innerHTML = setsHtml;

            // Stats r√©sum√© du match
            buildEndMatchStats();

            // Afficher la modal
            document.getElementById('endMatchOverlay').style.display = 'flex';
        }

        function buildEndMatchStats() {
            // Agr√©ger les stats de tous les sets (noms unifi√©s)
            let totalAces = 0, totalFautesServ = 0, totalKills = 0, totalBlocks = 0;
            let totalServiceTot = 0, totalReceptionTot = 0, totalAttackTot = 0;
            let totalReceptionExc = 0;

            currentMatch.sets.forEach(s => {
                if (s.stats && s.stats.home) {
                    Object.values(s.stats.home).forEach(p => {
                        totalServiceTot += (p.service && p.service.tot) || 0;
                        totalAces += (p.service && p.service.ace) || 0;
                        totalFautesServ += (p.service && (p.service.fser || p.service.fs)) || 0;
                        totalReceptionTot += (p.reception && p.reception.tot) || 0;
                        totalReceptionExc += (p.reception && (p.reception.rplus || p.reception.positive)) || 0;
                        totalAttackTot += (p.attack && p.attack.tot) || 0;
                        totalKills += (p.attack && (p.attack.attplus || p.attack.fd)) || 0;
                        totalBlocks += (p.block && (p.block.blcplus || p.block.bl)) || 0;
                    });
                }
            });

            // Also add current set stats if they exist
            if (setStats && setStats.home) {
                Object.values(setStats.home).forEach(p => {
                    totalServiceTot += (p.service && p.service.tot) || 0;
                    totalAces += (p.service && p.service.ace) || 0;
                    totalFautesServ += (p.service && p.service.fser) || 0;
                    totalReceptionTot += (p.reception && p.reception.tot) || 0;
                    totalReceptionExc += (p.reception && p.reception.rplus) || 0;
                    totalAttackTot += (p.attack && p.attack.tot) || 0;
                    totalKills += (p.attack && p.attack.attplus) || 0;
                    totalBlocks += (p.block && p.block.blcplus) || 0;
                });
            }

            const grid = document.getElementById('endMatchStatsGrid');
            grid.innerHTML = 
                '<div class="match-stat-item"><span class="stat-value">' + totalAces + '</span><span class="stat-label">Aces</span></div>' +
                '<div class="match-stat-item"><span class="stat-value">' + totalKills + '</span><span class="stat-label">Attaques gagnantes</span></div>' +
                '<div class="match-stat-item"><span class="stat-value">' + totalBlocks + '</span><span class="stat-label">Contres</span></div>' +
                '<div class="match-stat-item"><span class="stat-value">' + totalFautesServ + '</span><span class="stat-label">Fautes service</span></div>';
        }

        function returnToGameFromEndMatch() {
            // Fermer la modal fin de match
            document.getElementById('endMatchOverlay').style.display = 'none';

            // R√©initialiser le flag de fin de set pour permettre la correction
            gameState.setEnded = false;

            // Annuler la validation du dernier set
            currentSet.completed = false;
            delete currentSet.finalHomeScore;
            delete currentSet.finalAwayScore;
            delete currentSet.endReason;
            delete currentSet.winner;

            Storage.saveCurrentMatch(currentMatch);

            // Retour √† la s√©lection du serveur
            gameState.rally = [];
            gameState.currentAction = {};
            gameState.currentServer = null;

            clearMarkers();
            clearArrows();
            hideServiceZones();
            hideReceptionQualityZones();
            highlightCourt(null);

            gameState.phase = 'server_selection';
            updatePhase();
            renderServerSelection();
        }

        function confirmEndMatch() {
            // Sauvegarder les stats du set courant dans le match
            if (setStats) {
                currentSet.stats = { home: {}, away: {} };
                // Deep copy des stats
                for (const team of ['home', 'away']) {
                    for (const [name, data] of Object.entries(setStats[team] || {})) {
                        currentSet.stats[team][name] = JSON.parse(JSON.stringify(data));
                    }
                }
            }

            currentMatch.sets[setIndex] = currentSet;

            // Finaliser le match (change le statut en 'completed', calcule le r√©sultat)
            Storage.finalizeMatch(currentMatch, 'normal');

            // Upload vers Firebase en arri√®re-plan (non-bloquant)
            if (typeof FirebaseSync !== 'undefined' && FirebaseSync.isConfigured()) {
                FirebaseSync.uploadMatch(currentMatch).catch(function(err) {
                    console.warn('[Firebase] Upload √©chou√© (sera rattrap√© au chargement historique) :', err.message);
                });
            }

            // Fermer la modal
            document.getElementById('endMatchOverlay').style.display = 'none';

            // Rediriger vers l'historique
            window.location.href = 'historique.html';
        }

        // ==================== FIN DE CR√âNEAU (temps √©coul√©) ====================

        function showTimeEndModal() {
            const opponent = currentMatch.opponent || 'Adversaire';

            // Calculer le score des sets en comptant le set en cours
            // Le set en cours est gagn√© par l'√©quipe en t√™te (ou nul si √©galit√©)
            const home = gameState.homeScore;
            const away = gameState.awayScore;

            let homeWins = 0;
            let awayWins = 0;

            // Compter les sets pr√©c√©dents
            currentMatch.sets.forEach((s, i) => {
                if (i < setIndex && s.completed) {
                    if (s.winner === 'home') homeWins++;
                    else if (s.winner === 'away') awayWins++;
                }
            });

            // Ajouter le set en cours (celui qui est en t√™te gagne)
            if (home > away) homeWins++;
            else if (away > home) awayWins++;
            // Si √©galit√©, personne ne gagne ce set

            const isWin = homeWins > awayWins;
            const isDraw = homeWins === awayWins;

            // Score sets
            const scoreEl = document.getElementById('timeEndFinalScore');
            scoreEl.textContent = homeWins + ' ‚Äì ' + awayWins;
            scoreEl.className = 'match-final-score ' + (isWin ? 'win' : (isDraw ? 'draw' : 'loss'));

            // Versus
            document.getElementById('timeEndVs').textContent = 'Jen et ses Saints vs ' + opponent;

            // D√©tail des sets (incluant le set en cours)
            const setsDetail = document.getElementById('timeEndSetsDetail');
            let setsHtml = '';

            // Sets pr√©c√©dents
            currentMatch.sets.forEach((s, i) => {
                if (i < setIndex && s.completed) {
                    const h = s.finalHomeScore || 0;
                    const a = s.finalAwayScore || 0;
                    const won = h > a;
                    setsHtml += '<div>Set ' + (i + 1) + ' : <span class="' + (won ? 'set-won' : 'set-lost') + '">' + h + ' ‚Äì ' + a + '</span></div>';
                }
            });

            // Set en cours
            const currentSetWon = home > away;
            const currentSetClass = home === away ? '' : (currentSetWon ? 'set-won' : 'set-lost');
            setsHtml += '<div>Set ' + (setIndex + 1) + ' (en cours) : <span class="' + currentSetClass + '">' + home + ' ‚Äì ' + away + '</span></div>';

            setsDetail.innerHTML = setsHtml;

            // Stats r√©sum√© du match
            buildTimeEndStats();

            // Afficher la modal
            document.getElementById('timeEndOverlay').style.display = 'flex';
        }

        function closeTimeEndModal() {
            document.getElementById('timeEndOverlay').style.display = 'none';
        }

        function buildTimeEndStats() {
            // Agr√©ger les stats de tous les sets pr√©c√©dents + set en cours (noms unifi√©s)
            let totalAces = 0, totalFautesServ = 0, totalKills = 0, totalBlocks = 0;

            // Sets pr√©c√©dents
            currentMatch.sets.forEach((s, i) => {
                if (i < setIndex && s.stats && s.stats.home) {
                    Object.values(s.stats.home).forEach(p => {
                        totalAces += (p.service && p.service.ace) || 0;
                        totalFautesServ += (p.service && (p.service.fser || p.service.fs)) || 0;
                        totalKills += (p.attack && (p.attack.attplus || p.attack.fd)) || 0;
                        totalBlocks += (p.block && (p.block.blcplus || p.block.bl)) || 0;
                    });
                }
            });

            // Set en cours
            if (setStats && setStats.home) {
                Object.values(setStats.home).forEach(p => {
                    totalAces += (p.service && p.service.ace) || 0;
                    totalFautesServ += (p.service && p.service.fser) || 0;
                    totalKills += (p.attack && p.attack.attplus) || 0;
                    totalBlocks += (p.block && p.block.blcplus) || 0;
                });
            }

            const grid = document.getElementById('timeEndStatsGrid');
            grid.innerHTML =
                '<div class="match-stat-item"><span class="stat-value">' + totalAces + '</span><span class="stat-label">Aces</span></div>' +
                '<div class="match-stat-item"><span class="stat-value">' + totalKills + '</span><span class="stat-label">Attaques gagnantes</span></div>' +
                '<div class="match-stat-item"><span class="stat-value">' + totalBlocks + '</span><span class="stat-label">Contres</span></div>' +
                '<div class="match-stat-item"><span class="stat-value">' + totalFautesServ + '</span><span class="stat-label">Fautes service</span></div>';
        }

        function confirmTimeEndMatch() {
            const home = gameState.homeScore;
            const away = gameState.awayScore;

            // Sauvegarder le set en cours
            currentSet.finalHomeScore = home;
            currentSet.finalAwayScore = away;
            currentSet.endReason = 'time';
            currentSet.completed = true;
            currentSet.winner = home > away ? 'home' : (away > home ? 'away' : 'draw');
            currentSet.statsHomeScore = home;
            currentSet.statsAwayScore = away;

            // Sauvegarder les stats du set courant
            if (setStats) {
                currentSet.stats = { home: {}, away: {} };
                for (const team of ['home', 'away']) {
                    for (const [name, data] of Object.entries(setStats[team] || {})) {
                        currentSet.stats[team][name] = JSON.parse(JSON.stringify(data));
                    }
                }
            }

            currentMatch.sets[setIndex] = currentSet;

            // Finaliser le match avec raison 'time'
            Storage.finalizeMatch(currentMatch, 'time');

            // Upload vers Firebase en arri√®re-plan (non-bloquant)
            if (typeof FirebaseSync !== 'undefined' && FirebaseSync.isConfigured()) {
                FirebaseSync.uploadMatch(currentMatch).catch(function(err) {
                    console.warn('[Firebase] Upload √©chou√© (sera rattrap√© au chargement historique) :', err.message);
                });
            }

            // Fermer la modal
            document.getElementById('timeEndOverlay').style.display = 'none';

            // Rediriger vers l'historique
            window.location.href = 'historique.html';
        }

        function buildEndSetStatsRecap() {
            const points = currentSet.points || [];
            const totalPoints = points.length;
            
            if (totalPoints === 0) {
                document.getElementById('endSetStatsRecap').innerHTML = 'Aucun point enregistr√© dans ce set.';
                return;
            }

            // Compter les aces et fautes de service
            let aces = 0, faultesServ = 0;
            for (const pt of points) {
                for (const action of pt.rally) {
                    if (action.type === 'service' && action.result === 'ace') aces++;
                    if (action.type === 'service' && (action.result === 'fault' || action.result === 'fault_out' || action.result === 'fault_net')) faultesServ++;
                }
            }

            document.getElementById('endSetStatsRecap').innerHTML = `
                <span class="stat-highlight">${totalPoints}</span> points jou√©s
                ${aces > 0 ? ` ‚Ä¢ <span class="stat-highlight">${aces}</span> ace${aces > 1 ? 's' : ''}` : ''}
                ${faultesServ > 0 ? ` ‚Ä¢ <span class="stat-highlight">${faultesServ}</span> faute${faultesServ > 1 ? 's' : ''} au service` : ''}
            `;
        }

        function confirmEndSet() {
            let finalHome = gameState.homeScore;
            let finalAway = gameState.awayScore;
            let endReason = 'auto';

            if (endSetState.mode === 'manual') {
                if (!endSetState.reason) return;
                endReason = endSetState.reason;

                if (endSetState.reason === 'camera') {
                    finalHome = parseInt(document.getElementById('realScoreHome').value) || 0;
                    finalAway = parseInt(document.getElementById('realScoreAway').value) || 0;

                    // Validation d'un score valide de fin de set
                    const target = Storage.getTargetScore(currentMatch); // 25 ou 15 pour tie-break
                    const maxScore = Math.max(finalHome, finalAway);
                    const minScore = Math.min(finalHome, finalAway);
                    const diff = maxScore - minScore;

                    if (finalHome === finalAway) {
                        alert('Le score ne peut pas √™tre √† √©galit√© en fin de set.');
                        return;
                    }

                    if (maxScore < target) {
                        alert(`Le score gagnant doit √™tre d'au moins ${target} points.`);
                        return;
                    }

                    if (diff < 2) {
                        alert('Il faut au moins 2 points d\'√©cart pour gagner un set.');
                        return;
                    }

                    // Si score au-del√† du target, v√©rifier que l'√©cart est exactement 2
                    if (maxScore > target && diff !== 2) {
                        alert(`Avec un score au-del√† de ${target}, l'√©cart doit √™tre exactement de 2 points (ex: ${maxScore}-${maxScore - 2}).`);
                        return;
                    }
                }
                // Note: 'time' est g√©r√© directement dans selectEndReason() -> showTimeEndModal()
            }

            // Sauvegarder le r√©sultat du set
            currentSet.finalHomeScore = finalHome;
            currentSet.finalAwayScore = finalAway;
            currentSet.endReason = endReason;
            currentSet.completed = true;
            currentSet.winner = finalHome > finalAway ? 'home' : 'away';
            currentSet.statsHomeScore = gameState.homeScore;
            currentSet.statsAwayScore = gameState.awayScore;

            // D√©terminer le prochain serveur (alternance entre sets)
            // Le premier serveur du set change √† chaque set
            const firstServerThisSet = currentSet.firstServingTeam || currentSet.servingTeam;
            const nextServingTeam = firstServerThisSet === 'home' ? 'away' : 'home';

            // Sauvegarder qui a servi en premier dans ce set
            if (!currentSet.firstServingTeam) {
                currentSet.firstServingTeam = currentSet.servingTeam;
            }

            // Changement de c√¥t√© terrain (la cam√©ra reste fixe)
            const currentCameraSide = currentSet.cameraSide || 'home';
            const nextCameraSide = currentCameraSide === 'home' ? 'away' : 'home';

            // Pr√©parer le squelette du set suivant (sans composition pr√©-remplie)
            const nextSetNumber = (currentSet.setNumber || 1) + 1;
            const nextSet = {
                setNumber: nextSetNumber,
                homeLineup: {},  // Sera rempli dans match-set-composition
                awayLineup: {},
                homeScore: 0,
                awayScore: 0,
                points: [],
                cameraSide: nextCameraSide,
                servingTeam: nextServingTeam,
                firstServingTeam: nextServingTeam,
                youtubeUrl: currentSet.youtubeUrl || ''
            };

            // Sauvegarder le set courant d'abord
            currentMatch.sets[setIndex] = currentSet;

            // V√©rifier si le match est termin√©
            if (Storage.isMatchOver(currentMatch)) {
                // Sauvegarder les stats du set courant
                if (setStats) {
                    currentSet.stats = { home: {}, away: {} };
                    for (const team of ['home', 'away']) {
                        for (const [name, data] of Object.entries(setStats[team] || {})) {
                            currentSet.stats[team][name] = JSON.parse(JSON.stringify(data));
                        }
                    }
                }
                currentMatch.sets[setIndex] = currentSet;
                Storage.saveCurrentMatch(currentMatch);
                closeEndSetModal();
                showEndMatchModal();
                return;
            }

            // Sauvegarder les stats du set courant
            if (setStats) {
                currentSet.stats = { home: {}, away: {} };
                for (const team of ['home', 'away']) {
                    for (const [name, data] of Object.entries(setStats[team] || {})) {
                        currentSet.stats[team][name] = JSON.parse(JSON.stringify(data));
                    }
                }
            }

            // Ajouter le set suivant au match
            currentMatch.sets.push(nextSet);

            // Sauvegarder
            currentMatch.sets[setIndex] = currentSet;
            Storage.saveCurrentMatch(currentMatch);

            // Fermer la modal
            closeEndSetModal();

            // Aller √† la composition du set suivant
            window.location.href = 'match-set-composition.html';
        }


        function recalculateAllStats() {
            // R√©initialiser les stats
            initSetStats();

            // Parcourir tous les points enregistr√©s
            if (currentSet.points) {
                for (const point of currentSet.points) {
                    updateStatsFromRally(point.rally);
                }
            }

            renderStatsTables();
            renderMiniTimeline();
        }

        // ==================== MINI-TIMELINE ====================

        function buildTimelineData(set) {
            const points = set.points || [];
            if (points.length === 0) return [];

            const initialHome = set.initialHomeScore || 0;
            const runs = [];
            let currentRun = null;

            for (let i = 0; i < points.length; i++) {
                const pt = points[i];
                const prevHome = i > 0 ? points[i - 1].homeScore : initialHome;
                const scorer = pt.homeScore > prevHome ? 'home' : 'away';
                const teamScore = scorer === 'home' ? pt.homeScore : pt.awayScore;

                if (currentRun && currentRun.team === scorer) {
                    currentRun.points.push({ teamScore: teamScore });
                } else {
                    currentRun = { team: scorer, points: [{ teamScore: teamScore }] };
                    runs.push(currentRun);
                }
            }
            return runs;
        }

        function renderMiniTimeline() {
            const container = document.getElementById('miniTimelineChart');
            if (!container || !currentSet) { if (container) container.innerHTML = ''; return; }

            const mixHome = currentSet.mixiteHome || 0;
            const mixAway = currentSet.mixiteAway || 0;
            const hasMix = mixHome > 0 || mixAway > 0;
            const hasPoints = currentSet.points && currentSet.points.length > 0;

            if (!hasMix && !hasPoints) { container.innerHTML = ''; return; }

            const runs = hasPoints ? buildTimelineData(currentSet) : [];
            if (!hasMix && runs.length === 0) { container.innerHTML = ''; return; }

            const totalPoints = runs.reduce(function(sum, r) { return sum + r.points.length; }, 0);
            const totalMixBlocks = mixHome + mixAway;
            const totalAll = totalPoints + totalMixBlocks;
            const mixRuns = (mixHome > 0 ? 1 : 0) + (mixAway > 0 ? 1 : 0);
            const availableWidth = 576;
            const totalRuns = runs.length + mixRuns;
            const gapWidth = Math.max(0, totalRuns - 1) * 3;
            const internalGaps = totalAll - totalRuns;
            const blockSize = Math.max(6, Math.min(16, Math.floor((availableWidth - gapWidth - internalGaps) / totalAll)));
            const fontSize = blockSize >= 12 ? 7 : (blockSize >= 9 ? 6 : 0);
            const blockHeight = 14;

            let html = '';

            // Blocs mixit√© gris au d√©but
            if (mixHome > 0) {
                html += '<div class="mini-tl-run">';
                html += '<div class="mini-tl-row">';
                for (var m = 1; m <= mixHome; m++) {
                    html += '<div class="mini-tl-block mixite" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;font-size:' + fontSize + 'px;">' + (fontSize > 0 ? m : '') + '</div>';
                }
                html += '</div><div class="mini-tl-row">';
                for (var m = 0; m < mixHome; m++) {
                    html += '<div class="mini-tl-block empty" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;"></div>';
                }
                html += '</div></div>';
            }
            if (mixAway > 0) {
                html += '<div class="mini-tl-run">';
                html += '<div class="mini-tl-row">';
                for (var m = 0; m < mixAway; m++) {
                    html += '<div class="mini-tl-block empty" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;"></div>';
                }
                html += '</div><div class="mini-tl-row">';
                for (var m = 1; m <= mixAway; m++) {
                    html += '<div class="mini-tl-block mixite" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;font-size:' + fontSize + 'px;">' + (fontSize > 0 ? m : '') + '</div>';
                }
                html += '</div></div>';
            }

            runs.forEach(function(run) {
                html += '<div class="mini-tl-run">';
                html += '<div class="mini-tl-row">';
                run.points.forEach(function(pt) {
                    if (run.team === 'home') {
                        html += '<div class="mini-tl-block home" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;font-size:' + fontSize + 'px;">' + (fontSize > 0 ? pt.teamScore : '') + '</div>';
                    } else {
                        html += '<div class="mini-tl-block empty" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;"></div>';
                    }
                });
                html += '</div><div class="mini-tl-row">';
                run.points.forEach(function(pt) {
                    if (run.team === 'away') {
                        html += '<div class="mini-tl-block away" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;font-size:' + fontSize + 'px;">' + (fontSize > 0 ? pt.teamScore : '') + '</div>';
                    } else {
                        html += '<div class="mini-tl-block empty" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;"></div>';
                    }
                });
                html += '</div></div>';
            });

            container.innerHTML = html;
        }

        // Helper : obtenir les stats d'un joueur (avec init auto)
        // V20.27 : garde ‚Äî le joueur doit appartenir au lineup de l'√©quipe
        // (ou avoir d√©j√† des stats via substitution) pour √©viter les stats fant√¥mes
        function getPlayerStats(team, player) {
            if (!team || !player) return null;
            // Si le joueur a d√©j√† des stats pour cette √©quipe, OK (substitu√© ou d√©j√† compt√©)
            if (setStats[team][player]) return setStats[team][player];
            // Sinon, v√©rifier qu'il appartient au lineup actuel de l'√©quipe
            const lineup = team === 'home' ? currentSet.homeLineup : currentSet.awayLineup;
            if (!lineup) return null;
            const onCourt = Object.values(lineup).filter(name => name !== null);
            if (!onCourt.includes(player)) {
                // Joueur inconnu pour cette √©quipe ‚Äî ne pas cr√©er d'entr√©e stats fant√¥me
                return null;
            }
            setStats[team][player] = initPlayerStats();
            return setStats[team][player];
        }

        // Qualit√© de r√©ception ‚Üí note num√©rique (pour Moy serveur)
        function receptionQualityToNote(quality) {
            if (!quality || !quality.label) return null;
            switch (quality.label) {
                case 'Excellente': return 4;
                case 'Positive':   return 3;
                case 'Jouable':    return 2;
                case 'N√©gative':   return 1;
                case 'Faute':      return 0;
                default:
                    // Labels sp√©ciaux : utiliser le score directement si disponible
                    return (typeof quality.score === 'number') ? quality.score : null;
            }
        }

        // Chercher la prochaine action d'un certain type apr√®s l'index donn√© dans le rally
        function findNextAction(rally, afterIndex, type) {
            for (let i = afterIndex + 1; i < rally.length; i++) {
                if (rally[i].type === type) return { action: rally[i], index: i };
            }
            return null;
        }

        // Analyser ce qui se passe apr√®s une attaque defended
        // Retourne : 'continued' (A-), 'blocked' (BP), 'ended' (A+)
        function analyzeAfterDefended(rally, afterIndex, oppositeTeam) {
            const attackingTeam = oppositeTeam === 'home' ? 'away' : 'home';
            for (let i = afterIndex + 1; i < rally.length; i++) {
                const a = rally[i];
                if (a.team === oppositeTeam) {
                    // Defense fault = l'adversaire rate sa d√©fense ‚Üí l'attaque a forc√© le point
                    if (a.type === 'defense' && a.result === 'fault') continue;
                    // Block (sauf pass-through) : analyser o√π va la balle apr√®s
                    if (a.type === 'block' && !a.passThrough) {
                        for (let j = i + 1; j < rally.length; j++) {
                            if (rally[j].team === attackingTeam) {
                                // Balle c√¥t√© attaquant : l'attaquant doit d√©fendre
                                if (rally[j].type === 'defense' && rally[j].result === 'fault') {
                                    return 'blocked'; // Defense fault c√¥t√© attaquant = BP
                                }
                                return 'continued'; // L'√©quipe r√©cup√®re le block ‚Üí A-
                            }
                            // V20.188 : si la d√©fense du bloqueur rate, la balle est all√©e c√¥t√© adverse ‚Üí A+
                            if (rally[j].team === oppositeTeam && rally[j].type === 'defense' && rally[j].result === 'fault') {
                                return 'ended'; // Bloc d√©vie c√¥t√© adverse, adversaire rate ‚Üí A+
                            }
                        }
                        return 'blocked'; // Personne ne r√©cup√®re ‚Üí BP
                    }
                    // Toute autre action adverse (pass, attack, defense r√©ussie, retour direct) = jeu continue
                    return 'continued';
                }
            }
            return 'ended';
        }

        // V√©rifie si un retour direct (r√©ception ou d√©fense) est "exploit√©" par l'adversaire
        // = l'adversaire marque directement apr√®s sans que l'√©quipe ait reconstruit (pas de passe/attaque de l'√©quipe entre-temps)
        // ET sans que l'adversaire ait organis√© son jeu (passe adverse = le DR a √©t√© absorb√©, la suite n'est plus li√©e)
        function isDirectReturnExploited(rally, index, team) {
            const oppositeTeam = team === 'home' ? 'away' : 'home';
            for (let j = index + 1; j < rally.length; j++) {
                const a = rally[j];
                // Si l'√©quipe du retour direct fait une passe ou attaque ‚Üí elle a reconstruit ‚Üí non exploit√©
                if (a.team === team && (a.type === 'pass' || a.type === 'attack')) return false;
                // Si l'adversaire fait une passe ‚Üí il a organis√© son jeu ‚Üí le DR a √©t√© absorb√© ‚Üí non exploit√©
                // (une attaque directe SANS passe = exploitation du DR, donc on ne stoppe pas sur attack)
                if (a.team === oppositeTeam && a.type === 'pass') return false;
                // Si l'adversaire marque directement (attaque gagnante, faute d√©fense de l'√©quipe)
                if (a.team === oppositeTeam && a.type === 'attack' && (a.result === 'point' || a.result === 'bloc_out')) return true;
                if (a.team === team && a.type === 'defense' && a.result === 'fault') return true;
            }
            // Si le rally se termine sans suite apr√®s le retour ‚Üí non exploit√© (ex: retour gagnant g√©r√© s√©par√©ment)
            return false;
        }

        function updateStatsFromRally(rally) {
            if (!rally || rally.length === 0) return;

            for (let i = 0; i < rally.length; i++) {
                const action = rally[i];
                const team = action.team;
                const player = action.player;

                if (!team || !player) continue;

                const stats = getPlayerStats(team, player);
                if (!stats) continue;

                switch (action.type) {
                    case 'service': {
                        stats.service.tot++;
                        if (action.result === 'ace') {
                            stats.service.ace++;
                            // Si une r√©ception est associ√©e √† l'ace, la compter dans recSumAdv/recCountAdv
                            const recActionAce = findNextAction(rally, i, 'reception');
                            if (recActionAce) {
                                const noteAce = receptionQualityToNote(recActionAce.action.quality);
                                if (noteAce !== null) {
                                    stats.service.recSumAdv += noteAce;
                                    stats.service.recCountAdv++;
                                }
                            }
                        } else if (action.result === 'fault' || action.result === 'fault_out' || action.result === 'fault_net') {
                            stats.service.fser++;
                        } else {
                            // Service in : chercher la r√©ception adverse pour S+ et Moy
                            const recAction = findNextAction(rally, i, 'reception');
                            if (recAction) {
                                const rec = recAction.action;
                                let note = receptionQualityToNote(rec.quality);
                                if (note !== null) {
                                    // Retour direct gagnant = pire outcome pour le serveur ‚Üí note 0 (FR)
                                    if (rec.isDirectReturnWinner) {
                                        note = 0;
                                    }
                                    // Retour direct exploit√© par le serveur = r√©ception catastrophique ‚Üí note 0 (FR) + S+
                                    else if (rec.isDirectReturn && !rec.isDirectReturnWinner) {
                                        const exploited = isDirectReturnExploited(rally, recAction.index, rec.team);
                                        if (exploited) {
                                            note = 0;
                                        }
                                    }
                                    stats.service.recSumAdv += note;
                                    stats.service.recCountAdv++;
                                    // S+ = faute de r√©ception adverse (note 0)
                                    if (note === 0) {
                                        stats.service.splus++;
                                    }
                                }
                            }
                        }
                        break;
                    }

                    case 'reception': {
                        stats.reception.tot++;
                        // Retour direct exploit√© : R1 ‚Üí FR (l'adversaire marque directement apr√®s)
                        const recExploited = action.isDirectReturn && !action.isDirectReturnWinner
                            && isDirectReturnExploited(rally, i, action.team);
                        if (recExploited) {
                            stats.reception.frec++;
                        } else if (action.quality) {
                            switch (action.quality.label) {
                                case 'Excellente': stats.reception.r4++; break;
                                case 'Positive':   stats.reception.r3++; break;
                                case 'Jouable':    stats.reception.r2++; break;
                                case 'N√©gative':   stats.reception.r1++; break;
                                case 'Faute':      stats.reception.frec++; break;
                                default:
                                    if (action.quality.score === 0) stats.reception.frec++;
                                    break;
                            }
                        }
                        break;
                    }

                    case 'pass': {
                        // V20.0b : Relance passe ‚Äî geste de survie, pas comptabilise en stats passe
                        // Mais r√©trograde la r√©ception/d√©fense pr√©c√©dente et compte une relance R-
                        if (action.passType === 'relance') {
                            // V20.18 : relance out = pas de stats (faute brute, point perdu)
                            if (action.result === 'out') {
                                break;
                            }
                            // Chercher la derni√®re r√©ception ou d√©fense de la m√™me √©quipe en amont
                            for (let j = i - 1; j >= 0; j--) {
                                const prev = rally[j];
                                if (prev.team !== action.team) continue;
                                const prevPlayer = prev.player;
                                if (!prevPlayer) continue;
                                const prevStats = setStats[team][prevPlayer];
                                if (!prevStats) break;

                                if (prev.type === 'reception' && prev.quality) {
                                    // Annuler le score pr√©c√©dent et forcer R1
                                    switch (prev.quality.label) {
                                        case 'Excellente': prevStats.reception.r4--; break;
                                        case 'Positive':   prevStats.reception.r3--; break;
                                        case 'Jouable':    prevStats.reception.r2--; break;
                                        case 'N√©gative':   /* d√©j√† R1 */ break;
                                        case 'Faute':      prevStats.reception.frec--; break;
                                    }
                                    if (prev.quality.label !== 'N√©gative') {
                                        prevStats.reception.r1++;
                                    }
                                    break;
                                }
                                if (prev.type === 'defense') {
                                    // Annuler le score pr√©c√©dent et forcer D (V20.15)
                                    if (prev.defenseQuality === 'positive') {
                                        prevStats.defense.defplus--;
                                        prevStats.defense.defneutral++;
                                    }
                                    // Si d√©j√† D/D-/FD, on ne change rien
                                    break;
                                }
                            }
                            // Passe relance : pas de stats passe (ni Tot ni qualit√©)
                            // Si retour direct ‚Üí la d√©fense adverse g√®re via isDefAfterRelance
                            break;
                        }

                        // V19.2 : qualite de passe + ventilation par contexte
                        const passerRoleP = action.role || 'transition';
                        const passCtxObj = getPassContext(rally.slice(0, i), passerRoleP);
                        const pType = passCtxObj.playerType === 'Passeur' ? 'passeur' : 'autre';
                        const pCtx = passCtxObj.context;

                        // Helper : incrementer tot + score dans un bucket
                        function _incPass(bucket, scoreKey) {
                            bucket.tot++;
                            if (scoreKey === 'fp') bucket.fp++;
                            else if (bucket[scoreKey] !== undefined) bucket[scoreKey]++;
                        }

                        // Retour direct : compter comme FP si exploite
                        if (action.isDirectReturn) {
                            if (!action.isDirectReturnWinner) {
                                const passExploited = isDirectReturnExploited(rally, i, action.team);
                                if (passExploited) {
                                    _incPass(stats.pass, 'fp');
                                    _incPass(stats.pass[pType], 'fp');
                                    if (stats.pass[pType][pCtx]) _incPass(stats.pass[pType][pCtx], 'fp');
                                }
                            }
                            break;
                        }
                        // Passe sans endPos ou filet ‚Üí FP
                        if (!action.endPos || action.endPos.courtSide === 'net') {
                            _incPass(stats.pass, 'fp');
                            _incPass(stats.pass[pType], 'fp');
                            if (stats.pass[pType][pCtx]) _incPass(stats.pass[pType][pCtx], 'fp');
                            break;
                        }

                        // V20.0b : passe courtSide='out' = clic lat√©ral mais dans zone de jeu
                        // ‚Üí convertir vers le court-side de l'√©quipe pour √©valuer normalement
                        let passEndPos = action.endPos;
                        if (passEndPos.courtSide === 'out') {
                            const passCourtSide = getCourtSideForTeam(team);
                            passEndPos = { x: passEndPos.x, y: passEndPos.y, courtSide: passCourtSide };
                        }

                        // Determiner zone et evaluer la qualite
                        const passZone = getPassZone(passEndPos, team);
                        const passContext = passCtxObj.context;
                        const passEval = evaluatePassQuality(action.endPos, passZone, passContext, team);
                        const scoreKey = passEval.score === 4 ? 'p4' : passEval.score === 3 ? 'p3' : passEval.score === 2 ? 'p2' : 'p1';

                        _incPass(stats.pass, scoreKey);
                        _incPass(stats.pass[pType], scoreKey);
                        if (stats.pass[pType][pCtx]) _incPass(stats.pass[pType][pCtx], scoreKey);
                        break;
                    }

                    case 'attack': {
                        const isRelance = action.attackType === 'relance';
                        const oppositeTeam = team === 'home' ? 'away' : 'home';

                        if (isRelance) {
                            // ===== RELANCE : stats terminales compt√©es ici =====
                            // Les cas d√©fendus sont compt√©s c√¥t√© D√âFENSEUR (case 'defense' isDefAfterRelance)
                            // Seuls les cas terminaux (point, faute, bloc) n'ont pas de d√©fense ‚Üí compt√©s ici
                            if (action.result === 'point' || action.result === 'bloc_out') {
                                stats.relance.tot++;
                                stats.relance.relplus++; // R+ : relance gagnante
                            } else if (action.attackType === 'faute' || action.result === 'fault_net' || action.result === 'out') {
                                stats.relance.tot++;
                                stats.relance.frel++; // FR : faute de relance
                            } else if (action.result === 'blocked') {
                                stats.relance.tot++;
                                stats.relance.relminus++; // R- : bloc pris sur relance
                            }
                            // Si result === 'defended' ‚Üí tot + d√©tail compt√©s dans case 'defense'
                            break;
                        }

                        // ===== CAS STANDARD (smash/feinte/etc.) =====
                        stats.attack.tot++;

                        if (action.attackType === 'faute' || action.result === 'fault_net' || action.result === 'out') {
                            // FA : faute d'attaque (filet, out, faute technique)
                            stats.attack.fatt++;
                        } else if (action.result === 'point') {
                            // Kill direct ‚Üí A+
                            stats.attack.attplus++;
                        } else if (action.result === 'bloc_out') {
                            // Bloc out ‚Üí A+ (l'attaquant gagne le point)
                            stats.attack.attplus++;
                        } else if (action.result === 'blocked') {
                            // BP : bloc pris (la balle revient chez l'attaquant)
                            stats.attack.bp++;
                        } else if (action.result === 'defended') {
                            const outcome = analyzeAfterDefended(rally, i, oppositeTeam);
                            if (outcome === 'continued') {
                                stats.attack.attminus++; // Le jeu continue ‚Üí A-
                            } else if (outcome === 'blocked') {
                                stats.attack.bp++; // Bloc pris ‚Üí BP
                            } else {
                                stats.attack.attplus++; // L'attaque a forc√© le point ‚Üí A+
                            }
                        }
                        break;
                    }

                    case 'defense': {
                        // V20.188 : D√©tecter bloc pr√©c√©dent (m√™me √©quipe) pour ajuster la d√©fense
                        // - Apr√®s bloc_out ‚Üí aucune d√©fense compt√©e
                        // - Apr√®s bloc normal ‚Üí D- max (jamais FD)
                        let blockBeforeType = null; // null | 'bloc_out' | 'normal'
                        for (let j = i - 1; j >= 0; j--) {
                            if (rally[j].type === 'block' && rally[j].team === team) {
                                blockBeforeType = rally[j].result === 'bloc_out' ? 'bloc_out' : 'normal';
                                break;
                            }
                            if (rally[j].type === 'pass' && rally[j].team === team) break;
                            if (rally[j].type === 'attack' && rally[j].team === team) break;
                        }
                        if (blockBeforeType === 'bloc_out') break; // Aucune d√©fense compt√©e apr√®s bloc out

                        // Chercher si l'attaque adverse pr√©c√©dente est une relance
                        const oppositeTeamDef = team === 'home' ? 'away' : 'home';
                        let isDefAfterRelance = false;
                        for (let j = i - 1; j >= 0; j--) {
                            if (rally[j].type === 'attack' && rally[j].team === oppositeTeamDef) {
                                isDefAfterRelance = rally[j].attackType === 'relance';
                                break;
                            }
                            // Passe relance retour direct = m√™me traitement qu'attaque relance
                            if (rally[j].type === 'pass' && rally[j].team === oppositeTeamDef
                                && rally[j].passType === 'relance' && rally[j].isDirectReturn) {
                                isDefAfterRelance = true;
                                break;
                            }
                            // Si on trouve un block ou une defense de notre √©quipe avant l'attaque ‚Üí pas directement apr√®s relance
                            if (rally[j].type === 'block' || (rally[j].type === 'defense' && rally[j].team === team)) break;
                        }

                        if (isDefAfterRelance) {
                            // ===== RELANCE : stats compt√©es c√¥t√© d√©fenseur =====
                            // M√™me logique que D+/D-/FD mais dans les compteurs relance
                            stats.relance.tot++;

                            // Retour direct de relance exploit√© ‚Üí FR
                            const relExploited = action.isDirectReturn && !action.isDirectReturnWinner
                                && isDirectReturnExploited(rally, i, action.team);
                            if (relExploited) {
                                stats.relance.frel++;
                            } else if (action.isDirectReturn) {
                                // Retour direct non exploit√© ‚Üí R-
                                stats.relance.relminus++;
                            } else if (action.result === 'fault') {
                                // V20.188 : utilise blockBeforeType d√©j√† calcul√© en d√©but de case
                                if (blockBeforeType === 'normal') {
                                    stats.relance.relminus++; // Bloc avant ‚Üí R- (pas FR)
                                } else {
                                    stats.relance.frel++; // Pas de bloc ‚Üí FR
                                }
                            } else {
                                // Relance d√©fendue : utiliser defenseQuality
                                if (action.defenseQuality === 'positive') {
                                    stats.relance.relplus++; // Zone bleue claire ‚Üí R+
                                } else {
                                    stats.relance.relminus++; // Hors zone ‚Üí R-
                                }
                            }
                        } else {
                            // ===== DEFENSE NORMALE (V20.15 : D+/D/D-/FD) =====
                            stats.defense.tot++;

                            if (action.untouched) {
                                // V20.188 : apr√®s un bloc normal ‚Üí D- max (le bloc a d√©vi√© la trajectoire)
                                if (blockBeforeType === 'normal') {
                                    stats.defense.defminus++;
                                } else {
                                    // Balle non-touch√©e dans la zone ‚Üí FD
                                    stats.defense.fdef++;
                                }
                            } else {
                                // Retour direct de d√©fense exploit√© ‚Üí D- (touch√©e mais perdue)
                                const defExploited = action.isDirectReturn && !action.isDirectReturnWinner
                                    && isDirectReturnExploited(rally, i, action.team);
                                if (defExploited) {
                                    stats.defense.defminus++;
                                } else if (action.isDirectReturn) {
                                    // Retour direct gagnant ou non exploit√© ‚Üí D (touch√©e, pas optimale)
                                    stats.defense.defneutral++;
                                } else if (action.result === 'fault') {
                                    // V20.188 : apr√®s bloc normal ‚Üí D- max (pas FD, le bloc a d√©vi√©)
                                    // Sans bloc ‚Üí D- (seul responsable)
                                    stats.defense.defminus++;
                                } else {
                                    // D√©fense r√©ussie : utiliser defenseQuality si disponible
                                    if (action.defenseQuality === 'positive') {
                                        stats.defense.defplus++;
                                    } else if (action.defenseQuality === 'negative') {
                                        stats.defense.defneutral++; // Touch√©e mais pas optimale ‚Üí D
                                    } else {
                                        stats.defense.defplus++; // Fallback ‚Üí D+
                                    }
                                }
                            }
                        }
                        break;
                    }

                    case 'block': {
                        // V20.188 : Logique simplifi√©e
                        // FB = bloc out uniquement (le statisticien juge le bloqueur fautif)
                        // B+ = bloc kill direct OU bloc retourne c√¥t√© attaquant ET d√©fense attaquant rate
                        // B- = tous les autres cas (pass-through, jeu continue, balle c√¥t√© d√©fenseur)
                        stats.block.tot++;
                        if (action.result === 'bloc_out') {
                            stats.block.fblc++; // FB : bloc out
                        } else if (action.result === 'kill' || action.result === 'point') {
                            stats.block.blcplus++; // B+ : bloc kill direct
                        } else if (action.passThrough) {
                            stats.block.blcminus++; // B- : pass-through (balle traverse le bloc)
                        } else {
                            // Bloc standard : B+ seulement si la balle revient c√¥t√© attaquant
                            // ET la d√©fense de l'attaquant (team oppos√©e au bloqueur) rate
                            let isBlockKill = false;
                            for (let j = i + 1; j < rally.length; j++) {
                                if (rally[j].type === 'defense') {
                                    if (rally[j].result === 'fault' && rally[j].team !== team) {
                                        isBlockKill = true; // D√©fense attaquant rate ‚Üí B+
                                    }
                                    break;
                                }
                                if (rally[j].type === 'pass' || rally[j].type === 'attack') break;
                            }
                            stats.block[isBlockKill ? 'blcplus' : 'blcminus']++;
                        }
                        break;
                    }
                }
            }
        }

        // ==================== INIT ====================
        init();
    </script>
</body>
</html>
