<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match Live - Jen et ses Saints</title>
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;600;700&family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-header: #f8f9fa;
            --text-primary: #202124;
            --text-secondary: #5f6368;
            --border-color: #e8eaed;
            --accent-blue: #0056D2;
            --accent-orange: #ff6b35;
            --court-blue: #2563eb;
            --court-orange: #f59e0b;
            --win-color: #34a853;
            --loss-color: #ea4335;
            --home-color: #0056D2;
            --away-color: #ea4335;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', 'Google Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            max-width: 600px;
            margin: 0 auto;
            overflow-x: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* Header Score */
        .score-header {
            background: linear-gradient(135deg, var(--court-blue) 0%, #1e40af 100%);
            color: white;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 50;
        }

        .score-header-left {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .back-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: none;
            background: rgba(255,255,255,0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            transition: all 0.2s;
        }

        .back-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .set-indicator {
            background: rgba(255,255,255,0.2);
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        .score-display {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .team-score {
            text-align: center;
        }

        .team-name {
            font-size: 9px;
            opacity: 0.8;
            margin-bottom: 1px;
            max-width: 70px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .team-points {
            font-family: 'Google Sans', sans-serif;
            font-size: 24px;
            font-weight: 700;
        }

        .score-separator {
            font-size: 18px;
            opacity: 0.6;
        }

        .serving-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-orange);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.2); }
        }

        /* Main content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 8px 12px;
        }

        /* Phase indicator */
        .phase-indicator {
            text-align: center;
            padding: 6px 12px;
            background: var(--bg-header);
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .phase-indicator .highlight {
            color: var(--accent-blue);
            font-weight: 600;
        }

        /* Court container */
        .court-container {
            background: var(--court-blue);
            border-radius: 10px;
            padding: 8px;
            margin-bottom: 10px;
            position: relative;
            overflow: visible;
        }

        /* Zone out cliquable autour du terrain */
        .out-area {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            cursor: crosshair;
            display: none;
            z-index: 1;
        }

        .out-area.active {
            display: block;
            background: repeating-linear-gradient(
                45deg,
                rgba(107, 114, 128, 0.15),
                rgba(107, 114, 128, 0.15) 10px,
                rgba(107, 114, 128, 0.05) 10px,
                rgba(107, 114, 128, 0.05) 20px
            );
            border: 2px dashed rgba(107, 114, 128, 0.5);
            border-radius: 10px;
            animation: pulse-out 1.5s ease-in-out infinite;
        }

        @keyframes pulse-out {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .out-area-label {
            position: absolute;
            background: rgba(107, 114, 128, 0.9);
            color: white;
            font-size: 9px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .out-area-label.top {
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
        }

        .out-area-label.bottom {
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
        }

        .out-area-label.left {
            left: 4px;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
        }

        .out-area-label.right {
            right: 4px;
            top: 50%;
            transform: translateY(-50%) rotate(90deg);
        }

        .court {
            position: relative;
            width: 100%;
            max-width: 180px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            z-index: 2;
            overflow: visible;
        }

        .team-label {
            text-align: center;
            color: white;
            font-family: 'Google Sans', sans-serif;
            font-size: 9px;
            font-weight: 500;
            padding: 2px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .court-half {
            background: var(--court-orange);
            border: 2px solid white;
            position: relative;
            aspect-ratio: 1 / 1;
            cursor: crosshair;
            overflow: visible;
        }

        .court-half.away {
            border-bottom: none;
            border-radius: 3px 3px 0 0;
        }

        .court-half.home {
            border-top: none;
            border-radius: 0 0 3px 3px;
        }

        .court-half.inactive {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .court-half.target {
            box-shadow: inset 0 0 20px rgba(255,255,255,0.5);
        }

        /* Court lines */
        .court-half::before {
            content: '';
            position: absolute;
            top: 33.33%;
            left: 0;
            right: 0;
            height: 2px;
            background: rgba(255,255,255,0.5);
        }

        .court-half::after {
            content: '';
            position: absolute;
            top: 66.66%;
            left: 0;
            right: 0;
            height: 2px;
            background: rgba(255,255,255,0.5);
        }

        /* Net */
        .net {
            height: 4px;
            background: white;
            position: relative;
            z-index: 5;
        }

        .net::before,
        .net::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            top: 50%;
            transform: translateY(-50%);
        }

        .net::before { left: -4px; }
        .net::after { right: -4px; }

        /* Zone cliquable autour du filet (visible pendant serve_end) */
        .net-click-zone {
            position: absolute;
            top: -8px;
            left: -2px;
            right: -2px;
            height: 20px;
            z-index: 15;
            cursor: pointer;
            pointer-events: none;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .net-click-zone.active {
            pointer-events: auto;
            background: rgba(239, 68, 68, 0.15);
            border: 2px dashed rgba(239, 68, 68, 0.5);
        }

        .net-click-zone.active::after {
            content: 'ü•Ö FILET';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-weight: 700;
            color: #dc2626;
            letter-spacing: 1px;
            white-space: nowrap;
        }

        /* Click markers */
        .click-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 12;
            pointer-events: none;
            border: 2px solid white;
        }

        .click-marker.service {
            background: #6b7280;
        }

        .click-marker.reception {
            background: #3b82f6;
        }

        .click-marker.pass {
            background: #1f2937;
        }

        .click-marker.attack {
            background: #ef4444;
        }

        .click-marker.attack-feinte {
            background: #f97316;
        }

        .click-marker.attack-relance {
            background: #faef00;
        }

        .click-marker.attack-second {
            background: #22d3ee;
        }

        .click-marker.defense {
            background: #8b5cf6;
        }

        .click-marker.block {
            background: #8b5cf6;
        }

        /* Trajectory arrow */
        .trajectory-line {
            position: absolute;
            pointer-events: none;
            z-index: 5;
        }

        /* Tags container */
        .tags-container {
            margin-bottom: 8px;
        }

        .tags-title {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-align: center;
        }

        .tags-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
        }

        .player-tag {
            padding: 8px 14px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .player-tag.home {
            background: #e8f0fe;
            color: var(--home-color);
        }

        .player-tag.home:hover,
        .player-tag.home.selected {
            background: var(--home-color);
            color: white;
        }

        .player-tag.away {
            background: #fee2e2;
            color: var(--away-color);
        }

        .player-tag.away:hover,
        .player-tag.away.selected {
            background: var(--away-color);
            color: white;
        }

        /* Action tags */
        .action-tag {
            padding: 8px 14px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid var(--border-color);
            background: white;
        }

        .action-tag:hover {
            border-color: var(--accent-blue);
            background: #e8f0fe;
        }

        .action-tag.smash {
            border-color: var(--win-color);
            color: var(--win-color);
        }

        .action-tag.smash:hover {
            background: var(--win-color);
            color: white;
        }

        .action-tag.feinte {
            border-color: var(--accent-orange);
            color: var(--accent-orange);
        }

        .action-tag.feinte:hover {
            background: var(--accent-orange);
            color: white;
        }

        .action-tag.relance {
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .action-tag.relance:hover {
            background: var(--accent-blue);
            color: white;
        }

        .action-tag.bloc-direct {
            border-color: #8b5cf6;
            color: #8b5cf6;
        }

        .action-tag.bloc-direct:hover {
            background: #8b5cf6;
            color: white;
        }

        .action-tag.faute {
            border-color: var(--loss-color);
            color: var(--loss-color);
        }

        .action-tag.faute:hover {
            background: var(--loss-color);
            color: white;
        }

        .action-tag.ace {
            border-color: var(--win-color);
            color: var(--win-color);
        }

        .action-tag.ace:hover {
            background: var(--win-color);
            color: white;
        }

        .action-tag.direct-return {
            border-color: #ea580c;
            color: #ea580c;
        }

        .action-tag.direct-return:hover {
            background: #ea580c;
            color: white;
        }

        .action-tag.direct-return-winner {
            border-color: #22c55e;
            color: #22c55e;
        }

        .action-tag.direct-return-winner:hover {
            background: #22c55e;
            color: white;
        }

        .action-tag.second-touch {
            border-color: #22d3ee;
            color: #0891b2;
        }

        .action-tag.second-touch:hover {
            background: #22d3ee;
            color: #1f2937;
        }

        /* Result tags */
        .result-tag {
            padding: 10px 16px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .result-tag.point {
            background: #d1fae5;
            color: #059669;
            border: 2px solid #059669;
        }

        .result-tag.point:hover {
            background: #059669;
            color: white;
        }

        .result-tag.defended {
            background: #fef3c7;
            color: #d97706;
            border: 2px solid #d97706;
        }

        .result-tag.defended:hover {
            background: #d97706;
            color: white;
        }

        .result-tag.blocked {
            background: #fee2e2;
            color: #dc2626;
            border: 2px solid #dc2626;
        }

        .result-tag.blocked:hover {
            background: #dc2626;
            color: white;
        }

        /* Hidden */
        .hidden {
            display: none !important;
        }

        /* Control bar */
        .control-bar {
            display: flex;
            gap: 8px;
            padding: 6px 12px;
            justify-content: space-between;
        }

        .control-bar-left {
            display: flex;
            gap: 8px;
        }

        .control-bar-right {
            display: flex;
            gap: 8px;
        }

        .control-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            opacity: 0.7;
        }

        .control-btn:hover {
            opacity: 1;
        }

        .control-btn.substitute {
            background: #dbeafe;
            color: #1d4ed8;
        }

        .control-btn.substitute:hover {
            background: #1d4ed8;
            color: white;
        }

        .control-btn.cancel {
            background: #fee2e2;
            color: #dc2626;
        }

        .control-btn.cancel:hover {
            background: #dc2626;
            color: white;
        }

        .control-btn.undo {
            background: #e5e7eb;
            color: #374151;
        }

        .control-btn.undo:hover {
            background: #374151;
            color: white;
        }

        /* Modal de changement */
        .sub-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .sub-modal-overlay.active {
            display: flex;
        }

        .sub-modal {
            background: white;
            border-radius: 12px;
            padding: 16px;
            width: 92%;
            max-width: 380px;
            max-height: 85vh;
            overflow-y: auto;
        }

        .sub-modal-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            text-align: center;
        }

        .sub-modal-tabs {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
        }

        .sub-modal-tab {
            flex: 1;
            padding: 6px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            background: white;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
        }

        .sub-modal-tab.active {
            border-color: var(--accent-blue);
            background: #dbeafe;
        }

        .sub-modal-tab.home.active {
            border-color: var(--accent-orange);
            background: #ffedd5;
        }

        /* Mini court in modal */
        .sub-mini-court {
            background: var(--court-orange);
            border-radius: 8px;
            padding: 12px 8px;
            margin-bottom: 10px;
            position: relative;
        }

        .sub-court-row {
            display: flex;
            justify-content: space-around;
            margin-bottom: 8px;
        }

        .sub-court-row.front {
            justify-content: center;
            margin-bottom: 12px;
        }

        .sub-court-row.front::after {
            content: '';
            position: absolute;
            left: 8px;
            right: 8px;
            top: 52px;
            height: 2px;
            background: rgba(255,255,255,0.4);
            border-top: 1px dashed rgba(255,255,255,0.6);
        }

        .sub-court-slot {
            width: 80px;
            min-height: 52px;
            background: rgba(255,255,255,0.25);
            border: 2px dashed rgba(255,255,255,0.6);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
        }

        .sub-court-slot.selected {
            border-color: #fbbf24;
            background: rgba(251,191,36,0.3);
            box-shadow: 0 0 0 2px #fbbf24;
        }

        .sub-court-slot.drag-over {
            border-color: white;
            background: rgba(255,255,255,0.4);
            transform: scale(1.05);
        }

        .sub-court-slot .slot-role {
            font-size: 9px;
            font-weight: 600;
            color: rgba(255,255,255,0.8);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sub-court-slot .slot-player {
            font-size: 12px;
            font-weight: 600;
            color: white;
            text-align: center;
            line-height: 1.2;
        }

        .sub-court-slot.empty .slot-player {
            font-size: 10px;
            color: rgba(255,255,255,0.5);
            font-style: italic;
        }

        /* Bench in modal */
        .sub-bench-section {
            margin-bottom: 10px;
        }

        .sub-bench-label {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .sub-bench-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            min-height: 32px;
        }

        .sub-bench-player {
            padding: 6px 12px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            background: white;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }

        .sub-bench-player.selected {
            border-color: #16a34a;
            background: #dcfce7;
            color: #16a34a;
        }

        .sub-bench-player.drag-over {
            border-color: #3b82f6;
            background: #dbeafe;
        }

        .sub-no-player {
            font-size: 11px;
            color: var(--text-secondary);
            font-style: italic;
        }

        .sub-modal-hint {
            font-size: 10px;
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .sub-modal-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .sub-modal-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
        }

        .sub-modal-btn.cancel {
            background: #e5e7eb;
            color: #374151;
        }

        .sub-modal-btn.confirm {
            background: var(--accent-blue);
            color: white;
        }

        .sub-modal-btn.confirm:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        /* Tableau de statistiques du set */
        .stats-section {
            margin-top: 20px;
            padding: 0 10px;
        }

        .stats-table-container {
            background: var(--bg-header);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .stats-table-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stats-table {
            width: 100%;
            font-size: 10px;
            border-collapse: collapse;
            table-layout: fixed;
        }

        .stats-table th {
            background: #f0f0f0;
            padding: 4px 2px;
            text-align: center;
            font-weight: 600;
            color: #333;
            border-bottom: 2px solid #ddd;
        }

        .stats-table th.player-col {
            text-align: left;
            padding-left: 6px;
            width: 55px;
        }

        .stats-table th.section-header {
            background: #e0e0e0;
            font-weight: 700;
            border-bottom: 1px solid #ccc;
        }

        .stats-table td {
            padding: 3px 2px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        .stats-table td.player-name {
            text-align: left;
            padding-left: 6px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stats-table tbody tr:nth-child(even) {
            background: #fafafa;
        }

        .stats-table tbody tr:hover {
            background: #f0f0f0;
        }

        .stats-table tr.total-row {
            background: #e8e8e8 !important;
            font-weight: 600;
        }

        .stats-table tr.total-row td {
            border-top: 2px solid #ccc;
        }

        .stats-table .positive {
            color: #27ae60;
        }

        .stats-table .negative {
            color: #e74c3c;
        }

        /* SVG Arrow */
        svg.arrow-svg {
            position: absolute;
            top: -50px;
            left: -50px;
            width: calc(100% + 100px);
            height: calc(100% + 100px);
            pointer-events: none;
            z-index: 15;
            overflow: visible;
        }

        .arrow-line {
            stroke-width: 2;
            fill: none;
            stroke-linecap: round;
        }

        .arrow-line.service {
            stroke: #6b7280;
        }

        .arrow-line.reception {
            stroke: #3b82f6;
        }

        .arrow-line.pass {
            stroke: #1f2937;
        }

        .arrow-line.attack {
            stroke: #ef4444;
        }

        .arrow-line.attack-feinte {
            stroke: #f97316;
        }

        .arrow-line.attack-relance {
            stroke: #faef00;
        }

        .arrow-line.attack-second {
            stroke: #22d3ee;
        }

        .arrow-line.defense {
            stroke: #8b5cf6;
        }

        .arrow-line.block {
            stroke: #8b5cf6;
        }

        /* Arrowheads par couleur */
        .arrow-head-service { fill: #6b7280; }
        .arrow-head-reception { fill: #3b82f6; }
        .arrow-head-pass { fill: #1f2937; }
        .arrow-head-attack { fill: #ef4444; }
        .arrow-head-attack-feinte { fill: #f97316; }
        .arrow-head-attack-relance { fill: #faef00; }
        .arrow-head-attack-second { fill: #22d3ee; }
        .arrow-head-defense { fill: #8b5cf6; }
        .arrow-head-block { fill: #8b5cf6; }

        /* Out zone indicator */
        .out-zone {
            position: absolute;
            background: rgba(234, 67, 53, 0.1);
            pointer-events: none;
        }

        /* Service zone */
        .service-zone {
            background: rgba(156, 163, 175, 0.5);
            border: 2px dashed rgba(255, 255, 255, 0.8);
            cursor: crosshair;
            visibility: hidden;
            pointer-events: none;
            position: relative;
        }

        .service-zone.active {
            visibility: visible;
            pointer-events: auto;
        }

        .service-zone.top {
            border-radius: 3px 3px 0 0;
            border-bottom: none;
            height: 40px;
        }

        .service-zone.bottom {
            border-radius: 0 0 3px 3px;
            border-top: none;
            height: 40px;
        }

        .service-zone-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 9px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.8;
        }

        /* Zones de qualit√© de r√©ception */
        /* Position zones for reception auto-select */
        .position-zones {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }

        .position-zones.active {
            opacity: 1;
        }

        .position-zones.active .position-zone {
            pointer-events: auto;
        }

        .position-zone {
            position: absolute;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid transparent;
            transition: all 0.15s;
        }

        .position-zone:hover {
            filter: brightness(1.1);
            border-color: white;
        }

        .zone-label {
            font-size: 11px;
            font-weight: 700;
            color: white;
            text-align: center;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
            line-height: 1.3;
            pointer-events: none;
        }

        /* Bottom court: back = bottom portion */
        #positionZonesBottom .position-zone {
            bottom: 0;
            height: 66%;
        }
        #positionZonesBottom .position-zone[data-zone="left"] { left: 0; width: 33.33%; border-radius: 0 0 0 3px; }
        #positionZonesBottom .position-zone[data-zone="center"] { left: 33.33%; width: 33.34%; }
        #positionZonesBottom .position-zone[data-zone="right"] { right: 0; width: 33.33%; border-radius: 0 0 3px 0; }

        /* Top court: back = top portion */
        #positionZonesTop .position-zone {
            top: 0;
            height: 66%;
        }
        #positionZonesTop .position-zone[data-zone="left"] { left: 0; width: 33.33%; border-radius: 3px 0 0 0; }
        #positionZonesTop .position-zone[data-zone="center"] { left: 33.33%; width: 33.34%; }
        #positionZonesTop .position-zone[data-zone="right"] { right: 0; width: 33.33%; border-radius: 0 3px 0 0; }

        .reception-quality-zones {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            overflow: hidden;
        }

        .reception-quality-zones.active {
            opacity: 1;
        }

        .quality-zone {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0.5;
        }

        .quality-zone.perfect {
            background: #22c55e;
            z-index: 3;
        }

        .quality-zone.good {
            background: #3b82f6;
            z-index: 2;
        }

        .quality-zone.average {
            background: #ef4444;
            z-index: 1;
        }

        /* Zones pour terrain du haut (filet en bas) - demi-cercles vers le haut */
        #qualityZonesTop .quality-zone.average {
            width: 100%;
            height: 80%;
            bottom: 0;
            border-radius: 50% 50% 0 0;
        }

        #qualityZonesTop .quality-zone.good {
            width: 70%;
            height: 55%;
            bottom: 0;
            border-radius: 50% 50% 0 0;
        }

        #qualityZonesTop .quality-zone.perfect {
            width: 40%;
            height: 30%;
            bottom: 0;
            border-radius: 50% 50% 0 0;
        }

        /* Zones pour terrain du bas (filet en haut) - demi-cercles vers le bas */
        #qualityZonesBottom .quality-zone.average {
            width: 100%;
            height: 80%;
            top: 0;
            border-radius: 0 0 50% 50%;
        }

        #qualityZonesBottom .quality-zone.good {
            width: 70%;
            height: 55%;
            top: 0;
            border-radius: 0 0 50% 50%;
        }

        #qualityZonesBottom .quality-zone.perfect {
            width: 40%;
            height: 30%;
            top: 0;
            border-radius: 0 0 50% 50%;
        }

        /* L√©gende de qualit√© */
        .quality-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
            padding: 8px;
            background: var(--bg-header);
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            color: var(--text-secondary);
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-dot.perfect {
            background: #22c55e;
        }

        .legend-dot.good {
            background: #3b82f6;
        }

        .legend-dot.average {
            background: #ef4444;
        }

        .legend-dot.poor {
            background: #9ca3af;
        }

        /* Server continue banner */
        .server-continue-banner {
            text-align: center;
            padding: 10px 16px;
            background: linear-gradient(135deg, #dbeafe, #eff6ff);
            border: 2px solid #3b82f6;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
            color: #1d4ed8;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .server-continue-banner.away {
            background: linear-gradient(135deg, #fee2e2, #fef2f2);
            border-color: #ef4444;
            color: #dc2626;
        }

        .server-continue-banner .server-name {
            font-size: 15px;
            font-weight: 700;
        }

        /* Undo point modal */
        .undo-point-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .undo-point-overlay.active {
            display: flex;
        }

        .undo-point-modal {
            background: white;
            border-radius: 12px;
            padding: 16px;
            width: 90%;
            max-width: 380px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .undo-point-title {
            font-size: 15px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 12px;
            color: #dc2626;
        }

        .undo-point-summary {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .undo-point-score {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
            font-family: 'Google Sans', sans-serif;
        }

        .undo-point-score .score-before {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-secondary);
            text-decoration: line-through;
        }

        .undo-point-score .score-arrow {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .undo-point-score .score-after {
            font-size: 20px;
            font-weight: 700;
            color: #16a34a;
        }

        .undo-point-detail {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .undo-point-detail .label {
            font-weight: 600;
            color: var(--text-primary);
        }

        .undo-point-actions {
            display: flex;
            gap: 8px;
        }

        .undo-point-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        .undo-point-btn.keep {
            background: #e5e7eb;
            color: #374151;
        }

        .undo-point-btn.remove {
            background: #dc2626;
            color: white;
        }

        /* Bouton Fin du Set */
        .control-btn.end-set {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #f59e0b;
        }

        .control-btn.end-set:active {
            background: #fde68a;
        }

        /* Modal fin de set */
        .end-set-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .end-set-overlay.active {
            display: flex;
        }

        .end-set-modal {
            background: white;
            border-radius: 16px;
            padding: 20px;
            width: 92%;
            max-width: 400px;
            max-height: 85vh;
            overflow-y: auto;
        }

        .end-set-icon {
            text-align: center;
            font-size: 36px;
            margin-bottom: 8px;
        }

        .end-set-title {
            font-family: 'Google Sans', sans-serif;
            font-size: 17px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 4px;
            color: var(--text-primary);
        }

        .end-set-subtitle {
            font-size: 12px;
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        .end-set-score-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 14px;
            background: #f8f9fa;
            border-radius: 12px;
            margin-bottom: 16px;
        }

        .end-set-score-display .team {
            text-align: center;
            flex: 1;
        }

        .end-set-score-display .team-name {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .end-set-score-display .team-pts {
            font-family: 'Google Sans', sans-serif;
            font-size: 28px;
            font-weight: 700;
        }

        .end-set-score-display .team-pts.winner {
            color: #16a34a;
        }

        .end-set-score-display .team-pts.loser {
            color: #dc2626;
        }

        .end-set-score-display .vs {
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .end-set-winner {
            text-align: center;
            font-size: 13px;
            font-weight: 600;
            color: #16a34a;
            margin-bottom: 16px;
        }

        /* Choix de raison (cas manuel) */
        .end-set-reasons {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 16px;
        }

        .end-set-reason-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 14px;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            background: white;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
        }

        .end-set-reason-btn:active {
            transform: scale(0.98);
        }

        .end-set-reason-btn.selected {
            border-color: var(--accent-blue);
            background: #eff6ff;
        }

        .end-set-reason-btn .reason-icon {
            font-size: 20px;
            width: 30px;
            text-align: center;
        }

        .end-set-reason-btn .reason-text {
            flex: 1;
        }

        .end-set-reason-btn .reason-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .end-set-reason-btn .reason-desc {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        /* Score r√©el (pour cas cam√©ra) */
        .end-set-real-score {
            display: none;
            background: #fff7ed;
            border: 1px solid #fed7aa;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 16px;
        }

        .end-set-real-score.visible {
            display: block;
        }

        .end-set-real-score-title {
            font-size: 12px;
            font-weight: 600;
            color: #92400e;
            margin-bottom: 10px;
            text-align: center;
        }

        .end-set-real-score-inputs {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .end-set-real-score-inputs .team-input {
            text-align: center;
        }

        .end-set-real-score-inputs .team-input label {
            display: block;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .end-set-real-score-inputs .team-input input {
            width: 60px;
            padding: 8px;
            text-align: center;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 18px;
            font-weight: 700;
            font-family: 'Google Sans', sans-serif;
        }

        .end-set-real-score-inputs .input-sep {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-secondary);
            padding-top: 18px;
        }

        /* Stats recap */
        .end-set-stats-recap {
            font-size: 11px;
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 16px;
            line-height: 1.6;
        }

        .end-set-stats-recap .stat-highlight {
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Actions */
        .end-set-actions {
            display: flex;
            gap: 8px;
        }

        .end-set-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            font-family: inherit;
        }

        .end-set-btn.cancel {
            background: #e5e7eb;
            color: #374151;
        }

        .end-set-btn.confirm {
            background: var(--accent-blue);
            color: white;
        }

        .end-set-btn.confirm:disabled {
            background: #93c5fd;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Score Header -->
        <header class="score-header">
            <div class="score-header-left">
                <button class="back-btn" onclick="handleBack()">
                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                    </svg>
                </button>
                <span class="set-indicator" id="setIndicator">SET 1</span>
            </div>
            <div class="score-display">
                <div class="team-score" id="homeScoreDisplay">
                    <div class="team-name">Jen et ses Saints</div>
                    <div class="team-points" id="homePoints">0</div>
                </div>
                <span class="score-separator">-</span>
                <div class="team-score" id="awayScoreDisplay">
                    <div class="team-name" id="awayTeamName">Adversaire</div>
                    <div class="team-points" id="awayPoints">0</div>
                </div>
            </div>
            <div class="serving-indicator" id="servingIndicator" title="Au service"></div>
        </header>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Phase Indicator -->
            <div class="phase-indicator" id="phaseIndicator">
                <span class="highlight">Service</span> ‚Äî S√©lectionnez le serveur
            </div>

            <!-- Control buttons (toujours visibles, position fixe) -->
            <div class="control-bar">
                <div class="control-bar-left">
                    <button class="control-btn substitute" id="btnSubstitute" onclick="openSubModal()" title="Changement" style="display: none;">
                        <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M16 17.01V10h-2v7.01h-3L15 21l4-3.99h-3zM9 3L5 6.99h3V14h2V6.99h3L9 3z"/>
                        </svg>
                        Changement
                    </button>
                    <button class="control-btn end-set" id="btnEndSet" onclick="openEndSetModal('manual')" title="Terminer le set" style="display: none;">
                        <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"/>
                        </svg>
                        Fin du Set
                    </button>
                </div>
                <div class="control-bar-right">
                    <button class="control-btn undo" onclick="undoLastAction()" title="Retour">
                        <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>
                        </svg>
                        Retour
                    </button>
                    <button class="control-btn cancel" onclick="cancelPoint()" title="Annuler le point">
                        <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                        </svg>
                        Annuler point
                    </button>
                </div>
            </div>

            <!-- Court -->
            <div class="court-container" id="courtContainer">
                <!-- Zone out cliquable (visible pendant serve_end) -->
                <div class="out-area" id="outArea">
                    <span class="out-area-label top" id="outLabelTop">OUT</span>
                    <span class="out-area-label bottom" id="outLabelBottom">OUT</span>
                    <span class="out-area-label left">OUT</span>
                    <span class="out-area-label right">OUT</span>
                </div>
                
                <div class="court" id="court">
                    <!-- Zone de service haut -->
                    <div class="service-zone top" id="serviceZoneTop">
                        <span class="service-zone-label">Zone de service</span>
                    </div>
                    
                    <div class="team-label" id="topTeamLabel">Adversaire</div>
                    <div class="court-half away" id="courtTop" data-team="away">
                        <!-- Zones de position (pour auto-s√©lection r√©ception) -->
                        <div class="position-zones" id="positionZonesTop">
                            <div class="position-zone" data-zone="left"></div>
                            <div class="position-zone" data-zone="center"></div>
                            <div class="position-zone" data-zone="right"></div>
                        </div>
                        <!-- Zones de qualit√© de r√©ception -->
                        <div class="reception-quality-zones" id="qualityZonesTop">
                            <div class="quality-zone average"></div>
                            <div class="quality-zone good"></div>
                            <div class="quality-zone perfect"></div>
                        </div>
                    </div>
                    <div class="net" id="netZone">
                        <div class="net-click-zone" id="netClickZone"></div>
                    </div>
                    <div class="court-half home" id="courtBottom" data-team="home">
                        <!-- Zones de position (pour auto-s√©lection r√©ception) -->
                        <div class="position-zones" id="positionZonesBottom">
                            <div class="position-zone" data-zone="left"></div>
                            <div class="position-zone" data-zone="center"></div>
                            <div class="position-zone" data-zone="right"></div>
                        </div>
                        <!-- Zones de qualit√© de r√©ception -->
                        <div class="reception-quality-zones" id="qualityZonesBottom">
                            <div class="quality-zone average"></div>
                            <div class="quality-zone good"></div>
                            <div class="quality-zone perfect"></div>
                        </div>
                    </div>
                    <div class="team-label" id="bottomTeamLabel">Jen et ses Saints</div>
                    
                    <!-- Zone de service bas -->
                    <div class="service-zone bottom" id="serviceZoneBottom">
                        <span class="service-zone-label">Zone de service</span>
                    </div>
                </div>
                
                <!-- SVG for arrows (dans court-container pour couvrir la zone out) -->
                <svg class="arrow-svg" id="arrowSvg">
                    <defs>
                        <marker id="arrowhead-service" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-service" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-reception" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-reception" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-pass" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-pass" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-attack" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-attack" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-attack-feinte" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-attack-feinte" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-attack-relance" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-attack-relance" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-attack-second" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-attack-second" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-defense" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-defense" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-block" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-block" points="0 0, 10 3.5, 0 7" />
                        </marker>
                    </defs>
                </svg>
            </div>

            <!-- Tags Container -->
            <div class="tags-container" id="tagsContainer">
                <!-- Server selection (initial) -->
                <div id="serverSelection">
                    <div class="tags-title">Qui sert ?</div>
                    <div class="tags-grid" id="serverTags">
                        <!-- Generated dynamically -->
                    </div>
                </div>

                <!-- Server continue indicator -->
                <div id="serverContinue" class="hidden">
                    <div class="server-continue-banner" id="serverContinueBanner">
                        üèê <span class="server-name" id="serverContinueName">Joueur</span> toujours au service
                    </div>
                </div>

                <!-- Player selection -->
                <div id="playerSelection" class="hidden">
                    <div class="tags-title" id="playerSelectionTitle">S√©lectionnez le joueur</div>
                    <div class="tags-grid" id="playerTags">
                        <!-- Generated dynamically -->
                    </div>
                </div>

                <!-- Options 2√®me touche (visible uniquement pendant la phase passe) -->
                <div id="secondTouchOptions" class="hidden">
                    <div class="tags-title">Ou action en 2√®me touche</div>
                    <div class="tags-grid">
                        <button class="action-tag second-touch" onclick="handleSecondTouch('deuxieme_main')">‚úã Deuxi√®me main</button>
                        <button class="action-tag second-touch" onclick="handleSecondTouch('attaque_directe')">‚ö° Attaque directe</button>
                    </div>
                </div>

                <!-- Faute de passe (visible pendant phase pass_end) -->
                <div id="passFaultSection" class="hidden">
                    <div class="tags-grid">
                        <button class="action-tag faute" onclick="handlePassFault()">‚ùå Faute de passe</button>
                    </div>
                </div>

                <!-- R√©sultat faute de passe (visible quand passe arrive IN chez adversaire) -->
                <div id="passFaultResultSection" class="hidden">
                    <div class="tags-title">La passe est arriv√©e chez l'adversaire</div>
                    <div class="tags-grid">
                        <button class="action-tag point" onclick="handlePassFaultResult('point')">üèÜ Point direct</button>
                        <button class="action-tag defense" onclick="handlePassFaultResult('defense')">üõ°Ô∏è D√©fendu</button>
                    </div>
                </div>

                <!-- Attack type selection -->
                <div id="attackTypeSelection" class="hidden">
                    <div class="tags-title">Type d'attaque</div>
                    <div class="tags-grid">
                        <button class="action-tag smash" onclick="selectAttackType('smash')">üí™ Smash</button>
                        <button class="action-tag feinte" onclick="selectAttackType('feinte')">üéØ Feinte</button>
                        <button class="action-tag relance" onclick="selectAttackType('relance')">‚Ü©Ô∏è Relance</button>
                        <button class="action-tag bloc-direct" onclick="selectAttackType('bloc_direct')">üôå Bloc direct</button>
                        <button class="action-tag faute" onclick="selectAttackType('faute')">‚ùå Faute</button>
                    </div>
                </div>

                <!-- Result selection -->
                <div id="resultSelection" class="hidden">
                    <div class="tags-title">R√©sultat de l'attaque</div>
                    <div class="tags-grid">
                        <button class="result-tag point" onclick="selectResult('point')">‚úì Point</button>
                        <button class="result-tag defended" onclick="selectResult('defended')">üõ°Ô∏è D√©fendu</button>
                        <button class="result-tag blocked" onclick="selectResult('blocked')">‚úã Block√©e</button>
                    </div>
                </div>

                <!-- Faute de r√©ception / Retour direct -->
                <div id="receptionFaultSection" class="hidden">
                    <div class="tags-grid">
                        <button class="action-tag faute" onclick="handleReceptionFault()">‚ùå Faute r√©ception</button>
                        <button class="action-tag direct-return" onclick="handleDirectReturn()">‚Ü©Ô∏è Retour direct</button>
                        <button class="action-tag direct-return-winner" onclick="handleDirectReturnWinner()">‚úÖ Retour gagnant</button>
                    </div>
                    <div class="quality-legend">
                        <span class="legend-item"><span class="legend-dot perfect"></span>Excellente 4/4</span>
                        <span class="legend-item"><span class="legend-dot good"></span>Positive 3/4</span>
                        <span class="legend-item"><span class="legend-dot average"></span>Jouable 2/4</span>
                        <span class="legend-item"><span class="legend-dot poor"></span>N√©gative 1/4</span>
                    </div>
                </div>

                <div id="serveAceSection" class="hidden">
                    <div class="tags-grid">
                        <button class="action-tag ace" onclick="activateAceMode()">üéØ Ace</button>
                    </div>
                </div>
            </div>
        </main>

        <!-- Tableau de statistiques du set -->
        <div class="stats-section">
            <!-- Tableau √©quipe domicile -->
            <div class="stats-table-container">
                <div class="stats-table-title">üìä <span id="homeTeamStatsTitle">Jen et ses Saints</span></div>
                <table class="stats-table">
                    <thead>
                        <tr>
                            <th class="player-col" rowspan="2">Joueur</th>
                            <th colspan="3" class="section-header">Service</th>
                            <th colspan="5" class="section-header">R√©ception</th>
                            <th colspan="5" class="section-header">Attaque</th>
                            <th class="section-header">Bloc</th>
                        </tr>
                        <tr>
                            <th>Tot</th>
                            <th>Ace</th>
                            <th>FS</th>
                            <th>Tot</th>
                            <th>Ft</th>
                            <th>+</th>
                            <th>J</th>
                            <th>-</th>
                            <th>Tot</th>
                            <th>FD</th>
                            <th>Bl</th>
                            <th>+</th>
                            <th>-</th>
                            <th>Bl</th>
                        </tr>
                    </thead>
                    <tbody id="homeStatsBody">
                        <!-- G√©n√©r√© dynamiquement -->
                    </tbody>
                </table>
            </div>

            <!-- Tableau √©quipe adverse -->
            <div class="stats-table-container">
                <div class="stats-table-title">üìä <span id="awayTeamStatsTitle">Adversaire</span></div>
                <table class="stats-table">
                    <thead>
                        <tr>
                            <th class="player-col" rowspan="2">Joueur</th>
                            <th colspan="3" class="section-header">Service</th>
                            <th colspan="5" class="section-header">R√©ception</th>
                            <th colspan="5" class="section-header">Attaque</th>
                            <th class="section-header">Bloc</th>
                        </tr>
                        <tr>
                            <th>Tot</th>
                            <th>Ace</th>
                            <th>FS</th>
                            <th>Tot</th>
                            <th>Ft</th>
                            <th>+</th>
                            <th>J</th>
                            <th>-</th>
                            <th>Tot</th>
                            <th>FD</th>
                            <th>Bl</th>
                            <th>+</th>
                            <th>-</th>
                            <th>Bl</th>
                        </tr>
                    </thead>
                    <tbody id="awayStatsBody">
                        <!-- G√©n√©r√© dynamiquement -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Modal de changement -->
        <div class="sub-modal-overlay" id="subModalOverlay" onclick="closeSubModal(event)">
            <div class="sub-modal" onclick="event.stopPropagation()">
                <div class="sub-modal-title">üîÑ Changement / Positions</div>
                
                <div class="sub-modal-tabs">
                    <button class="sub-modal-tab home active" id="subTabHome" onclick="switchSubTeam('home')">Jen et ses Saints</button>
                    <button class="sub-modal-tab away" id="subTabAway" onclick="switchSubTeam('away')">Adversaire</button>
                </div>

                <div class="sub-modal-hint">Cliquez 2 joueurs sur le terrain pour √©changer leurs positions.<br>Cliquez un rempla√ßant puis un joueur sur le terrain pour substituer.</div>
                
                <!-- Mini court -->
                <div class="sub-mini-court" id="subMiniCourt">
                    <div class="sub-court-row front">
                        <div class="sub-court-slot" id="subSlotPasseur" onclick="subSlotClick('Passeur')">
                            <span class="slot-role">Passeur</span>
                            <span class="slot-player">‚Äî</span>
                        </div>
                    </div>
                    <div class="sub-court-row">
                        <div class="sub-court-slot" id="subSlotR4" onclick="subSlotClick('R4')">
                            <span class="slot-role">R4</span>
                            <span class="slot-player">‚Äî</span>
                        </div>
                        <div class="sub-court-slot" id="subSlotCentre" onclick="subSlotClick('Centre')">
                            <span class="slot-role">Centre</span>
                            <span class="slot-player">‚Äî</span>
                        </div>
                        <div class="sub-court-slot" id="subSlotPointu" onclick="subSlotClick('Pointu')">
                            <span class="slot-role">Pointu</span>
                            <span class="slot-player">‚Äî</span>
                        </div>
                    </div>
                </div>

                <!-- Bench -->
                <div class="sub-bench-section">
                    <div class="sub-bench-label">ü™ë Rempla√ßants :</div>
                    <div class="sub-bench-grid" id="subBenchGrid">
                        <!-- Generated dynamically -->
                    </div>
                </div>
                
                <div class="sub-modal-actions">
                    <button class="sub-modal-btn cancel" onclick="closeSubModal()">Fermer</button>
                </div>
            </div>
        </div>

        <!-- Modal annuler dernier point -->
        <div class="undo-point-overlay" id="undoPointOverlay" onclick="closeUndoPointModal(event)">
            <div class="undo-point-modal" onclick="event.stopPropagation()">
                <div class="undo-point-title">‚ö†Ô∏è Annuler le dernier point ?</div>
                <div class="undo-point-summary" id="undoPointSummary">
                    <!-- Rempli dynamiquement -->
                </div>
                <div class="undo-point-actions">
                    <button class="undo-point-btn keep" onclick="closeUndoPointModal()">Garder</button>
                    <button class="undo-point-btn remove" onclick="confirmUndoLastPoint()">Supprimer ce point</button>
                </div>
            </div>
        </div>

        <!-- Modal fin de set -->
        <div class="end-set-overlay" id="endSetOverlay">
            <div class="end-set-modal" onclick="event.stopPropagation()">
                <div class="end-set-icon" id="endSetIcon">üèÜ</div>
                <div class="end-set-title" id="endSetTitle">Fin du Set</div>
                <div class="end-set-subtitle" id="endSetSubtitle"></div>
                
                <!-- Score actuel -->
                <div class="end-set-score-display" id="endSetScoreDisplay">
                    <div class="team">
                        <div class="team-name">Jen et ses Saints</div>
                        <div class="team-pts" id="endSetHomeScore">0</div>
                    </div>
                    <div class="vs">‚Äî</div>
                    <div class="team">
                        <div class="team-name" id="endSetAwayName">Adversaire</div>
                        <div class="team-pts" id="endSetAwayScore">0</div>
                    </div>
                </div>
                
                <div class="end-set-winner" id="endSetWinner"></div>

                <!-- Choix raison (mode manuel uniquement) -->
                <div class="end-set-reasons" id="endSetReasons" style="display:none;">
                    <button class="end-set-reason-btn" onclick="selectEndReason('camera')">
                        <span class="reason-icon">üìπ</span>
                        <div class="reason-text">
                            <div class="reason-title">Probl√®me cam√©ra</div>
                            <div class="reason-desc">Batterie, chute, obstruction‚Ä¶ Saisir le score r√©el</div>
                        </div>
                    </button>
                    <button class="end-set-reason-btn" onclick="selectEndReason('time')">
                        <span class="reason-icon">‚è±Ô∏è</span>
                        <div class="reason-text">
                            <div class="reason-title">Fin du cr√©neau</div>
                            <div class="reason-desc">Le set se termine sur le score actuel</div>
                        </div>
                    </button>
                </div>

                <!-- Score r√©el (mode cam√©ra) -->
                <div class="end-set-real-score" id="endSetRealScore">
                    <div class="end-set-real-score-title">Score r√©el de fin de set</div>
                    <div class="end-set-real-score-inputs">
                        <div class="team-input">
                            <label>Jen et ses Saints</label>
                            <input type="number" id="realScoreHome" min="0" max="99" value="0">
                        </div>
                        <div class="input-sep">‚Äî</div>
                        <div class="team-input">
                            <label id="realScoreAwayLabel">Adversaire</label>
                            <input type="number" id="realScoreAway" min="0" max="99" value="0">
                        </div>
                    </div>
                </div>

                <!-- Recap stats -->
                <div class="end-set-stats-recap" id="endSetStatsRecap"></div>

                <!-- Actions -->
                <div class="end-set-actions">
                    <button class="end-set-btn cancel" id="endSetCancelBtn" onclick="closeEndSetModal()">Annuler</button>
                    <button class="end-set-btn cancel" id="endSetBackBtn" onclick="returnToGameForCorrection()">‚Üê Corriger</button>
                    <button class="end-set-btn confirm" id="endSetConfirmBtn" onclick="confirmEndSet()">Valider</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== DONN√âES ====================
        const currentMatch = JSON.parse(localStorage.getItem('volleyball_current_match')) || null;
        let currentSet = null;
        let setIndex = 0;

        // √âtat du jeu
        let gameState = {
            phase: 'server_selection', // server_selection, serve_start, serve_end, reception, pass, attack_player, attack_type, attack_start, attack_end, result, defense, defense_end, etc.
            servingTeam: 'away', // qui sert actuellement
            attackingTeam: 'home', // qui attaque actuellement
            currentServer: null,
            clicks: [], // positions cliqu√©es
            currentAction: {}, // action en cours
            rally: [], // toutes les actions du point en cours
            homeScore: 0,
            awayScore: 0,
            setEnded: false,
            receptionAutoSelected: false, // true si le r√©ceptionneur a √©t√© auto-s√©lectionn√© via zone pendant serve_end
            passAutoSelected: false, // true si le passeur a √©t√© auto-s√©lectionn√© (r√©ception excellente)
            aceMode: false // true si l'utilisateur a cliqu√© Ace pendant serve_end
        };

        // Statistiques du set
        let setStats = {
            home: {}, // { playerName: { service: {tot, ace, fs}, reception: {tot, faute, positive, jouable, negative}, attack: {tot, fd, bl, plus, minus}, block: {bl} } }
            away: {}
        };

        function initPlayerStats(playerName) {
            return {
                service: { tot: 0, ace: 0, fs: 0 },
                reception: { tot: 0, faute: 0, positive: 0, jouable: 0, negative: 0 },
                attack: { tot: 0, fd: 0, bl: 0, plus: 0, minus: 0 },
                block: { bl: 0 }
            };
        }

        function initSetStats() {
            setStats = { home: {}, away: {} };
            
            // Initialiser les stats pour les joueurs de l'√©quipe home
            if (currentSet && currentSet.homeLineup) {
                Object.values(currentSet.homeLineup).forEach(name => {
                    if (name) setStats.home[name] = initPlayerStats(name);
                });
            }
            
            // Initialiser les stats pour les joueurs de l'√©quipe adverse
            if (currentSet && currentSet.awayLineup) {
                Object.values(currentSet.awayLineup).forEach(name => {
                    if (name) setStats.away[name] = initPlayerStats(name);
                });
            }
            
            renderStatsTables();
        }

        function renderStatsTables() {
            renderStatsTable('home', 'homeStatsBody');
            renderStatsTable('away', 'awayStatsBody');
        }

        function renderStatsTable(team, bodyId) {
            const tbody = document.getElementById(bodyId);
            const stats = setStats[team];
            const players = Object.keys(stats);
            
            // Calculer les totaux
            const totals = {
                service: { tot: 0, ace: 0, fs: 0 },
                reception: { tot: 0, faute: 0, positive: 0, jouable: 0, negative: 0 },
                attack: { tot: 0, fd: 0, bl: 0, plus: 0, minus: 0 },
                block: { bl: 0 }
            };
            
            let html = '';
            
            players.forEach(playerName => {
                const p = stats[playerName];
                
                // Additionner aux totaux
                totals.service.tot += p.service.tot;
                totals.service.ace += p.service.ace;
                totals.service.fs += p.service.fs;
                totals.reception.tot += p.reception.tot;
                totals.reception.faute += p.reception.faute;
                totals.reception.positive += p.reception.positive;
                totals.reception.jouable += p.reception.jouable;
                totals.reception.negative += p.reception.negative;
                totals.attack.tot += p.attack.tot;
                totals.attack.fd += p.attack.fd;
                totals.attack.bl += p.attack.bl;
                totals.attack.plus += p.attack.plus;
                totals.attack.minus += p.attack.minus;
                totals.block.bl += p.block.bl;
                
                html += `
                    <tr>
                        <td class="player-name">${playerName}</td>
                        <td>${p.service.tot || '-'}</td>
                        <td class="${p.service.ace > 0 ? 'positive' : ''}">${p.service.ace || '-'}</td>
                        <td class="${p.service.fs > 0 ? 'negative' : ''}">${p.service.fs || '-'}</td>
                        <td>${p.reception.tot || '-'}</td>
                        <td class="${p.reception.faute > 0 ? 'negative' : ''}">${p.reception.faute || '-'}</td>
                        <td class="${p.reception.positive > 0 ? 'positive' : ''}">${p.reception.positive || '-'}</td>
                        <td>${p.reception.jouable || '-'}</td>
                        <td class="${p.reception.negative > 0 ? 'negative' : ''}">${p.reception.negative || '-'}</td>
                        <td>${p.attack.tot || '-'}</td>
                        <td class="${p.attack.fd > 0 ? 'negative' : ''}">${p.attack.fd || '-'}</td>
                        <td class="${p.attack.bl > 0 ? 'negative' : ''}">${p.attack.bl || '-'}</td>
                        <td class="${p.attack.plus > 0 ? 'positive' : ''}">${p.attack.plus || '-'}</td>
                        <td class="${p.attack.minus > 0 ? 'negative' : ''}">${p.attack.minus || '-'}</td>
                        <td class="${p.block.bl > 0 ? 'positive' : ''}">${p.block.bl || '-'}</td>
                    </tr>
                `;
            });
            
            // Ligne total
            html += `
                <tr class="total-row">
                    <td class="player-name">TOTAL</td>
                    <td>${totals.service.tot || '-'}</td>
                    <td class="${totals.service.ace > 0 ? 'positive' : ''}">${totals.service.ace || '-'}</td>
                    <td class="${totals.service.fs > 0 ? 'negative' : ''}">${totals.service.fs || '-'}</td>
                    <td>${totals.reception.tot || '-'}</td>
                    <td class="${totals.reception.faute > 0 ? 'negative' : ''}">${totals.reception.faute || '-'}</td>
                    <td class="${totals.reception.positive > 0 ? 'positive' : ''}">${totals.reception.positive || '-'}</td>
                    <td>${totals.reception.jouable || '-'}</td>
                    <td class="${totals.reception.negative > 0 ? 'negative' : ''}">${totals.reception.negative || '-'}</td>
                    <td>${totals.attack.tot || '-'}</td>
                    <td class="${totals.attack.fd > 0 ? 'negative' : ''}">${totals.attack.fd || '-'}</td>
                    <td class="${totals.attack.bl > 0 ? 'negative' : ''}">${totals.attack.bl || '-'}</td>
                    <td class="${totals.attack.plus > 0 ? 'positive' : ''}">${totals.attack.plus || '-'}</td>
                    <td class="${totals.attack.minus > 0 ? 'negative' : ''}">${totals.attack.minus || '-'}</td>
                    <td class="${totals.block.bl > 0 ? 'positive' : ''}">${totals.block.bl || '-'}</td>
                </tr>
            `;
            
            tbody.innerHTML = html;
        }

        // Configuration cam√©ra (qui est en bas)
        let cameraSide = 'home'; // 'home' = Jen en bas, 'away' = adversaire en bas

        // ==================== INITIALISATION ====================
        function init() {
            if (!currentMatch) {
                window.location.href = 'nouveau-match.html';
                return;
            }

            // R√©cup√©rer le set actuel
            setIndex = (currentMatch.sets?.length || 1) - 1;
            currentSet = currentMatch.sets?.[setIndex];

            if (!currentSet) {
                window.location.href = 'match-set-composition.html';
                return;
            }

            // Configuration
            cameraSide = currentSet.cameraSide || 'home';
            gameState.servingTeam = currentSet.servingTeam || 'away';
            gameState.homeScore = currentSet.homeScore || 0;
            gameState.awayScore = currentSet.awayScore || 0;

            // Sauvegarder le score initial (bonus) si pas encore fait
            if (currentSet.initialHomeScore === undefined) {
                currentSet.initialHomeScore = gameState.homeScore;
                currentSet.initialAwayScore = gameState.awayScore;
            }

            // Mettre √† jour l'affichage
            updateLabels();
            updateScore();
            updatePhase();
            renderServerSelection();
            setupCourtListeners();
            
            // Initialiser les statistiques du set
            initSetStats();
            
            // Mettre √† jour les titres des tableaux de stats
            const opponent = currentMatch.opponent || 'Adversaire';
            document.getElementById('homeTeamStatsTitle').textContent = 'Jen et ses Saints';
            document.getElementById('awayTeamStatsTitle').textContent = opponent;
        }

        // ==================== AFFICHAGE ====================
        function updateLabels() {
            const opponent = currentMatch.opponent || 'Adversaire';
            
            document.getElementById('awayTeamName').textContent = opponent;
            document.getElementById('setIndicator').textContent = `SET ${setIndex + 1}`;

            // Labels du terrain selon c√¥t√© cam√©ra
            if (cameraSide === 'home') {
                document.getElementById('topTeamLabel').textContent = opponent;
                document.getElementById('bottomTeamLabel').textContent = 'Jen et ses Saints';
            } else {
                document.getElementById('topTeamLabel').textContent = 'Jen et ses Saints';
                document.getElementById('bottomTeamLabel').textContent = opponent;
            }
        }

        function updateScore() {
            document.getElementById('homePoints').textContent = gameState.homeScore;
            document.getElementById('awayPoints').textContent = gameState.awayScore;

            // Indicateur de service
            const indicator = document.getElementById('servingIndicator');
            const homeDisplay = document.getElementById('homeScoreDisplay');
            const awayDisplay = document.getElementById('awayScoreDisplay');

            if (gameState.servingTeam === 'home') {
                homeDisplay.style.opacity = '1';
                awayDisplay.style.opacity = '0.6';
            } else {
                homeDisplay.style.opacity = '0.6';
                awayDisplay.style.opacity = '1';
            }
        }

        function updatePhase() {
            const phaseEl = document.getElementById('phaseIndicator');
            const phases = {
                'server_selection': '<span class="highlight">Service</span> ‚Äî S√©lectionnez le serveur',
                'serve_start': '<span class="highlight">Service</span> ‚Äî Cliquez le point de d√©part',
                'serve_end': '<span class="highlight">Service</span> ‚Äî Cliquez le point d\'arriv√©e',
                'reception': '<span class="highlight">R√©ception</span> ‚Äî S√©lectionnez le r√©ceptionneur',
                'reception_end': '<span class="highlight">R√©ception</span> ‚Äî Cliquez o√π arrive la r√©ception',
                'direct_return_end': '<span class="highlight">Retour direct</span> ‚Äî Cliquez o√π arrive le retour',
                'pass': '<span class="highlight">Passe</span> ‚Äî S√©lectionnez le passeur',
                'pass_end': '<span class="highlight">Passe</span> ‚Äî Cliquez o√π arrive la passe',
                'pass_fault_end': '<span class="highlight">Faute de passe</span> ‚Äî Cliquez o√π arrive la passe',
                'pass_fault_result': '<span class="highlight">Faute de passe</span> ‚Äî R√©sultat ?',
                'second_touch_player': '<span class="highlight">2√®me touche</span> ‚Äî Qui fait la 2√®me touche ?',
                'attack_player': '<span class="highlight">Attaque</span> ‚Äî S√©lectionnez l\'attaquant',
                'attack_type': '<span class="highlight">Attaque</span> ‚Äî Type ou cliquez le terrain = smash',
                'attack_end': '<span class="highlight">Attaque</span> ‚Äî Cliquez o√π arrive l\'attaque',
                'result': '<span class="highlight">R√©sultat</span> ‚Äî Qu\'est-ce qui s\'est pass√© ?',
                'block_end': '<span class="highlight">Block</span> ‚Äî Cliquez o√π arrive le block',
                'defense': '<span class="highlight">D√©fense</span> ‚Äî S√©lectionnez le d√©fenseur',
                'defense_end': '<span class="highlight">D√©fense</span> ‚Äî Cliquez o√π arrive la d√©fense'
            };
            phaseEl.innerHTML = phases[gameState.phase] || '';
            
            // Afficher le bouton Changement pendant la s√©lection du serveur ou au d√©but du service
            const btnSub = document.getElementById('btnSubstitute');
            if (btnSub) {
                btnSub.style.display = (gameState.phase === 'server_selection' || gameState.phase === 'serve_start') ? 'flex' : 'none';
            }
            
            // Afficher le bouton Fin du Set pendant la s√©lection du serveur ou au d√©but du service
            const btnEnd = document.getElementById('btnEndSet');
            if (btnEnd) {
                btnEnd.style.display = (gameState.phase === 'server_selection' || gameState.phase === 'serve_start') ? 'flex' : 'none';
            }
        }

        // ==================== S√âLECTION SERVEUR ====================
        function renderServerSelection() {
            const container = document.getElementById('serverTags');
            const servingTeam = gameState.servingTeam;
            
            let players = [];
            if (servingTeam === 'home') {
                players = currentMatch.players || [];
            } else {
                players = (currentMatch.adversePlayers || []).map(name => ({ prenom: name }));
            }

            // Filtrer pour n'avoir que les 4 joueurs sur le terrain
            const lineup = servingTeam === 'home' 
                ? currentSet.homeLineup 
                : currentSet.awayLineup;
            
            const onCourtPlayers = Object.values(lineup).filter(p => p !== null);

            container.innerHTML = onCourtPlayers.map((playerName, idx) => `
                <button class="player-tag ${servingTeam}" onclick="selectServer('${playerName}')">
                    ${playerName}
                </button>
            `).join('');

            showSection('serverSelection');
        }

        function selectServer(playerName) {
            gameState.currentServer = playerName;
            gameState.currentAction = {
                type: 'service',
                player: playerName,
                team: gameState.servingTeam,
                role: getPlayerRole(gameState.servingTeam, playerName)
            };
            gameState.phase = 'serve_start';
            updatePhase();
            hideAllSections();
            highlightCourt(null);
            showServiceZone();
        }

        function showServerContinueBanner() {
            const banner = document.getElementById('serverContinue');
            const bannerInner = document.getElementById('serverContinueBanner');
            const nameSpan = document.getElementById('serverContinueName');
            
            nameSpan.textContent = gameState.currentServer;
            
            // Style selon l'√©quipe
            if (gameState.servingTeam === 'away') {
                bannerInner.classList.add('away');
            } else {
                bannerInner.classList.remove('away');
            }
            
            banner.classList.remove('hidden');
        }

        // ==================== GESTION DU TERRAIN ====================
        function setupCourtListeners() {
            const courtTop = document.getElementById('courtTop');
            const courtBottom = document.getElementById('courtBottom');
            const serviceZoneTop = document.getElementById('serviceZoneTop');
            const serviceZoneBottom = document.getElementById('serviceZoneBottom');
            const outArea = document.getElementById('outArea');

            courtTop.addEventListener('click', (e) => handleCourtClick(e, 'top'));
            courtBottom.addEventListener('click', (e) => handleCourtClick(e, 'bottom'));
            serviceZoneTop.addEventListener('click', (e) => handleServiceZoneClick(e, 'top'));
            serviceZoneBottom.addEventListener('click', (e) => handleServiceZoneClick(e, 'bottom'));
            outArea.addEventListener('click', (e) => handleOutAreaClick(e));
            
            // Zone filet cliquable
            const netClickZone = document.getElementById('netClickZone');
            netClickZone.addEventListener('click', (e) => {
                e.stopPropagation();
                handleNetZoneClick(e);
            });
            
            // Position zones click handlers (auto-select receiver)
            document.querySelectorAll('.position-zone').forEach(zone => {
                zone.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const player = e.currentTarget.dataset.player;
                    if (!player) return;
                    
                    if (gameState.phase === 'reception') {
                        // S√©lection manuelle: auto-s√©lection du r√©ceptionneur via zone
                        hidePositionZones();
                        selectReceptioner(player);
                    } else if (gameState.phase === 'serve_end') {
                        // Clic dans une zone pendant serve_end
                        const courtHalf = e.currentTarget.closest('.court-half');
                        const rect = courtHalf.getBoundingClientRect();
                        const x = ((e.clientX - rect.left) / rect.width) * 100;
                        const y = ((e.clientY - rect.top) / rect.height) * 100;
                        const courtSide = courtHalf.id === 'courtTop' ? 'top' : 'bottom';
                        const clickData = { x, y, courtSide };
                        
                        if (gameState.aceMode) {
                            // Mode Ace: traiter comme un clic terrain normal
                            handleServeEnd(clickData);
                            return;
                        }
                        
                        // NOUVEAU: auto-s√©lection directe du r√©ceptionneur
                        // Enregistrer le point d'arriv√©e du service
                        gameState.currentAction.endPos = clickData;
                        addMarker(clickData, 'service');
                        
                        // D√©sactiver les zones serve_end
                        document.getElementById('outArea').classList.remove('active');
                        document.getElementById('netClickZone').classList.remove('active');
                        hidePositionZones();
                        
                        // Pousser l'action de service dans le rally
                        gameState.rally.push({ ...gameState.currentAction });
                        
                        // Configurer la r√©ception auto-s√©lectionn√©e
                        const receivingTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
                        gameState.attackingTeam = receivingTeam;
                        gameState.receptionAutoSelected = true;
                        
                        // Auto-s√©lection du r√©ceptionneur (passe directement en reception_end)
                        selectReceptioner(player);
                    }
                });
            });
        }

        function handleOutAreaClick(event) {
            // Calculer la position relative au container
            const container = document.getElementById('courtContainer');
            const rect = container.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 100;
            const y = ((event.clientY - rect.top) / rect.height) * 100;
            
            // Marquer comme "out" (hors terrain)
            const clickData = { x, y, courtSide: 'out' };
            
            if (gameState.phase === 'serve_end') {
                handleServeEnd(clickData);
            } else if (gameState.phase === 'reception_end') {
                handleReceptionEnd(clickData);
            } else if (gameState.phase === 'pass_end') {
                handlePassEnd(clickData);
            } else if (gameState.phase === 'pass_fault_end') {
                handlePassFaultEnd(clickData);
            } else if (gameState.phase === 'attack_type') {
                // Clic OUT direct = smash out
                gameState.currentAction.attackType = 'smash';
                gameState.phase = 'attack_end';
                handleAttackEnd(clickData);
            } else if (gameState.phase === 'attack_end') {
                handleAttackEnd(clickData);
            } else if (gameState.phase === 'defense_end') {
                handleDefenseEnd(clickData);
            }
        }

        function handleServiceZoneClick(event, zoneSide) {
            if (gameState.phase !== 'serve_start') return;

            const rect = event.currentTarget.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 100;
            const y = ((event.clientY - rect.top) / rect.height) * 100;

            const clickData = { x, y, courtSide: zoneSide === 'top' ? 'service_top' : 'service_bottom' };
            handleServeStart(clickData);
        }

        function showServiceZone() {
            const serviceZoneTop = document.getElementById('serviceZoneTop');
            const serviceZoneBottom = document.getElementById('serviceZoneBottom');
            
            // Masquer les deux d'abord
            serviceZoneTop.classList.remove('active');
            serviceZoneBottom.classList.remove('active');

            // Afficher la bonne zone selon l'√©quipe qui sert
            const servingCourtSide = getCourtSideForTeam(gameState.servingTeam);
            
            if (servingCourtSide === 'top') {
                serviceZoneTop.classList.add('active');
            } else {
                serviceZoneBottom.classList.add('active');
            }
        }

        function hideServiceZones() {
            document.getElementById('serviceZoneTop').classList.remove('active');
            document.getElementById('serviceZoneBottom').classList.remove('active');
        }

        function handleCourtClick(event, courtSide) {
            const rect = event.currentTarget.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 100;
            const y = ((event.clientY - rect.top) / rect.height) * 100;

            const clickData = { x, y, courtSide };

            switch (gameState.phase) {
                case 'serve_start':
                    handleServeStart(clickData);
                    break;
                case 'serve_end':
                    handleServeEnd(clickData);
                    break;
                case 'reception_end':
                    handleReceptionEnd(clickData);
                    break;
                case 'direct_return_end':
                    handleDirectReturnEnd(clickData);
                    break;
                case 'pass_end':
                    handlePassEnd(clickData);
                    break;
                case 'pass_fault_end':
                    handlePassFaultEnd(clickData);
                    break;
                case 'attack_end':
                    handleAttackEnd(clickData);
                    break;
                case 'attack_type':
                    // Clic direct sur le terrain = smash par d√©faut
                    gameState.currentAction.attackType = 'smash';
                    gameState.phase = 'attack_end';
                    handleAttackEnd(clickData);
                    break;
                case 'block_end':
                    handleBlockEnd(clickData);
                    break;
                case 'defense_end':
                    handleDefenseEnd(clickData);
                    break;
            }
        }

        function handleServeStart(clickData) {
            gameState.currentAction.startPos = clickData;
            addMarker(clickData, 'service');
            gameState.phase = 'serve_end';
            updatePhase();
            
            // Masquer la zone de service
            hideServiceZones();
            
            // Activer la zone out pour permettre les clics hors terrain
            document.getElementById('outArea').classList.add('active');
            
            // Masquer le label OUT c√¥t√© serveur, afficher les autres
            const servingCourtSide = getCourtSideForTeam(gameState.servingTeam);
            document.getElementById('outLabelTop').style.display = servingCourtSide === 'top' ? 'none' : 'block';
            document.getElementById('outLabelBottom').style.display = servingCourtSide === 'bottom' ? 'none' : 'block';
            
            // Activer la zone filet cliquable
            document.getElementById('netClickZone').classList.add('active');
            
            // Highlight receiving team's court
            const receivingTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
            highlightCourt(receivingTeam);
            
            // Show position zones for auto-selection during serve landing
            showPositionZones(receivingTeam);
            
            // Show Ace button
            document.getElementById('serveAceSection').classList.remove('hidden');
        }

        function handleServeEnd(clickData) {
            gameState.currentAction.endPos = clickData;
            // On ne dessine pas de fl√®che ici, elle sera dessin√©e √† la r√©ception
            // On garde le marker pour montrer o√π le service est all√©
            addMarker(clickData, 'service');
            
            // D√©sactiver la zone out et la zone filet
            document.getElementById('outArea').classList.remove('active');
            document.getElementById('netClickZone').classList.remove('active');
            hidePositionZones();

            // V√©rifier si service faute (hors du terrain receveur)
            const receivingTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
            const expectedCourtSide = getCourtSideForTeam(receivingTeam);

            if (clickData.courtSide !== expectedCourtSide) {
                // Service faute out ! On dessine la fl√®che quand m√™me pour montrer l'erreur
                gameState.aceMode = false;
                drawArrow(gameState.currentAction.startPos, clickData, 'service');
                handleServiceFaultOut();
            } else if (gameState.aceMode) {
                // Mode Ace : le service atterrit IN, point direct
                gameState.aceMode = false;
                drawArrow(gameState.currentAction.startPos, clickData, 'service');
                gameState.currentAction.result = 'ace';
                gameState.rally.push({ ...gameState.currentAction });
                awardPoint(gameState.servingTeam);
                endRally();
            } else {
                // Service bon, passer √† la r√©ception (s√©lection manuelle)
                gameState.rally.push({ ...gameState.currentAction });
                gameState.attackingTeam = receivingTeam;
                gameState.receptionAutoSelected = false;
                gameState.phase = 'reception';
                updatePhase();
                showPositionZones(receivingTeam);
                renderPlayerSelection(receivingTeam, 'Qui r√©ceptionne ?');
            }
        }

        function handleServiceFault() {
            // Marquer le service comme fault (g√©n√©rique, utilis√© par bouton depuis reception)
            gameState.currentAction.result = 'fault';
            gameState.rally.push({ ...gameState.currentAction });
            
            // Point pour l'√©quipe qui re√ßoit
            const receivingTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
            awardPoint(receivingTeam);
            endRally();
        }

        function handleServiceFaultOut() {
            // Service out (hors terrain)
            gameState.currentAction.result = 'fault_out';
            gameState.rally.push({ ...gameState.currentAction });
            
            // Point pour l'√©quipe qui re√ßoit
            const receivingTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
            awardPoint(receivingTeam);
            endRally();
        }

        function handleNetZoneClick(event) {
            if (gameState.phase !== 'serve_end') return;
            
            // Capturer les coordonn√©es relatives au courtContainer
            const container = document.getElementById('courtContainer');
            const rect = container.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 100;
            const y = ((event.clientY - rect.top) / rect.height) * 100;
            
            const clickData = { x, y, courtSide: 'net' };
            
            // Sauvegarder la position d'arriv√©e (pour les stats/patterns)
            gameState.currentAction.endPos = clickData;
            addMarker(clickData, 'fault');
            
            // Tracer la fl√®che du service vers le filet
            if (gameState.currentAction.startPos) {
                drawArrow(gameState.currentAction.startPos, clickData, 'service');
            }
            
            // D√©sactiver zones
            document.getElementById('outArea').classList.remove('active');
            document.getElementById('netClickZone').classList.remove('active');
            hidePositionZones();
            
            gameState.currentAction.result = 'fault_net';
            gameState.rally.push({ ...gameState.currentAction });
            
            // Point pour l'√©quipe qui re√ßoit
            const receivingTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
            awardPoint(receivingTeam);
            endRally();
        }

        function activateAceMode() {
            gameState.aceMode = true;
            document.getElementById('serveAceSection').classList.add('hidden');
            hidePositionZones();
            // Update phase text
            document.getElementById('phaseText').innerHTML = '<span class="highlight">Ace !</span> ‚Äî Cliquez o√π le service atterrit';
        }

        function handleAceFromReception() {
            // Ace signal√© pendant la s√©lection du r√©ceptionneur
            hideAllSections();
            
            // Retrouver l'action de service et la marquer comme ace
            const serviceAction = gameState.rally.find(a => a.type === 'service');
            if (serviceAction) {
                serviceAction.result = 'ace';
            }
            
            // Tracer la fl√®che du service
            if (serviceAction && serviceAction.startPos && serviceAction.endPos) {
                drawArrow(serviceAction.startPos, serviceAction.endPos, 'service');
            }
            
            // Point pour l'√©quipe qui sert
            awardPoint(gameState.servingTeam);
            endRally();
        }

        // ==================== R√âCEPTION ====================
        function selectReceptioner(playerName) {
            gameState.currentAction = {
                type: 'reception',
                player: playerName,
                team: gameState.attackingTeam,
                role: getPlayerRole(gameState.attackingTeam, playerName)
            };
            gameState.phase = 'reception_end';
            updatePhase();
            hideAllSections();
            highlightCourt(gameState.attackingTeam);
            
            // Afficher les zones de qualit√© et le bouton faute
            showReceptionQualityZones();
            document.getElementById('receptionFaultSection').classList.remove('hidden');
            
            // Activer la zone out pour les r√©ceptions hors terrain
            document.getElementById('outArea').classList.add('active');
            // Masquer les labels OUT c√¥t√© adverse (on ne r√©ceptionne pas chez l'adversaire)
            const receivingCourtSide = getCourtSideForTeam(gameState.attackingTeam);
            document.getElementById('outLabelTop').style.display = receivingCourtSide === 'top' ? 'block' : 'none';
            document.getElementById('outLabelBottom').style.display = receivingCourtSide === 'bottom' ? 'block' : 'none';
        }

        function handleReceptionEnd(clickData) {
            gameState.currentAction.endPos = clickData;
            
            // D√©sactiver la zone out
            document.getElementById('outArea').classList.remove('active');
            
            // Calculer la qualit√© de la r√©ception selon la zone
            // Si c'est hors terrain, c'est automatiquement une r√©ception n√©gative (1/4)
            let quality;
            if (clickData.courtSide === 'out') {
                quality = { score: 1, label: 'N√©gative' };
            } else {
                quality = calculateReceptionQuality(clickData);
            }
            gameState.currentAction.quality = quality;
            
            addMarker(clickData, 'reception');
            
            // Masquer les zones de qualit√©
            hideReceptionQualityZones();
            document.getElementById('receptionFaultSection').classList.add('hidden');
            
            // Tracer fl√®che du SERVICE depuis son point de d√©part jusqu'au point de contact (endPos du service)
            const serviceAction = gameState.rally.find(a => a.type === 'service');
            if (serviceAction && serviceAction.startPos && serviceAction.endPos) {
                drawArrow(serviceAction.startPos, serviceAction.endPos, 'service');
                
                // Tracer fl√®che de R√âCEPTION depuis le point de contact jusqu'√† l'arriv√©e de la r√©ception
                drawArrow(serviceAction.endPos, clickData, 'reception');
            }

            gameState.rally.push({ ...gameState.currentAction });
            
            // Si r√©ception excellente (4/4), auto-s√©lectionner le passeur
            if (quality.score === 4) {
                const passeur = getPlayerByRole(gameState.attackingTeam, 'Passeur');
                if (passeur) {
                    gameState.passAutoSelected = true;
                    gameState.currentAction = {
                        type: 'pass',
                        player: passeur,
                        team: gameState.attackingTeam,
                        role: 'Passeur'
                    };
                    gameState.phase = 'pass_end';
                    updatePhase();
                    hideAllSections();
                    highlightCourt(gameState.attackingTeam);
                    document.getElementById('passFaultSection').classList.remove('hidden');
                    document.getElementById('outArea').classList.add('active');
                    const attackingCourtSide = getCourtSideForTeam(gameState.attackingTeam);
                    document.getElementById('outLabelTop').style.display = attackingCourtSide === 'top' ? 'block' : 'none';
                    document.getElementById('outLabelBottom').style.display = attackingCourtSide === 'bottom' ? 'block' : 'none';
                    return;
                }
            }
            
            gameState.passAutoSelected = false;
            gameState.phase = 'pass';
            updatePhase();
            renderPlayerSelection(gameState.attackingTeam, 'Qui fait la passe ?');
        }

        function calculateReceptionQuality(clickData) {
            // Calculer la distance par rapport au filet
            const courtSide = getCourtSideForTeam(gameState.attackingTeam);
            
            // Distance depuis le filet (en %)
            let distanceFromNet;
            if (courtSide === 'top') {
                // Terrain du haut : filet en bas (y=100%)
                distanceFromNet = 100 - clickData.y;
            } else {
                // Terrain du bas : filet en haut (y=0%)
                distanceFromNet = clickData.y;
            }
            
            // Distance horizontale depuis le centre (en %)
            const distX = Math.abs(clickData.x - 50);
            
            // Calcul bas√© sur la forme elliptique des demi-cercles
            // Zone parfaite: width 40%, height 30% ‚Üí ratio x/20, y/30
            // Zone correcte: width 70%, height 55% ‚Üí ratio x/35, y/55
            // Zone moyenne: width 100%, height 80% ‚Üí ratio x/50, y/80
            
            const perfectRatio = Math.sqrt(Math.pow(distX / 20, 2) + Math.pow(distanceFromNet / 30, 2));
            const goodRatio = Math.sqrt(Math.pow(distX / 35, 2) + Math.pow(distanceFromNet / 55, 2));
            const averageRatio = Math.sqrt(Math.pow(distX / 50, 2) + Math.pow(distanceFromNet / 80, 2));
            
            if (perfectRatio <= 1) {
                return { score: 4, label: 'Excellente' };
            } else if (goodRatio <= 1) {
                return { score: 3, label: 'Positive' };
            } else if (averageRatio <= 1) {
                return { score: 2, label: 'Jouable' };
            } else {
                return { score: 1, label: 'N√©gative' };
            }
        }

        function showReceptionQualityZones() {
            const courtSide = getCourtSideForTeam(gameState.attackingTeam);
            if (courtSide === 'top') {
                document.getElementById('qualityZonesTop').classList.add('active');
            } else {
                document.getElementById('qualityZonesBottom').classList.add('active');
            }
        }

        function hideReceptionQualityZones() {
            document.getElementById('qualityZonesTop').classList.remove('active');
            document.getElementById('qualityZonesBottom').classList.remove('active');
        }

        function handleReceptionFault() {
            // Faute de r√©ception = point pour l'√©quipe qui sert (ace)
            gameState.currentAction.quality = { score: 0, label: 'Faute' };
            gameState.currentAction.endPos = null;
            gameState.rally.push({ ...gameState.currentAction });
            
            // Marquer le service comme ace
            const serviceAction = gameState.rally.find(a => a.type === 'service');
            if (serviceAction) {
                serviceAction.result = 'ace';
            }
            
            // Masquer les zones
            hideReceptionQualityZones();
            document.getElementById('receptionFaultSection').classList.add('hidden');
            
            // Tracer fl√®che du service quand m√™me
            if (serviceAction && serviceAction.startPos && serviceAction.endPos) {
                drawArrow(serviceAction.startPos, serviceAction.endPos, 'service');
            }
            
            // Point pour l'√©quipe qui sert
            awardPoint(gameState.servingTeam);
            endRally();
        }

        function handleDirectReturn() {
            // Retour direct = la balle va dans le terrain adverse, ils doivent d√©fendre
            // Consid√©r√© comme une faute (0/4) car non ma√Ætris√©
            gameState.currentAction.quality = { score: 0, label: 'Faute' };
            gameState.currentAction.isDirectReturn = true;
            
            // Le point de contact de la r√©ception = l'arriv√©e du service
            const serviceAction = gameState.rally.find(a => a.type === 'service');
            if (serviceAction && serviceAction.endPos) {
                gameState.currentAction.endPos = serviceAction.endPos;
                // Ajouter un marker au point de contact
                addMarker(serviceAction.endPos, 'reception');
            }
            
            // Ne pas encore pusher dans rally, on attend le clic de l'arriv√©e
            
            // Masquer les zones
            hideReceptionQualityZones();
            document.getElementById('receptionFaultSection').classList.add('hidden');
            
            // Tracer fl√®che du service
            if (serviceAction && serviceAction.startPos && serviceAction.endPos) {
                drawArrow(serviceAction.startPos, serviceAction.endPos, 'service');
            }
            
            // L'√©quipe adverse (qui servait) doit maintenant d√©fendre
            const defendingTeam = gameState.servingTeam;
            
            // Mettre en surbrillance le terrain de l'√©quipe qui d√©fend (qui servait)
            highlightCourt(defendingTeam);
            
            // Phase pour cliquer l'arriv√©e du retour direct
            gameState.phase = 'direct_return_end';
            updatePhase();
            hideAllSections();
        }

        function handleDirectReturnEnd(clickData) {
            // Enregistrer l'arriv√©e du retour direct
            gameState.currentAction.directReturnEndPos = clickData;
            gameState.rally.push({ ...gameState.currentAction });
            
            // Tracer la fl√®che du retour direct (depuis r√©ception vers arriv√©e)
            const receptionStartPos = gameState.currentAction.endPos; // endPos de la r√©ception = point de contact
            if (receptionStartPos) {
                drawArrow(receptionStartPos, clickData, 'reception');
            }
            
            // Ajouter un marker pour l'arriv√©e
            addMarker(clickData, 'reception');
            
            // L'√©quipe adverse (qui servait) doit maintenant d√©fendre
            const defendingTeam = gameState.servingTeam;
            gameState.attackingTeam = defendingTeam;
            
            gameState.phase = 'defense';
            updatePhase();
            renderPlayerSelection(defendingTeam, 'Qui d√©fend ?');
        }

        function handleDirectReturnWinner() {
            // Retour direct gagnant = point direct pour l'√©quipe qui r√©ceptionne
            gameState.currentAction.quality = { score: 0, label: 'Retour gagnant' };
            gameState.currentAction.isDirectReturnWinner = true;
            gameState.rally.push({ ...gameState.currentAction });
            
            // Masquer les zones
            hideReceptionQualityZones();
            document.getElementById('receptionFaultSection').classList.add('hidden');
            
            // Tracer fl√®che du service
            const serviceAction = gameState.rally.find(a => a.type === 'service');
            if (serviceAction && serviceAction.startPos && serviceAction.endPos) {
                drawArrow(serviceAction.startPos, serviceAction.endPos, 'service');
            }
            
            // Point pour l'√©quipe qui r√©ceptionne (attackingTeam)
            awardPoint(gameState.attackingTeam);
            endRally();
        }

        // ==================== PASSE ====================
        function selectPasser(playerName) {
            gameState.passAutoSelected = false;
            gameState.currentAction = {
                type: 'pass',
                player: playerName,
                team: gameState.attackingTeam,
                role: getPlayerRole(gameState.attackingTeam, playerName)
            };
            gameState.phase = 'pass_end';
            updatePhase();
            hideAllSections();
            highlightCourt(gameState.attackingTeam);
            
            // Afficher le bouton faute de passe
            document.getElementById('passFaultSection').classList.remove('hidden');
            
            // Activer la zone out pour les passes hors terrain
            document.getElementById('outArea').classList.add('active');
            // Masquer les labels OUT c√¥t√© adverse (on ne passe pas chez l'adversaire)
            const attackingCourtSide = getCourtSideForTeam(gameState.attackingTeam);
            document.getElementById('outLabelTop').style.display = attackingCourtSide === 'top' ? 'block' : 'none';
            document.getElementById('outLabelBottom').style.display = attackingCourtSide === 'bottom' ? 'block' : 'none';
        }

        function handleSecondTouch(type) {
            // Attaque en 2√®me touche (deuxieme_main ou attaque_directe)
            // On sauvegarde le type et on demande qui fait l'action
            gameState.secondTouchType = type;
            gameState.phase = 'second_touch_player';
            updatePhase();
            hideAllSections();
            renderPlayerSelection(gameState.attackingTeam, 'Qui fait la 2√®me touche ?');
        }

        function handlePassFault() {
            // Le passeur est d√©j√† s√©lectionn√© dans currentAction (phase pass_end)
            gameState.currentAction.subType = 'fault';
            gameState.phase = 'pass_fault_end';
            updatePhase();
            hideAllSections();
            
            // Permettre de cliquer partout (les 2 terrains + out)
            document.getElementById('outArea').classList.add('active');
            document.getElementById('outLabelTop').style.display = 'block';
            document.getElementById('outLabelBottom').style.display = 'block';
            highlightCourt(null); // Les deux terrains actifs
        }

        function handlePassFaultEnd(clickData) {
            gameState.currentAction.endPos = clickData;
            addMarker(clickData, 'fault');
            
            // D√©sactiver la zone out
            document.getElementById('outArea').classList.remove('active');
            
            // Tracer fl√®che depuis la r√©ception/d√©fense pr√©c√©dente
            const lastAction = gameState.rally[gameState.rally.length - 1];
            if (lastAction && lastAction.endPos) {
                drawArrow(lastAction.endPos, clickData, 'fault');
            } else if (lastAction && lastAction.isDirectReturn && lastAction.directReturnEndPos) {
                drawArrow(lastAction.directReturnEndPos, clickData, 'fault');
            }
            
            // V√©rifier o√π la passe a atterri
            const defendingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
            const defendingCourtSide = getCourtSideForTeam(defendingTeam);
            
            if (clickData.courtSide === defendingCourtSide) {
                // Passe arriv√©e IN chez l'adversaire ‚Üí point direct ou d√©fense ?
                gameState.rally.push({ ...gameState.currentAction });
                gameState.phase = 'pass_fault_result';
                updatePhase();
                hideAllSections();
                showPassFaultResult();
            } else {
                // Passe arriv√©e sur son propre terrain ou OUT ‚Üí faute, point adversaire
                gameState.rally.push({ ...gameState.currentAction });
                const otherTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                awardPoint(otherTeam);
                endRally();
            }
        }

        function showPassFaultResult() {
            // Afficher les options : point direct ou d√©fendu
            const section = document.getElementById('passFaultResultSection');
            section.classList.remove('hidden');
        }

        function handlePassFaultResult(result) {
            document.getElementById('passFaultResultSection').classList.add('hidden');
            
            if (result === 'point') {
                // Point direct pour l'√©quipe qui a fait la passe (la balle est tomb√©e chez l'adversaire)
                awardPoint(gameState.attackingTeam);
                endRally();
            } else if (result === 'defense') {
                // L'adversaire d√©fend ‚Üí passer en mode d√©fense pour l'adversaire
                const defendingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                gameState.attackingTeam = defendingTeam;
                gameState.phase = 'defense';
                updatePhase();
                renderPlayerSelection(defendingTeam, 'Qui d√©fend ?');
            }
        }

        function selectSecondTouchPlayer(playerName) {
            // Cr√©er directement une action d'attaque avec le type pr√©-d√©fini
            gameState.currentAction = {
                type: 'attack',
                player: playerName,
                team: gameState.attackingTeam,
                attackType: gameState.secondTouchType,
                role: getPlayerRole(gameState.attackingTeam, playerName)
            };
            
            // Passer directement √† attack_end
            gameState.phase = 'attack_end';
            updatePhase();
            hideAllSections();
            
            // Highlight terrain adverse
            const defendingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
            highlightCourt(defendingTeam);
        }

        function handlePassEnd(clickData) {
            gameState.currentAction.endPos = clickData;
            addMarker(clickData, 'pass');
            
            // D√©sactiver la zone out
            document.getElementById('outArea').classList.remove('active');

            // Tracer fl√®che depuis la r√©ception ou d√©fense
            const lastAction = gameState.rally[gameState.rally.length - 1];
            if (lastAction && lastAction.endPos) {
                drawArrow(lastAction.endPos, clickData, 'pass');
            } else if (lastAction && lastAction.isDirectReturn && lastAction.directReturnEndPos) {
                // Cas apr√®s d√©fense sur retour direct
                drawArrow(lastAction.directReturnEndPos, clickData, 'pass');
            }

            gameState.rally.push({ ...gameState.currentAction });
            gameState.phase = 'attack_player';
            updatePhase();
            renderPlayerSelection(gameState.attackingTeam, 'Qui attaque ?');
        }

        // ==================== ATTAQUE ====================
        function selectAttacker(playerName) {
            gameState.currentAction = {
                type: 'attack',
                player: playerName,
                team: gameState.attackingTeam,
                role: getPlayerRole(gameState.attackingTeam, playerName)
            };
            
            // Si c'est une attaque directe depuis la d√©fense, marquer le type
            if (gameState.defenseDirectAttack) {
                gameState.currentAction.isDefenseDirectAttack = true;
                gameState.defenseDirectAttack = false; // Reset le flag
            }
            
            gameState.phase = 'attack_type';
            updatePhase();
            showSection('attackTypeSelection');
            
            // Activer le terrain adverse pour permettre un clic direct = smash
            const defendingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
            highlightCourt(defendingTeam);
            document.getElementById('outArea').classList.add('active');
            const defendingCourtSide = getCourtSideForTeam(defendingTeam);
            document.getElementById('outLabelTop').style.display = defendingCourtSide === 'top' ? 'none' : 'block';
            document.getElementById('outLabelBottom').style.display = defendingCourtSide === 'bottom' ? 'none' : 'block';
        }

        function selectAttackType(type) {
            gameState.currentAction.attackType = type;

            if (type === 'faute') {
                // Faute directe = point pour l'adversaire
                const otherTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                gameState.rally.push({ ...gameState.currentAction });
                awardPoint(otherTeam);
                endRally();
            } else if (type === 'bloc_direct') {
                // Bloc direct encaiss√© = point pour l'adversaire (diff√©rent de faute pour les stats)
                const otherTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                gameState.rally.push({ ...gameState.currentAction });
                awardPoint(otherTeam);
                endRally();
            } else {
                // Passer directement √† attack_end (le d√©part sera la position de la passe)
                gameState.phase = 'attack_end';
                updatePhase();
                hideAllSections();
                
                // Highlight terrain adverse pour l'arriv√©e de l'attaque
                const defendingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                highlightCourt(defendingTeam);
                document.getElementById('outArea').classList.add('active');
            }
        }

        function handleAttackEnd(clickData) {
            gameState.currentAction.endPos = clickData;
            
            // D√©terminer le type de marker/fl√®che selon le type d'attaque
            let arrowType = 'attack';
            if (gameState.currentAction.attackType === 'feinte') {
                arrowType = 'attack-feinte';
            } else if (gameState.currentAction.attackType === 'relance') {
                arrowType = 'attack-relance';
            } else if (gameState.currentAction.attackType === 'deuxieme_main' || gameState.currentAction.attackType === 'attaque_directe') {
                arrowType = 'attack-second';
            }
            
            addMarker(clickData, arrowType);
            
            // Tracer fl√®che depuis la passe (ou r√©ception/d√©fense si 2√®me touche, ou action pr√©c√©dente si attaque directe d√©fense)
            const lastAction = gameState.rally[gameState.rally.length - 1];
            
            if (gameState.currentAction.isDefenseDirectAttack) {
                // Attaque directe depuis la d√©fense: la fl√®che part de l'action pr√©c√©dente (attaque adverse, block, ou retour direct)
                if (lastAction && lastAction.type === 'reception' && lastAction.isDirectReturn && lastAction.directReturnEndPos) {
                    drawArrow(lastAction.directReturnEndPos, clickData, arrowType);
                } else if (lastAction && lastAction.type === 'defense' && lastAction.isDirectReturn && lastAction.directReturnEndPos) {
                    drawArrow(lastAction.directReturnEndPos, clickData, arrowType);
                } else if (lastAction && lastAction.endPos) {
                    drawArrow(lastAction.endPos, clickData, arrowType);
                }
            } else if (lastAction && lastAction.endPos) {
                drawArrow(lastAction.endPos, clickData, arrowType);
            }

            // V√©rifier si attaque faute (hors du terrain d√©fenseur)
            const defendingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
            const expectedCourtSide = getCourtSideForTeam(defendingTeam);

            if (clickData.courtSide !== expectedCourtSide) {
                // Attaque out = point pour l'adversaire
                gameState.currentAction.result = 'out';
                gameState.rally.push({ ...gameState.currentAction });
                awardPoint(defendingTeam);
                endRally();
            } else {
                // Attaque dans le terrain, demander le r√©sultat
                gameState.rally.push({ ...gameState.currentAction });
                gameState.phase = 'result';
                updatePhase();
                showSection('resultSelection');
            }
        }

        function selectResult(result) {
            const lastAction = gameState.rally[gameState.rally.length - 1];
            lastAction.result = result;

            if (result === 'point') {
                // Point pour l'√©quipe qui attaque
                awardPoint(gameState.attackingTeam);
                endRally();
            } else if (result === 'defended') {
                // D√©fendu : l'autre √©quipe d√©fend et va contre-attaquer
                const newAttackingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                gameState.attackingTeam = newAttackingTeam;
                gameState.phase = 'defense';
                updatePhase();
                renderPlayerSelection(newAttackingTeam, 'Qui d√©fend ?');
            } else if (result === 'blocked') {
                // Block√©e : on demande d'abord o√π arrive le block
                gameState.currentAction = {
                    type: 'block',
                    team: gameState.attackingTeam === 'home' ? 'away' : 'home' // L'√©quipe qui a bloqu√©
                };
                gameState.phase = 'block_end';
                updatePhase();
                hideAllSections();
                // Le block arrive sur le terrain de l'attaquant
                highlightCourt(gameState.attackingTeam);
            }
        }

        // ==================== BLOCK ====================
        function handleBlockEnd(clickData) {
            gameState.currentAction.endPos = clickData;
            addMarker(clickData, 'block');

            // Tracer fl√®che du block depuis l'arriv√©e de l'attaque jusqu'√† l'arriv√©e du block
            const lastAttack = [...gameState.rally].reverse().find(a => a.type === 'attack');
            if (lastAttack && lastAttack.endPos) {
                drawArrow(lastAttack.endPos, clickData, 'block');
            }

            gameState.rally.push({ ...gameState.currentAction });

            // Passer √† la d√©fense (m√™me √©quipe que l'attaquant)
            gameState.phase = 'defense';
            updatePhase();
            renderPlayerSelection(gameState.attackingTeam, 'Qui d√©fend ?');
        }

        // ==================== D√âFENSE ====================
        function selectDefender(playerName) {
            gameState.currentAction = {
                type: 'defense',
                player: playerName,
                team: gameState.attackingTeam,
                role: getPlayerRole(gameState.attackingTeam, playerName)
            };
            gameState.phase = 'defense_end';
            updatePhase();
            hideAllSections();
            
            // Permettre de cliquer sur les deux terrains (d√©fense peut aller chez l'adversaire)
            highlightCourt(null); // Pas de highlight sp√©cifique, les deux terrains sont cliquables
            
            // Activer la zone out pour les d√©fenses hors terrain
            document.getElementById('outArea').classList.add('active');
            // Afficher tous les labels OUT sauf celui c√¥t√© adverse (la balle peut y aller mais pas en out)
            const defendingCourtSide = getCourtSideForTeam(gameState.attackingTeam);
            document.getElementById('outLabelTop').style.display = defendingCourtSide === 'top' ? 'block' : 'none';
            document.getElementById('outLabelBottom').style.display = defendingCourtSide === 'bottom' ? 'block' : 'none';
        }

        function handleDefenseEnd(clickData) {
            // D√©sactiver la zone out
            document.getElementById('outArea').classList.remove('active');
            
            // V√©rifier si la d√©fense va dans le terrain adverse
            const defendingTeam = gameState.attackingTeam;
            const defendingCourtSide = getCourtSideForTeam(defendingTeam);
            const oppositeCourtSide = defendingCourtSide === 'top' ? 'bottom' : 'top';
            
            // Si le clic est sur le terrain adverse, c'est un retour direct de d√©fense
            if (clickData.courtSide === oppositeCourtSide) {
                handleDefenseDirectReturn(clickData);
                return;
            }
            
            gameState.currentAction.endPos = clickData;
            addMarker(clickData, 'defense');

            // Tracer fl√®che depuis l'action pr√©c√©dente
            const prevAction = gameState.rally[gameState.rally.length - 1];
            
            if (prevAction && prevAction.type === 'reception' && prevAction.isDirectReturn && prevAction.directReturnEndPos) {
                // Cas du retour direct : la fl√®che part du point d'arriv√©e du retour direct
                drawArrow(prevAction.directReturnEndPos, clickData, 'defense');
            } else if (prevAction && prevAction.type === 'defense' && prevAction.isDirectReturn && prevAction.directReturnEndPos) {
                // Cas du retour direct de d√©fense pr√©c√©dente
                drawArrow(prevAction.directReturnEndPos, clickData, 'defense');
            } else if (prevAction && prevAction.endPos) {
                if (prevAction.type === 'block') {
                    drawArrow(prevAction.endPos, clickData, 'defense');
                } else if (prevAction.type === 'attack') {
                    drawArrow(prevAction.endPos, clickData, 'defense');
                }
            }

            gameState.rally.push({ ...gameState.currentAction });
            
            // Passer √† la passe
            gameState.phase = 'pass';
            updatePhase();
            renderPlayerSelection(gameState.attackingTeam, 'Qui fait la passe ?');
        }

        function handleDefenseDirectReturn(clickData) {
            // La d√©fense va directement dans le terrain adverse
            gameState.currentAction.isDirectReturn = true;
            gameState.currentAction.directReturnEndPos = clickData;
            
            // Trouver le point de d√©part de la d√©fense (depuis l'action pr√©c√©dente)
            const prevAction = gameState.rally[gameState.rally.length - 1];
            let defenseStartPos = null;
            
            if (prevAction && prevAction.type === 'reception' && prevAction.isDirectReturn && prevAction.directReturnEndPos) {
                defenseStartPos = prevAction.directReturnEndPos;
            } else if (prevAction && prevAction.type === 'defense' && prevAction.isDirectReturn && prevAction.directReturnEndPos) {
                defenseStartPos = prevAction.directReturnEndPos;
            } else if (prevAction && prevAction.endPos) {
                defenseStartPos = prevAction.endPos;
            }
            
            gameState.currentAction.endPos = defenseStartPos; // Le point de contact de la d√©fense
            
            // Ajouter markers
            if (defenseStartPos) {
                addMarker(defenseStartPos, 'defense');
            }
            addMarker(clickData, 'defense');
            
            // Tracer la fl√®che de la d√©fense vers le terrain adverse
            if (defenseStartPos) {
                drawArrow(defenseStartPos, clickData, 'defense');
            }
            
            gameState.rally.push({ ...gameState.currentAction });
            
            // L'√©quipe adverse doit maintenant d√©fendre
            const newDefendingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
            gameState.attackingTeam = newDefendingTeam;
            
            // Mettre en surbrillance le terrain de l'√©quipe qui va d√©fendre
            highlightCourt(newDefendingTeam);
            
            gameState.phase = 'defense';
            updatePhase();
            renderPlayerSelection(newDefendingTeam, 'Qui d√©fend ?');
        }

        function handleDefenseDirectAttack() {
            // Attaque directe depuis la d√©fense (sans passe)
            // On passe directement √† la s√©lection de l'attaquant
            gameState.defenseDirectAttack = true; // Flag pour savoir qu'on vient de la d√©fense
            gameState.phase = 'attack_player';
            updatePhase();
            hideAllSections();
            renderPlayerSelection(gameState.attackingTeam, 'Qui attaque ?');
        }

        // ==================== GESTION DES POINTS ====================
        function awardPoint(team) {
            if (team === 'home') {
                gameState.homeScore++;
            } else {
                gameState.awayScore++;
            }
            updateScore();

            // Changement de service si l'√©quipe qui re√ßoit gagne le point
            if (team !== gameState.servingTeam) {
                gameState.servingTeam = team;
                gameState.currentServer = null; // Nouveau serveur √† choisir
            }
            // Si team === servingTeam, currentServer reste (m√™me serveur continue)

            // Sauvegarder
            saveCurrentSet();

            // V√©rifier fin de set (met le flag setEnded si c'est fini)
            gameState.setEnded = false;
            checkSetEnd();
        }

        function checkSetEnd() {
            const home = gameState.homeScore;
            const away = gameState.awayScore;

            // Set gagn√© √† 25 avec 2 points d'√©cart
            if ((home >= 25 || away >= 25) && Math.abs(home - away) >= 2) {
                gameState.setEnded = true;
                openEndSetModal('auto');
            }
        }

        // ==================== FIN DU SET ====================
        let endSetState = {
            mode: null,     // 'auto', 'manual'
            reason: null,   // null, 'camera', 'time'
        };

        function openEndSetModal(mode) {
            endSetState.mode = mode;
            endSetState.reason = null;

            const opponent = currentMatch.opponent || 'Adversaire';
            const home = gameState.homeScore;
            const away = gameState.awayScore;

            // Mettre √† jour les noms
            document.getElementById('endSetAwayName').textContent = opponent;
            document.getElementById('realScoreAwayLabel').textContent = opponent;

            // Score
            const homeEl = document.getElementById('endSetHomeScore');
            const awayEl = document.getElementById('endSetAwayScore');
            homeEl.textContent = home;
            awayEl.textContent = away;

            // Reset des classes winner/loser
            homeEl.classList.remove('winner', 'loser');
            awayEl.classList.remove('winner', 'loser');

            if (mode === 'auto') {
                // Fin automatique ‚Äî on sait qui a gagn√©
                const winner = home > away ? 'home' : 'away';
                const winnerName = winner === 'home' ? 'Jen et ses Saints' : opponent;
                
                homeEl.classList.add(home > away ? 'winner' : 'loser');
                awayEl.classList.add(away > home ? 'winner' : 'loser');

                document.getElementById('endSetIcon').textContent = 'üèÜ';
                document.getElementById('endSetTitle').textContent = 'Fin du Set !';
                document.getElementById('endSetSubtitle').textContent = `Set ${setIndex + 1} termin√© ‚Äî 25 points atteints`;
                document.getElementById('endSetWinner').textContent = `üéâ ${winnerName} remporte le set`;
                document.getElementById('endSetWinner').style.display = 'block';
                document.getElementById('endSetReasons').style.display = 'none';
                document.getElementById('endSetRealScore').classList.remove('visible');
                document.getElementById('endSetCancelBtn').style.display = 'none';
                document.getElementById('endSetBackBtn').style.display = 'block';
                document.getElementById('endSetConfirmBtn').textContent = 'Set suivant ‚Üí';
                document.getElementById('endSetConfirmBtn').disabled = false;
            } else {
                // Mode manuel
                document.getElementById('endSetIcon').textContent = 'üèÅ';
                document.getElementById('endSetTitle').textContent = 'Terminer le set ?';
                document.getElementById('endSetSubtitle').textContent = `Set ${setIndex + 1} ‚Äî Score actuel`;
                document.getElementById('endSetWinner').style.display = 'none';
                document.getElementById('endSetReasons').style.display = 'flex';
                document.getElementById('endSetRealScore').classList.remove('visible');
                document.getElementById('endSetCancelBtn').style.display = 'block';
                document.getElementById('endSetBackBtn').style.display = 'none';
                document.getElementById('endSetConfirmBtn').textContent = 'Terminer le set';
                document.getElementById('endSetConfirmBtn').disabled = true; // Attendre le choix de raison

                // Reset les boutons raison
                document.querySelectorAll('.end-set-reason-btn').forEach(b => b.classList.remove('selected'));
            }

            // Stats recap
            buildEndSetStatsRecap();

            // Pr√©-remplir score r√©el avec score actuel
            document.getElementById('realScoreHome').value = home;
            document.getElementById('realScoreAway').value = away;

            document.getElementById('endSetOverlay').classList.add('active');
        }

        function selectEndReason(reason) {
            endSetState.reason = reason;

            // Highlight du bouton
            document.querySelectorAll('.end-set-reason-btn').forEach(b => b.classList.remove('selected'));
            event.currentTarget.classList.add('selected');

            if (reason === 'camera') {
                document.getElementById('endSetRealScore').classList.add('visible');
                document.getElementById('endSetConfirmBtn').textContent = 'Terminer avec score r√©el';
            } else {
                document.getElementById('endSetRealScore').classList.remove('visible');
                document.getElementById('endSetConfirmBtn').textContent = 'Terminer sur le score actuel';
            }

            document.getElementById('endSetConfirmBtn').disabled = false;
        }

        function closeEndSetModal() {
            document.getElementById('endSetOverlay').classList.remove('active');
        }

        function returnToGameForCorrection() {
            // Fermer la modal
            closeEndSetModal();
            
            // R√©initialiser le flag de fin de set
            gameState.setEnded = false;
            
            // Retour √† la s√©lection du serveur pour pouvoir utiliser "Annuler point"
            gameState.rally = [];
            gameState.currentAction = {};
            gameState.currentServer = null;
            
            clearMarkers();
            clearArrows();
            hideServiceZones();
            hideReceptionQualityZones();
            highlightCourt(null);
            
            gameState.phase = 'server_selection';
            updatePhase();
            renderServerSelection();
        }

        function buildEndSetStatsRecap() {
            const points = currentSet.points || [];
            const totalPoints = points.length;
            
            if (totalPoints === 0) {
                document.getElementById('endSetStatsRecap').innerHTML = 'Aucun point enregistr√© dans ce set.';
                return;
            }

            // Compter les aces et fautes de service
            let aces = 0, faultesServ = 0;
            for (const pt of points) {
                for (const action of pt.rally) {
                    if (action.type === 'service' && action.result === 'ace') aces++;
                    if (action.type === 'service' && (action.result === 'fault' || action.result === 'fault_out' || action.result === 'fault_net')) faultesServ++;
                }
            }

            document.getElementById('endSetStatsRecap').innerHTML = `
                <span class="stat-highlight">${totalPoints}</span> points jou√©s
                ${aces > 0 ? ` ‚Ä¢ <span class="stat-highlight">${aces}</span> ace${aces > 1 ? 's' : ''}` : ''}
                ${faultesServ > 0 ? ` ‚Ä¢ <span class="stat-highlight">${faultesServ}</span> faute${faultesServ > 1 ? 's' : ''} au service` : ''}
            `;
        }

        function confirmEndSet() {
            let finalHome = gameState.homeScore;
            let finalAway = gameState.awayScore;
            let endReason = 'auto';

            if (endSetState.mode === 'manual') {
                if (!endSetState.reason) return;
                endReason = endSetState.reason;

                if (endSetState.reason === 'camera') {
                    finalHome = parseInt(document.getElementById('realScoreHome').value) || 0;
                    finalAway = parseInt(document.getElementById('realScoreAway').value) || 0;
                    
                    // Validation basique
                    if (finalHome === finalAway) {
                        alert('Le score ne peut pas √™tre √† √©galit√© en fin de set.');
                        return;
                    }
                }
                // Pour 'time', on garde le score actuel
                if (endSetState.reason === 'time' && finalHome === finalAway) {
                    alert('Le score est √† √©galit√©. Jouez au moins un point suppl√©mentaire ou utilisez "Probl√®me cam√©ra" pour saisir un score diff√©rent.');
                    return;
                }
            }

            // Sauvegarder le r√©sultat du set
            currentSet.finalHomeScore = finalHome;
            currentSet.finalAwayScore = finalAway;
            currentSet.endReason = endReason;
            currentSet.completed = true;
            currentSet.winner = finalHome > finalAway ? 'home' : 'away';
            currentSet.statsHomeScore = gameState.homeScore;
            currentSet.statsAwayScore = gameState.awayScore;

            // D√©terminer le prochain serveur (alternance entre sets)
            // Le premier serveur du set change √† chaque set
            const firstServerThisSet = currentSet.firstServingTeam || currentSet.servingTeam;
            const nextServingTeam = firstServerThisSet === 'home' ? 'away' : 'home';

            // Sauvegarder qui a servi en premier dans ce set
            if (!currentSet.firstServingTeam) {
                currentSet.firstServingTeam = currentSet.servingTeam;
            }

            // Changement de c√¥t√© terrain (la cam√©ra reste fixe)
            const currentCameraSide = currentSet.cameraSide || 'home';
            const nextCameraSide = currentCameraSide === 'home' ? 'away' : 'home';

            // Pr√©parer le squelette du set suivant
            const nextSetNumber = (currentSet.setNumber || 1) + 1;
            const nextSet = {
                setNumber: nextSetNumber,
                homeLineup: { ...currentSet.homeLineup },  // Copier la composition
                awayLineup: { ...currentSet.awayLineup },
                homeScore: 0,
                awayScore: 0,
                points: [],
                cameraSide: nextCameraSide,
                servingTeam: nextServingTeam,
                firstServingTeam: nextServingTeam,
                previousSetReady: true  // Flag pour que la composition sache qu'on vient d'un set termin√©
            };

            // Ajouter le set suivant au match
            currentMatch.sets.push(nextSet);

            // Sauvegarder
            currentMatch.sets[setIndex] = currentSet;
            localStorage.setItem('volleyball_current_match', JSON.stringify(currentMatch));

            // Fermer la modal
            closeEndSetModal();

            // Aller √† la composition du set suivant
            window.location.href = 'match-set-composition.html';
        }

        function endRally() {
            // Sauvegarder le rally
            if (!currentSet.points) currentSet.points = [];
            currentSet.points.push({
                rally: [...gameState.rally],
                homeScore: gameState.homeScore,
                awayScore: gameState.awayScore,
                servingTeam: gameState.rally[0]?.team || gameState.servingTeam,
                server: gameState.rally[0]?.player || null,
                timestamp: Date.now()
            });

            // Mettre √† jour les statistiques
            recalculateAllStats();

            // Si le set est termin√©, ne pas pr√©parer le prochain point
            if (gameState.setEnded) {
                gameState.rally = [];
                gameState.currentAction = {};
                clearMarkers();
                clearArrows();
                return;
            }

            // Reset pour le prochain point
            gameState.rally = [];
            gameState.currentAction = {};
            clearMarkers();
            clearArrows();
            hideServiceZones();
            hideReceptionQualityZones();

            if (gameState.currentServer) {
                // M√™me serveur continue ‚Äî skip la s√©lection
                gameState.phase = 'serve_start';
                gameState.currentAction = {
                    type: 'service',
                    player: gameState.currentServer,
                    team: gameState.servingTeam
                };
                updatePhase();
                hideAllSections();
                showServerContinueBanner();
                highlightCourt(null);
                showServiceZone();
            } else {
                // Nouveau serveur √† choisir
                gameState.phase = 'server_selection';
                updatePhase();
                renderServerSelection();
            }
        }

        function recalculateAllStats() {
            // R√©initialiser les stats
            initSetStats();
            
            // Parcourir tous les points enregistr√©s
            if (currentSet.points) {
                for (const point of currentSet.points) {
                    for (const action of point.rally) {
                        updateStatFromAction(action);
                    }
                }
            }
            
            renderStatsTables();
        }

        function updateStatFromAction(action) {
            const team = action.team;
            const player = action.player;
            
            if (!player || !team) return;
            
            // S'assurer que le joueur existe dans les stats
            if (!setStats[team][player]) {
                setStats[team][player] = initPlayerStats(player);
            }
            
            const stats = setStats[team][player];
            
            switch (action.type) {
                case 'service':
                    stats.service.tot++;
                    if (action.result === 'ace') {
                        stats.service.ace++;
                    } else if (action.result === 'fault' || action.result === 'fault_out' || action.result === 'fault_net') {
                        stats.service.fs++;
                    }
                    break;
                    
                case 'reception':
                    stats.reception.tot++;
                    if (action.quality) {
                        switch (action.quality.label) {
                            case 'Excellente':
                                stats.reception.positive++;
                                break;
                            case 'Positive':
                                stats.reception.positive++;
                                break;
                            case 'Jouable':
                                stats.reception.jouable++;
                                break;
                            case 'N√©gative':
                                stats.reception.negative++;
                                break;
                            case 'Faute':
                                stats.reception.faute++;
                                break;
                            case 'Retour gagnant':
                                // Retour gagnant n'est pas une faute
                                break;
                        }
                    }
                    break;
                    
                case 'attack':
                    stats.attack.tot++;
                    if (action.attackType === 'faute') {
                        stats.attack.fd++;
                        stats.attack.minus++;
                    } else if (action.attackType === 'bloc_direct') {
                        stats.attack.bl++;
                        stats.attack.minus++;
                    } else if (action.result === 'point') {
                        stats.attack.plus++;
                    } else if (action.result === 'out') {
                        stats.attack.fd++;
                        stats.attack.minus++;
                    } else if (action.result === 'blocked') {
                        stats.attack.bl++;
                        stats.attack.minus++;
                    }
                    // defended = ni plus ni minus
                    break;
                    
                case 'block':
                    // Block r√©ussi (le block a √©t√© enregistr√© donc il a perturb√© l'attaque)
                    stats.block.bl++;
                    break;
            }
        }

        // ==================== HELPERS ====================
        // ==================== POSITION ROLES ====================
        const POSITION_ROLES = {
            home: { 1: 'Passeur', 2: 'R4', 3: 'Centre', 4: 'Pointu' },
            away: { 4: 'Passeur', 1: 'R4', 2: 'Centre', 3: 'Pointu' }
        };

        const ROLE_COLORS = {
            'R4': '#3b82f6',
            'Centre': '#ef4444',
            'Pointu': '#22c55e'
        };

        function getPlayerByRole(team, role) {
            const lineup = team === 'home' ? currentSet.homeLineup : currentSet.awayLineup;
            const roles = POSITION_ROLES[team];
            for (const [pos, r] of Object.entries(roles)) {
                if (r === role) return lineup[pos];
            }
            return null;
        }

        function getPlayerRole(team, playerName) {
            const lineup = team === 'home' ? currentSet.homeLineup : currentSet.awayLineup;
            const roles = POSITION_ROLES[team];
            for (const [pos, name] of Object.entries(lineup)) {
                if (name === playerName) return roles[pos] || null;
            }
            return null;
        }

        function showPositionZones(team) {
            const courtSide = getCourtSideForTeam(team);
            const zonesId = courtSide === 'top' ? 'positionZonesTop' : 'positionZonesBottom';
            const zones = document.getElementById(zonesId);
            
            const lineup = team === 'home' ? currentSet.homeLineup : currentSet.awayLineup;
            
            // Position numbers for back row roles
            let r4Pos, centrePos, pointuPos;
            if (team === 'home') {
                r4Pos = 2; centrePos = 3; pointuPos = 4;
            } else {
                r4Pos = 1; centrePos = 2; pointuPos = 3;
            }
            
            // Map viewer-left/center/right based on court side
            // Bottom court: R4 √† gauche, Centre au milieu, Pointu √† droite (comme composition home)
            // Top court: miroir (Pointu √† gauche, Centre au milieu, R4 √† droite)
            let mapping;
            if (courtSide === 'bottom') {
                mapping = [
                    { player: lineup[r4Pos], role: 'R4', color: ROLE_COLORS['R4'] },
                    { player: lineup[centrePos], role: 'Centre', color: ROLE_COLORS['Centre'] },
                    { player: lineup[pointuPos], role: 'Pointu', color: ROLE_COLORS['Pointu'] }
                ];
            } else {
                // Top court: mirrored left-right
                mapping = [
                    { player: lineup[pointuPos], role: 'Pointu', color: ROLE_COLORS['Pointu'] },
                    { player: lineup[centrePos], role: 'Centre', color: ROLE_COLORS['Centre'] },
                    { player: lineup[r4Pos], role: 'R4', color: ROLE_COLORS['R4'] }
                ];
            }
            
            const zoneElements = zones.querySelectorAll('.position-zone');
            mapping.forEach((m, i) => {
                zoneElements[i].style.background = m.color + '40';
                zoneElements[i].style.borderColor = m.color + '80';
                zoneElements[i].innerHTML = `<span class="zone-label">${m.role}<br>${m.player}</span>`;
                zoneElements[i].dataset.player = m.player;
                zoneElements[i].dataset.role = m.role;
            });
            
            zones.classList.add('active');
        }

        function hidePositionZones() {
            document.getElementById('positionZonesTop').classList.remove('active');
            document.getElementById('positionZonesBottom').classList.remove('active');
        }

        function getCourtSideForTeam(team) {
            // Retourne 'top' ou 'bottom' selon le c√¥t√© cam√©ra
            if (cameraSide === 'home') {
                return team === 'home' ? 'bottom' : 'top';
            } else {
                return team === 'home' ? 'top' : 'bottom';
            }
        }

        function renderPlayerSelection(team, title) {
            const container = document.getElementById('playerTags');
            document.getElementById('playerSelectionTitle').textContent = title;

            const lineup = team === 'home' ? currentSet.homeLineup : currentSet.awayLineup;
            const players = Object.values(lineup).filter(p => p !== null);

            let html = players.map(playerName => `
                <button class="player-tag ${team}" onclick="handlePlayerSelection('${playerName}')">
                    ${playerName}
                </button>
            `).join('');
            
            // Ajouter le bouton Ace en phase reception
            if (gameState.phase === 'reception') {
                html += `<button class="action-tag ace" onclick="handleAceFromReception()">üéØ Ace</button>`;
            }
            
            // Ajouter le bouton Attaque directe en phase defense
            if (gameState.phase === 'defense') {
                html += `<button class="action-tag direct-return" onclick="handleDefenseDirectAttack()">‚ö° Attaque directe</button>`;
            }
            
            container.innerHTML = html;

            showSection('playerSelection');
            
            // Afficher les options de 2√®me touche uniquement en phase passe (s√©lection du passeur)
            if (gameState.phase === 'pass') {
                document.getElementById('secondTouchOptions').classList.remove('hidden');
            }
        }

        function handlePlayerSelection(playerName) {
            switch (gameState.phase) {
                case 'reception':
                    selectReceptioner(playerName);
                    break;
                case 'pass':
                    selectPasser(playerName);
                    break;
                case 'second_touch_player':
                    selectSecondTouchPlayer(playerName);
                    break;
                case 'attack_player':
                    selectAttacker(playerName);
                    break;
                case 'defense':
                    selectDefender(playerName);
                    break;
            }
        }

        function showSection(sectionId) {
            hideAllSections();
            document.getElementById(sectionId).classList.remove('hidden');
        }

        function hideAllSections() {
            document.getElementById('serverSelection').classList.add('hidden');
            document.getElementById('serverContinue').classList.add('hidden');
            document.getElementById('playerSelection').classList.add('hidden');
            document.getElementById('secondTouchOptions').classList.add('hidden');
            document.getElementById('passFaultSection').classList.add('hidden');
            document.getElementById('passFaultResultSection').classList.add('hidden');
            document.getElementById('netClickZone').classList.remove('active');
            document.getElementById('attackTypeSelection').classList.add('hidden');
            document.getElementById('resultSelection').classList.add('hidden');
            document.getElementById('receptionFaultSection').classList.add('hidden');
            document.getElementById('serveAceSection').classList.add('hidden');
            document.getElementById('outArea').classList.remove('active');
            hideReceptionQualityZones();
            hidePositionZones();
        }

        function highlightCourt(team) {
            const courtTop = document.getElementById('courtTop');
            const courtBottom = document.getElementById('courtBottom');

            courtTop.classList.remove('target', 'inactive');
            courtBottom.classList.remove('target', 'inactive');

            if (team === null) {
                // Pas de highlight
                return;
            }

            const targetSide = getCourtSideForTeam(team);

            if (targetSide === 'top') {
                courtTop.classList.add('target');
                courtBottom.classList.add('inactive');
            } else {
                courtBottom.classList.add('target');
                courtTop.classList.add('inactive');
            }
        }

        function addMarker(pos, actionType) {
            const courtContainer = document.getElementById('courtContainer');
            const courtTop = document.getElementById('courtTop');
            const courtBottom = document.getElementById('courtBottom');
            const serviceZoneTop = document.getElementById('serviceZoneTop');
            const serviceZoneBottom = document.getElementById('serviceZoneBottom');

            const marker = document.createElement('div');
            marker.className = `click-marker ${actionType}`;

            // Calculer la position absolue dans le courtContainer
            const containerRect = courtContainer.getBoundingClientRect();
            
            // Cas sp√©cial : clic en dehors du terrain (out)
            if (pos.courtSide === 'out') {
                const left = (pos.x / 100) * containerRect.width;
                const top = (pos.y / 100) * containerRect.height;
                
                marker.style.left = `${left}px`;
                marker.style.top = `${top}px`;
                courtContainer.appendChild(marker);
                return;
            }
            
            let targetElement;
            
            if (pos.courtSide === 'service_top') {
                targetElement = serviceZoneTop;
            } else if (pos.courtSide === 'service_bottom') {
                targetElement = serviceZoneBottom;
            } else if (pos.courtSide === 'top') {
                targetElement = courtTop;
            } else {
                targetElement = courtBottom;
            }
            
            const targetRect = targetElement.getBoundingClientRect();
            const offsetTop = targetRect.top - containerRect.top;
            const offsetLeft = targetRect.left - containerRect.left;
            const left = (pos.x / 100) * targetRect.width + offsetLeft;
            const top = (pos.y / 100) * targetRect.height + offsetTop;

            marker.style.left = `${left}px`;
            marker.style.top = `${top}px`;

            courtContainer.appendChild(marker);
        }

        function drawArrow(from, to, actionType) {
            const svg = document.getElementById('arrowSvg');
            const courtContainer = document.getElementById('courtContainer');
            const courtTop = document.getElementById('courtTop');
            const courtBottom = document.getElementById('courtBottom');
            const serviceZoneTop = document.getElementById('serviceZoneTop');
            const serviceZoneBottom = document.getElementById('serviceZoneBottom');
            const containerRect = courtContainer.getBoundingClientRect();
            
            // D√©calage du SVG (il est positionn√© √† -50px, -50px)
            const svgOffset = 50;

            // Calculer les positions
            function getAbsolutePos(pos) {
                // Cas sp√©cial : position out (en dehors du terrain)
                if (pos.courtSide === 'out') {
                    const left = (pos.x / 100) * containerRect.width + svgOffset;
                    const top = (pos.y / 100) * containerRect.height + svgOffset;
                    return { x: left, y: top };
                }
                
                let targetElement;
                
                if (pos.courtSide === 'service_top') {
                    targetElement = serviceZoneTop;
                } else if (pos.courtSide === 'service_bottom') {
                    targetElement = serviceZoneBottom;
                } else if (pos.courtSide === 'top') {
                    targetElement = courtTop;
                } else {
                    targetElement = courtBottom;
                }
                
                const targetRect = targetElement.getBoundingClientRect();
                const offsetTop = targetRect.top - containerRect.top + svgOffset;
                const offsetLeft = targetRect.left - containerRect.left + svgOffset;
                const left = (pos.x / 100) * targetRect.width + offsetLeft;
                const top = (pos.y / 100) * targetRect.height + offsetTop;
                return { x: left, y: top };
            }

            const startPos = getAbsolutePos(from);
            const endPos = getAbsolutePos(to);

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('class', `arrow-line ${actionType}`);
            line.setAttribute('x1', startPos.x);
            line.setAttribute('y1', startPos.y);
            line.setAttribute('x2', endPos.x);
            line.setAttribute('y2', endPos.y);
            line.setAttribute('marker-end', `url(#arrowhead-${actionType})`);

            svg.appendChild(line);
        }

        function clearMarkers() {
            document.querySelectorAll('.click-marker').forEach(m => m.remove());
        }

        function clearArrows() {
            const svg = document.getElementById('arrowSvg');
            svg.querySelectorAll('line').forEach(l => l.remove());
        }

        function undoLastAction() {
            // Si on est √† la s√©lection du serveur, rien √† annuler
            if (gameState.phase === 'server_selection') {
                return;
            }

            // Effacer les markers et fl√®ches
            clearMarkers();
            clearArrows();

            // D√©terminer l'√©tat pr√©c√©dent selon la phase actuelle
            switch (gameState.phase) {
                case 'serve_start':
                    // Retour √† la s√©lection du serveur
                    gameState.phase = 'server_selection';
                    gameState.currentAction = {};
                    hideServiceZones();
                    renderServerSelection();
                    break;

                case 'serve_end':
                    if (gameState.aceMode) {
                        // Just deactivate ace mode, stay in serve_end
                        gameState.aceMode = false;
                        const aceRecvTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
                        showPositionZones(aceRecvTeam);
                        document.getElementById('serveAceSection').classList.remove('hidden');
                        updatePhase();
                        // Redraw start marker
                        if (gameState.currentAction.startPos) {
                            addMarker(gameState.currentAction.startPos, 'service');
                        }
                        break;
                    }
                    // Retour au d√©but du service
                    gameState.phase = 'serve_start';
                    gameState.currentAction = {
                        type: 'service',
                        player: gameState.currentServer,
                        team: gameState.servingTeam
                    };
                    hideAllSections();
                    highlightCourt(null);
                    showServiceZone();
                    break;

                case 'reception':
                    // Retour √† serve_end
                    gameState.phase = 'serve_end';
                    // R√©cup√©rer les donn√©es du service depuis le rally
                    const serviceFromRally = gameState.rally.pop(); // Retirer le service du rally
                    if (serviceFromRally) {
                        // Garder seulement startPos, on va re-cliquer endPos
                        gameState.currentAction = {
                            type: 'service',
                            player: serviceFromRally.player,
                            team: serviceFromRally.team,
                            startPos: serviceFromRally.startPos
                        };
                    }
                    hideAllSections();
                    const recvTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
                    highlightCourt(recvTeam);
                    // R√©activer zone out et zone filet
                    document.getElementById('outArea').classList.add('active');
                    document.getElementById('netClickZone').classList.add('active');
                    // Afficher les zones de position pour auto-s√©lection
                    showPositionZones(recvTeam);
                    // Afficher le bouton Ace
                    document.getElementById('serveAceSection').classList.remove('hidden');
                    const servCourtSide = getCourtSideForTeam(gameState.servingTeam);
                    document.getElementById('outLabelTop').style.display = servCourtSide === 'top' ? 'none' : 'block';
                    document.getElementById('outLabelBottom').style.display = servCourtSide === 'bottom' ? 'none' : 'block';
                    // Redessiner (juste le marker de d√©part du service)
                    redrawRally();
                    // Ajouter le marker de d√©part du service en cours
                    if (gameState.currentAction.startPos) {
                        addMarker(gameState.currentAction.startPos, 'service');
                    }
                    break;

                case 'reception_end':
                    if (gameState.receptionAutoSelected) {
                        // Auto-s√©lectionn√©: retour combin√© √† serve_end
                        gameState.phase = 'serve_end';
                        gameState.receptionAutoSelected = false;
                        // Retirer le service du rally
                        const autoServiceAction = gameState.rally.pop();
                        if (autoServiceAction) {
                            gameState.currentAction = {
                                type: 'service',
                                player: autoServiceAction.player,
                                team: autoServiceAction.team,
                                startPos: autoServiceAction.startPos,
                                role: autoServiceAction.role
                            };
                        }
                        hideAllSections();
                        hideReceptionQualityZones();
                        document.getElementById('receptionFaultSection').classList.add('hidden');
                        const autoRecvTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
                        highlightCourt(autoRecvTeam);
                        // R√©activer zone out et zone filet
                        document.getElementById('outArea').classList.add('active');
                        document.getElementById('netClickZone').classList.add('active');
                        showPositionZones(autoRecvTeam);
                        // Afficher le bouton Ace
                        document.getElementById('serveAceSection').classList.remove('hidden');
                        // Labels OUT corrects
                        const autoSrvCourtSide = getCourtSideForTeam(gameState.servingTeam);
                        document.getElementById('outLabelTop').style.display = autoSrvCourtSide === 'top' ? 'none' : 'block';
                        document.getElementById('outLabelBottom').style.display = autoSrvCourtSide === 'bottom' ? 'none' : 'block';
                        redrawRally();
                        if (gameState.currentAction.startPos) {
                            addMarker(gameState.currentAction.startPos, 'service');
                        }
                    } else {
                        // Retour standard √† la s√©lection du r√©ceptionneur
                        gameState.phase = 'reception';
                        hideReceptionQualityZones();
                        document.getElementById('receptionFaultSection').classList.add('hidden');
                        showPositionZones(gameState.attackingTeam);
                        renderPlayerSelection(gameState.attackingTeam, 'Qui r√©ceptionne ?');
                        redrawRally();
                    }
                    break;

                case 'direct_return_end':
                    // Retour √† reception_end (avant le clic sur retour direct)
                    gameState.phase = 'reception_end';
                    gameState.currentAction.isDirectReturn = false;
                    gameState.currentAction.quality = null;
                    hideAllSections();
                    highlightCourt(gameState.attackingTeam);
                    showReceptionQualityZones();
                    document.getElementById('receptionFaultSection').classList.remove('hidden');
                    redrawRally();
                    break;

                case 'pass':
                    // Retour √† reception_end
                    gameState.phase = 'reception_end';
                    // R√©cup√©rer la r√©ception depuis le rally
                    const receptionFromRally = gameState.rally.pop();
                    if (receptionFromRally) {
                        gameState.currentAction = { ...receptionFromRally };
                    }
                    hideAllSections();
                    highlightCourt(gameState.attackingTeam);
                    redrawRally();
                    break;

                case 'pass_end':
                    if (gameState.passAutoSelected) {
                        // Auto-s√©lectionn√©: retour combin√© √† reception_end
                        gameState.phase = 'reception_end';
                        gameState.passAutoSelected = false;
                        // R√©cup√©rer la r√©ception depuis le rally
                        const autoReceptionAction = gameState.rally.pop();
                        if (autoReceptionAction) {
                            gameState.currentAction = { ...autoReceptionAction };
                        }
                        hideAllSections();
                        highlightCourt(gameState.attackingTeam);
                        showReceptionQualityZones();
                        document.getElementById('receptionFaultSection').classList.remove('hidden');
                        document.getElementById('outArea').classList.add('active');
                        const autoAttCourtSide = getCourtSideForTeam(gameState.attackingTeam);
                        document.getElementById('outLabelTop').style.display = autoAttCourtSide === 'top' ? 'block' : 'none';
                        document.getElementById('outLabelBottom').style.display = autoAttCourtSide === 'bottom' ? 'block' : 'none';
                        redrawRally();
                    } else {
                        // Retour standard √† la s√©lection du passeur
                        gameState.phase = 'pass';
                        renderPlayerSelection(gameState.attackingTeam, 'Qui fait la passe ?');
                        redrawRally();
                    }
                    break;

                case 'pass_fault_end':
                    // Retour √† pass_end (le passeur est d√©j√† s√©lectionn√©)
                    gameState.currentAction.subType = undefined;
                    gameState.phase = 'pass_end';
                    updatePhase();
                    hideAllSections();
                    document.getElementById('passFaultSection').classList.remove('hidden');
                    document.getElementById('outArea').classList.add('active');
                    highlightCourt(gameState.attackingTeam);
                    redrawRally();
                    break;

                case 'pass_fault_result':
                    // Retour √† pass_fault_end ‚Äî retirer le marker et l'action du rally
                    gameState.rally.pop();
                    gameState.currentAction.endPos = undefined;
                    gameState.phase = 'pass_fault_end';
                    updatePhase();
                    hideAllSections();
                    document.getElementById('outArea').classList.add('active');
                    document.getElementById('outLabelTop').style.display = 'block';
                    document.getElementById('outLabelBottom').style.display = 'block';
                    highlightCourt(null);
                    redrawRally();
                    break;

                case 'second_touch_player':
                    // Retour √† la s√©lection du passeur (phase pass)
                    gameState.phase = 'pass';
                    gameState.secondTouchType = null;
                    renderPlayerSelection(gameState.attackingTeam, 'Qui fait la passe ?');
                    redrawRally();
                    break;

                case 'attack_player':
                    // V√©rifier si on vient d'une attaque directe depuis la d√©fense
                    if (gameState.defenseDirectAttack || (gameState.currentAction && gameState.currentAction.isDefenseDirectAttack)) {
                        // Retour √† la s√©lection du d√©fenseur
                        gameState.defenseDirectAttack = false;
                        gameState.phase = 'defense';
                        renderPlayerSelection(gameState.attackingTeam, 'Qui d√©fend ?');
                        redrawRally();
                    } else {
                        // Retour √† pass_end
                        gameState.phase = 'pass_end';
                        // R√©cup√©rer la passe depuis le rally
                        const passFromRally = gameState.rally.pop();
                        if (passFromRally) {
                            // Garder tout sauf endPos qu'on va re-cliquer
                            gameState.currentAction = {
                                type: 'pass',
                                player: passFromRally.player,
                                team: passFromRally.team,
                                startPos: passFromRally.startPos
                            };
                        }
                        hideAllSections();
                        highlightCourt(gameState.attackingTeam);
                        document.getElementById('passFaultSection').classList.remove('hidden');
                        // Activer la zone out pour les passes
                        document.getElementById('outArea').classList.add('active');
                        const attackingCourtSide = getCourtSideForTeam(gameState.attackingTeam);
                        document.getElementById('outLabelTop').style.display = attackingCourtSide === 'top' ? 'block' : 'none';
                        document.getElementById('outLabelBottom').style.display = attackingCourtSide === 'bottom' ? 'block' : 'none';
                        redrawRally();
                    }
                    break;

                case 'attack_type':
                    // Retour √† la s√©lection de l'attaquant
                    // Si c'√©tait une attaque directe depuis la d√©fense, remettre le flag
                    if (gameState.currentAction && gameState.currentAction.isDefenseDirectAttack) {
                        gameState.defenseDirectAttack = true;
                    }
                    gameState.phase = 'attack_player';
                    renderPlayerSelection(gameState.attackingTeam, 'Qui attaque ?');
                    redrawRally();
                    break;

                case 'attack_end':
                    // Retour au choix du type d'attaque
                    gameState.phase = 'attack_type';
                    showSection('attackTypeSelection');
                    redrawRally();
                    break;

                case 'result':
                    // Retour √† attack_end
                    gameState.phase = 'attack_end';
                    // R√©cup√©rer l'attaque depuis le rally
                    const attackFromRally = gameState.rally.pop();
                    if (attackFromRally) {
                        // Garder tout sauf endPos qu'on va re-cliquer
                        gameState.currentAction = {
                            type: 'attack',
                            player: attackFromRally.player,
                            team: attackFromRally.team,
                            attackType: attackFromRally.attackType,
                            startPos: attackFromRally.startPos
                        };
                    }
                    hideAllSections();
                    const defTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                    highlightCourt(defTeam);
                    redrawRally();
                    break;

                case 'defense':
                    // Retour au r√©sultat, au block_end, au direct_return_end, ou √† la d√©fense pr√©c√©dente
                    const lastActionForDefense = gameState.rally[gameState.rally.length - 1];
                    
                    if (lastActionForDefense && lastActionForDefense.type === 'reception' && lastActionForDefense.isDirectReturn) {
                        // C'√©tait apr√®s un retour direct de r√©ception, retourner √† direct_return_end
                        gameState.phase = 'direct_return_end';
                        const directReturnFromRally = gameState.rally.pop();
                        if (directReturnFromRally) {
                            gameState.currentAction = { ...directReturnFromRally };
                            // Enlever le directReturnEndPos car on va le re-cliquer
                            delete gameState.currentAction.directReturnEndPos;
                        }
                        // Remettre l'√©quipe qui attaque √† celle qui a fait le retour direct
                        gameState.attackingTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
                        hideAllSections();
                        highlightCourt(gameState.servingTeam);
                        redrawRally();
                    } else if (lastActionForDefense && lastActionForDefense.type === 'defense' && lastActionForDefense.isDirectReturn) {
                        // C'√©tait apr√®s un retour direct de d√©fense, retourner √† defense_end de l'action pr√©c√©dente
                        const directReturnDefense = gameState.rally.pop();
                        // Remettre l'√©quipe qui attaque √† celle qui a fait le retour direct
                        gameState.attackingTeam = directReturnDefense.team;
                        gameState.currentAction = { 
                            type: 'defense',
                            player: directReturnDefense.player,
                            team: directReturnDefense.team
                        };
                        gameState.phase = 'defense_end';
                        hideAllSections();
                        highlightCourt(null);
                        document.getElementById('outArea').classList.add('active');
                        const defendingCourtSide = getCourtSideForTeam(gameState.attackingTeam);
                        document.getElementById('outLabelTop').style.display = defendingCourtSide === 'top' ? 'block' : 'none';
                        document.getElementById('outLabelBottom').style.display = defendingCourtSide === 'bottom' ? 'block' : 'none';
                        redrawRally();
                    } else if (lastActionForDefense && lastActionForDefense.type === 'block') {
                        // C'√©tait apr√®s un block, retourner √† block_end
                        gameState.phase = 'block_end';
                        const blockFromRally = gameState.rally.pop();
                        if (blockFromRally) {
                            // Garder tout sauf endPos qu'on va re-cliquer
                            gameState.currentAction = {
                                type: 'block',
                                player: blockFromRally.player,
                                team: blockFromRally.team,
                                startPos: blockFromRally.startPos
                            };
                        }
                        hideAllSections();
                        highlightCourt(gameState.attackingTeam);
                        redrawRally();
                    } else {
                        // C'√©tait apr√®s un defended, retour au r√©sultat
                        gameState.phase = 'result';
                        showSection('resultSelection');
                        // V√©rifier si c'√©tait defended (√©quipe chang√©e)
                        const lastAttackAct = gameState.rally[gameState.rally.length - 1];
                        if (lastAttackAct && lastAttackAct.result === 'defended') {
                            gameState.attackingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                        }
                        redrawRally();
                    }
                    break;

                case 'block_end':
                    // Retour au r√©sultat
                    gameState.phase = 'result';
                    showSection('resultSelection');
                    redrawRally();
                    break;

                case 'defense_end':
                    // Retour √† la s√©lection du d√©fenseur
                    gameState.phase = 'defense';
                    renderPlayerSelection(gameState.attackingTeam, 'Qui d√©fend ?');
                    redrawRally();
                    break;
            }

            updatePhase();
        }

        function cancelPoint() {
            // Si on est au d√©but d'un point (s√©lection serveur ou serve_start avec m√™me serveur)
            // ‚Üí proposer d'annuler le dernier point valid√©
            if (gameState.phase === 'server_selection' || 
                (gameState.phase === 'serve_start' && gameState.currentServer && gameState.rally.length === 0)) {
                if (currentSet.points && currentSet.points.length > 0) {
                    showUndoPointModal();
                } else {
                    alert('Aucun point √† annuler.');
                }
                return;
            }
            
            // Sinon, on est en cours de rally ‚Üí annuler le rally en cours
            if (!confirm('Annuler ce point et recommencer ?')) {
                return;
            }

            // Reset complet du point
            gameState.rally = [];
            gameState.currentAction = {};
            gameState.currentServer = null;
            
            // Remettre l'√©quipe qui attaque
            const receivingTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
            gameState.attackingTeam = receivingTeam;

            clearMarkers();
            clearArrows();
            hideServiceZones();
            hideReceptionQualityZones();
            highlightCourt(null);

            // Retour √† la s√©lection du serveur
            gameState.phase = 'server_selection';
            updatePhase();
            renderServerSelection();
        }

        // ==================== ANNULER DERNIER POINT VALID√â ====================
        function showUndoPointModal() {
            const points = currentSet.points;
            const lastPoint = points[points.length - 1];
            const rally = lastPoint.rally;
            
            // Calculer le score avant ce point
            const prevPoint = points.length >= 2 ? points[points.length - 2] : null;
            const scoreBefore = prevPoint 
                ? `${prevPoint.homeScore} - ${prevPoint.awayScore}` 
                : `${currentSet.homeScore || 0} - ${currentSet.awayScore || 0}`;
            
            // Score initial (bonus inclus)
            const initialHome = currentSet.initialHomeScore || 0;
            const initialAway = currentSet.initialAwayScore || 0;
            const scoreBeforeHome = prevPoint ? prevPoint.homeScore : initialHome;
            const scoreBeforeAway = prevPoint ? prevPoint.awayScore : initialAway;
            
            // Info service
            const serviceAction = rally.find(a => a.type === 'service');
            const serverName = serviceAction ? serviceAction.player : '?';
            const serverTeam = serviceAction ? serviceAction.team : '?';
            const serverTeamName = serverTeam === 'home' ? 'Jen et ses Saints' : (currentMatch.opponent || 'Adversaire');
            
            // Qui a marqu√© ?
            const whoScored = lastPoint.homeScore > scoreBeforeHome ? 'home' : 'away';
            const whoScoredName = whoScored === 'home' ? 'Jen et ses Saints' : (currentMatch.opponent || 'Adversaire');
            
            // Derni√®re action significative
            const lastAction = rally[rally.length - 1];
            let lastActionDesc = '';
            if (lastAction) {
                const actionLabels = {
                    'service': 'Service',
                    'reception': 'R√©ception',
                    'pass': 'Passe',
                    'attack': 'Attaque',
                    'block': 'Block',
                    'defense': 'D√©fense'
                };
                const actionLabel = actionLabels[lastAction.type] || lastAction.type;
                
                if (lastAction.type === 'service') {
                    if (lastAction.result === 'ace') lastActionDesc = `Ace de ${lastAction.player}`;
                    else if (lastAction.result === 'fault' || lastAction.result === 'fault_out' || lastAction.result === 'fault_net') lastActionDesc = `Faute au service de ${lastAction.player}`;
                    else lastActionDesc = `Service de ${lastAction.player}`;
                } else if (lastAction.type === 'attack') {
                    if (lastAction.result === 'point') lastActionDesc = `Attaque gagnante de ${lastAction.player}`;
                    else if (lastAction.attackType === 'faute') lastActionDesc = `Faute d'attaque de ${lastAction.player}`;
                    else if (lastAction.result === 'out') lastActionDesc = `Attaque out de ${lastAction.player}`;
                    else lastActionDesc = `${actionLabel} de ${lastAction.player}`;
                } else if (lastAction.type === 'reception') {
                    if (lastAction.isDirectReturnWinner) lastActionDesc = `Retour gagnant de ${lastAction.player}`;
                    else if (lastAction.quality?.label === 'Faute') lastActionDesc = `Faute r√©ception de ${lastAction.player}`;
                    else lastActionDesc = `${actionLabel} de ${lastAction.player}`;
                } else {
                    lastActionDesc = `${actionLabel}${lastAction.player ? ' de ' + lastAction.player : ''}`;
                }
            }
            
            // Construire le HTML
            const summaryEl = document.getElementById('undoPointSummary');
            summaryEl.innerHTML = `
                <div class="undo-point-score">
                    <span class="score-before">${lastPoint.homeScore} - ${lastPoint.awayScore}</span>
                    <span class="score-arrow">‚Üí</span>
                    <span class="score-after">${scoreBeforeHome} - ${scoreBeforeAway}</span>
                </div>
                <div class="undo-point-detail">
                    <div><span class="label">üèê Service :</span> ${serverName} (${serverTeamName})</div>
                    <div><span class="label">üèÜ Point pour :</span> ${whoScoredName}</div>
                    <div><span class="label">üìã Derni√®re action :</span> ${lastActionDesc}</div>
                    <div style="margin-top:6px; font-size:11px; color:#9ca3af;">Point n¬∞${points.length} ‚Ä¢ ${new Date(lastPoint.timestamp).toLocaleTimeString('fr-FR', {hour:'2-digit', minute:'2-digit'})}</div>
                </div>
            `;
            
            document.getElementById('undoPointOverlay').classList.add('active');
        }

        function closeUndoPointModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('undoPointOverlay').classList.remove('active');
        }

        function confirmUndoLastPoint() {
            const points = currentSet.points;
            if (!points || points.length === 0) return;
            
            // Retirer le dernier point
            const removedPoint = points.pop();
            
            // Restaurer le score
            const prevPoint = points.length > 0 ? points[points.length - 1] : null;
            const initialHome = currentSet.initialHomeScore || 0;
            const initialAway = currentSet.initialAwayScore || 0;
            
            gameState.homeScore = prevPoint ? prevPoint.homeScore : initialHome;
            gameState.awayScore = prevPoint ? prevPoint.awayScore : initialAway;
            
            // Restaurer l'√©quipe au service
            // Le serveur du point supprim√© avait servi pour son √©quipe
            // Si cette √©quipe a perdu le point, le service avait chang√© ‚Üí on r√©tablit
            const serviceAction = removedPoint.rally.find(a => a.type === 'service');
            if (serviceAction) {
                gameState.servingTeam = serviceAction.team;
            }
            
            // R√©initialiser le serveur (on ne sait pas forc√©ment qui servait avant)
            gameState.currentServer = null;
            
            // Mettre √† jour l'affichage
            updateScore();
            
            // Recalculer les stats
            recalculateAllStats();
            
            // Sauvegarder
            saveCurrentSet();
            
            // Fermer la modal
            closeUndoPointModal();
            
            // Reset pour nouveau point
            gameState.rally = [];
            gameState.currentAction = {};
            clearMarkers();
            clearArrows();
            hideServiceZones();
            hideReceptionQualityZones();
            highlightCourt(null);
            
            gameState.phase = 'server_selection';
            updatePhase();
            renderServerSelection();
        }

        function redrawRally() {
            // Redessiner tous les markers et fl√®ches du rally actuel
            clearMarkers();
            clearArrows();

            // Redessiner le service si pr√©sent
            const serviceAction = gameState.rally.find(a => a.type === 'service');
            if (serviceAction) {
                if (serviceAction.startPos) {
                    addMarker(serviceAction.startPos, 'service');
                }
                if (serviceAction.endPos) {
                    addMarker(serviceAction.endPos, 'service');
                }
            }

            // Redessiner les autres actions
            for (let i = 0; i < gameState.rally.length; i++) {
                const action = gameState.rally[i];
                
                if (action.type === 'reception') {
                    if (action.endPos) {
                        addMarker(action.endPos, 'reception');
                    }
                    // Dessiner fl√®che service
                    if (serviceAction && serviceAction.startPos && serviceAction.endPos) {
                        drawArrow(serviceAction.startPos, serviceAction.endPos, 'service');
                        // Dessiner la fl√®che de r√©ception
                        if (action.endPos) {
                            drawArrow(serviceAction.endPos, action.endPos, 'reception');
                        }
                        // Si retour direct avec position d'arriv√©e, dessiner la fl√®che du retour
                        if (action.isDirectReturn && action.directReturnEndPos) {
                            addMarker(action.directReturnEndPos, 'reception');
                            drawArrow(action.endPos, action.directReturnEndPos, 'reception');
                        }
                    }
                } else if (action.type === 'pass') {
                    if (action.endPos) {
                        addMarker(action.endPos, 'pass');
                    }
                    // Trouver l'action pr√©c√©dente pour la fl√®che
                    const prevAction = gameState.rally[i - 1];
                    if (prevAction && prevAction.endPos && action.endPos) {
                        drawArrow(prevAction.endPos, action.endPos, 'pass');
                    }
                } else if (action.type === 'attack') {
                    // D√©terminer le type de marker/fl√®che selon le type d'attaque
                    let arrowType = 'attack';
                    if (action.attackType === 'feinte') {
                        arrowType = 'attack-feinte';
                    } else if (action.attackType === 'relance') {
                        arrowType = 'attack-relance';
                    } else if (action.attackType === 'deuxieme_main' || action.attackType === 'attaque_directe') {
                        arrowType = 'attack-second';
                    }
                    
                    if (action.endPos) {
                        addMarker(action.endPos, arrowType);
                    }
                    // Trouver l'action pr√©c√©dente (passe, ou r√©ception/d√©fense si 2√®me touche)
                    const prevAction = gameState.rally[i - 1];
                    if (prevAction && prevAction.endPos && action.endPos) {
                        drawArrow(prevAction.endPos, action.endPos, arrowType);
                    }
                } else if (action.type === 'block') {
                    if (action.endPos) {
                        addMarker(action.endPos, 'block');
                    }
                    // Trouver l'attaque pr√©c√©dente
                    const lastAttack = [...gameState.rally.slice(0, i)].reverse().find(a => a.type === 'attack');
                    if (lastAttack && lastAttack.endPos && action.endPos) {
                        drawArrow(lastAttack.endPos, action.endPos, 'block');
                    }
                } else if (action.type === 'defense') {
                    if (action.endPos) {
                        addMarker(action.endPos, 'defense');
                    }
                    // Si c'est un retour direct de d√©fense, afficher aussi le point d'arriv√©e
                    if (action.isDirectReturn && action.directReturnEndPos) {
                        addMarker(action.directReturnEndPos, 'defense');
                        if (action.endPos) {
                            drawArrow(action.endPos, action.directReturnEndPos, 'defense');
                        }
                    } else {
                        // Trouver l'action pr√©c√©dente (block, attack, ou retour direct)
                        const prevAction = gameState.rally[i - 1];
                        if (prevAction && prevAction.type === 'reception' && prevAction.isDirectReturn && prevAction.directReturnEndPos) {
                            // Cas du retour direct de r√©ception : fl√®che depuis directReturnEndPos
                            if (action.endPos) {
                                drawArrow(prevAction.directReturnEndPos, action.endPos, 'defense');
                            }
                        } else if (prevAction && prevAction.type === 'defense' && prevAction.isDirectReturn && prevAction.directReturnEndPos) {
                            // Cas du retour direct de d√©fense pr√©c√©dente : fl√®che depuis directReturnEndPos
                            if (action.endPos) {
                                drawArrow(prevAction.directReturnEndPos, action.endPos, 'defense');
                            }
                        } else if (prevAction && prevAction.endPos && action.endPos) {
                            drawArrow(prevAction.endPos, action.endPos, 'defense');
                        }
                    }
                }
            }
        }

        function saveCurrentSet() {
            currentSet.homeScore = gameState.homeScore;
            currentSet.awayScore = gameState.awayScore;
            currentMatch.sets[setIndex] = currentSet;
            localStorage.setItem('volleyball_current_match', JSON.stringify(currentMatch));
        }

        // ==================== CHANGEMENT DE JOUEUR ====================
        let subState = {
            team: 'home',
            selectedSlot: null,   // Position number on court
            selectedBench: null   // Bench player name
        };

        function openSubModal() {
            subState = { team: 'home', selectedSlot: null, selectedBench: null };
            
            document.getElementById('subTabAway').textContent = currentMatch.opponent || 'Adversaire';
            document.getElementById('subTabHome').classList.add('active');
            document.getElementById('subTabAway').classList.remove('active');
            
            renderSubModal();
            document.getElementById('subModalOverlay').classList.add('active');
        }

        function closeSubModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('subModalOverlay').classList.remove('active');
        }

        function switchSubTeam(team) {
            subState = { team, selectedSlot: null, selectedBench: null };
            
            document.getElementById('subTabHome').classList.toggle('active', team === 'home');
            document.getElementById('subTabAway').classList.toggle('active', team === 'away');
            
            renderSubModal();
        }

        function getPosForRole(team, role) {
            const roles = POSITION_ROLES[team];
            for (const [pos, r] of Object.entries(roles)) {
                if (r === role) return pos;
            }
            return null;
        }

        function renderSubModal() {
            const team = subState.team;
            const lineup = team === 'home' ? currentSet.homeLineup : currentSet.awayLineup;
            
            // Update court slots by role
            const roleList = ['Passeur', 'R4', 'Centre', 'Pointu'];
            roleList.forEach(role => {
                const slotEl = document.getElementById('subSlot' + role);
                const playerSpan = slotEl.querySelector('.slot-player');
                const pos = getPosForRole(team, role);
                const playerName = lineup[pos];
                
                playerSpan.textContent = playerName || '‚Äî';
                slotEl.classList.toggle('empty', !playerName);
                slotEl.classList.toggle('selected', subState.selectedSlot === role);
            });
            
            // Update bench
            const benchGrid = document.getElementById('subBenchGrid');
            const onCourt = Object.values(lineup).filter(p => p !== null);
            let bench = [];
            
            if (team === 'home') {
                const allPlayers = currentMatch.players || [];
                bench = allPlayers.filter(p => !onCourt.includes(p.prenom)).map(p => p.prenom);
            } else {
                const allAway = currentMatch.adversePlayers || [];
                bench = allAway.filter(name => !onCourt.includes(name));
            }
            
            if (bench.length > 0) {
                benchGrid.innerHTML = bench.map(name => `
                    <div class="sub-bench-player ${subState.selectedBench === name ? 'selected' : ''}" 
                         onclick="subBenchClick('${name}')">${name}</div>
                `).join('');
            } else {
                benchGrid.innerHTML = '<span class="sub-no-player">Pas de rempla√ßant</span>';
            }
        }

        function subSlotClick(role) {
            const team = subState.team;
            const lineup = team === 'home' ? currentSet.homeLineup : currentSet.awayLineup;
            const pos = getPosForRole(team, role);
            
            if (subState.selectedBench) {
                // Bench player selected ‚Üí substitute into this slot
                const benchPlayer = subState.selectedBench;
                
                lineup[pos] = benchPlayer;
                
                const statsTeam = team === 'home' ? setStats.home : setStats.away;
                if (!statsTeam[benchPlayer]) {
                    statsTeam[benchPlayer] = initPlayerStats(benchPlayer);
                }
                
                subState.selectedBench = null;
                saveCurrentSet();
                renderStatsTables();
                renderServerSelection();
                renderSubModal();
                
            } else if (subState.selectedSlot !== null) {
                if (subState.selectedSlot === role) {
                    // Deselect
                    subState.selectedSlot = null;
                    renderSubModal();
                } else {
                    // Swap positions between the two roles
                    const pos1 = getPosForRole(team, subState.selectedSlot);
                    const pos2 = pos;
                    const temp = lineup[pos1];
                    lineup[pos1] = lineup[pos2];
                    lineup[pos2] = temp;
                    
                    subState.selectedSlot = null;
                    saveCurrentSet();
                    renderSubModal();
                }
            } else {
                // Select this slot
                subState.selectedSlot = role;
                subState.selectedBench = null;
                renderSubModal();
            }
        }

        function subBenchClick(playerName) {
            if (subState.selectedSlot !== null) {
                // Court slot selected ‚Üí substitute bench player into that slot
                const team = subState.team;
                const lineup = team === 'home' ? currentSet.homeLineup : currentSet.awayLineup;
                const pos = getPosForRole(team, subState.selectedSlot);
                
                lineup[pos] = playerName;
                
                const statsTeam = team === 'home' ? setStats.home : setStats.away;
                if (!statsTeam[playerName]) {
                    statsTeam[playerName] = initPlayerStats(playerName);
                }
                
                subState.selectedSlot = null;
                saveCurrentSet();
                renderStatsTables();
                renderServerSelection();
                renderSubModal();
                
            } else if (subState.selectedBench === playerName) {
                // Deselect
                subState.selectedBench = null;
                renderSubModal();
            } else {
                // Select this bench player
                subState.selectedBench = playerName;
                subState.selectedSlot = null;
                renderSubModal();
            }
        }

        function handleBack() {
            if (confirm('Voulez-vous quitter le match en cours ? Les donn√©es seront sauvegard√©es.')) {
                saveCurrentSet();
                window.location.href = 'index.html';
            }
        }

        // ==================== INIT ====================
        init();
    </script>
</body>
</html>
