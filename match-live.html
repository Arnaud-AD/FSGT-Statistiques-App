<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match Live - Jen et ses Saints</title>
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;600;700&family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="match-live.css">
</head>
<body class="classic-mode">
    <div class="layout-wrapper" id="layoutWrapper">
    <div class="app-container">
        <!-- Score Header -->
        <header class="score-header">
            <div class="score-header-row-top">
                <div class="score-header-left">
                    <button class="back-btn" onclick="handleBack()">
                        <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                        </svg>
                    </button>
                    <span class="set-indicator" id="setIndicator">SET 1</span>
                </div>
                <div class="score-display">
                    <div class="team-score" id="homeScoreDisplay">
                        <div class="team-name">Jen et ses Saints</div>
                        <div class="team-points" id="homePoints">0</div>
                    </div>
                    <span class="score-separator">-</span>
                    <div class="team-score" id="awayScoreDisplay">
                        <div class="team-name" id="awayTeamName">Adversaire</div>
                        <div class="team-points" id="awayPoints">0</div>
                    </div>
                </div>
                <div class="score-header-right-placeholder"></div>
            </div>
            <div class="score-header-row-bottom">
                <div class="header-controls-left">
                    <button class="header-ctrl-btn substitute" id="btnSubstitute" onclick="openSubModal()" title="Changement" style="display: none;">
                        <svg width="12" height="12" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M16 17.01V10h-2v7.01h-3L15 21l4-3.99h-3zM9 3L5 6.99h3V14h2V6.99h3L9 3z"/>
                        </svg>
                        Changement
                    </button>
                    <button class="header-ctrl-btn end-set" id="btnEndSet" onclick="openEndSetModal('manual')" title="Terminer le set" style="display: none;">
                        <svg width="12" height="12" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"/>
                        </svg>
                        Fin du Set
                    </button>
                </div>
                <div class="header-controls-center">
                    <button class="header-ctrl-btn youtube-link" id="btnYoutubeLink" onclick="openYoutubeModal()" title="Lien YouTube">
                        <svg width="12" height="12" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M10 15l5.19-3L10 9v6m11.56-7.83c.13.47.22 1.1.28 1.9.07.8.1 1.49.1 2.09L22 12c0 2.19-.16 3.8-.44 4.83-.25.9-.83 1.48-1.73 1.73-.47.13-1.33.22-2.65.28-1.3.07-2.49.1-3.59.1L12 19c-4.19 0-6.8-.16-7.83-.44-.9-.25-1.48-.83-1.73-1.73-.13-.47-.22-1.1-.28-1.9-.07-.8-.1-1.49-.1-2.09L2 12c0-2.19.16-3.8.44-4.83.25-.9.83-1.48 1.73-1.73.47-.13 1.33-.22 2.65-.28 1.3-.07 2.49-.1 3.59-.1L12 5c4.19 0 6.8.16 7.83.44.9.25 1.48.83 1.73 1.73z"/>
                        </svg>
                        YouTube
                    </button>
                </div>
                <div class="header-controls-right">
                    <button class="header-ctrl-btn undo" onclick="undoLastAction()" title="Retour">
                        <svg width="12" height="12" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>
                        </svg>
                        Retour
                    </button>
                    <button class="header-ctrl-btn cancel" onclick="cancelPoint()" title="Annuler le point">
                        <svg width="12" height="12" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                        </svg>
                        Annuler point
                    </button>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Overlay pr√©-match : cam√©ra + service (affich√© avant le 1er point) -->
            <div class="pre-match-overlay" id="preMatchOverlay">
                <div class="pre-match-card">
                    <div class="pre-match-section">
                        <div class="pre-match-label">
                            <svg fill="currentColor" viewBox="0 0 24 24" width="18" height="18">
                                <path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/>
                            </svg>
                            √âquipe c√¥t√© cam√©ra (terrain du bas)
                        </div>
                        <div class="pre-match-toggle" id="preMatchCameraToggle">
                            <button class="pre-match-option selected" data-value="home" onclick="preMatchSelect('camera', 'home')">Jen et ses Saints</button>
                            <button class="pre-match-option" data-value="away" onclick="preMatchSelect('camera', 'away')" id="preMatchCameraAway">Adversaire</button>
                        </div>
                    </div>
                    <div class="pre-match-section">
                        <div class="pre-match-label">
                            <svg fill="currentColor" viewBox="0 0 24 24" width="18" height="18">
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                            </svg>
                            Qui sert ?
                        </div>
                        <div class="pre-match-toggle" id="preMatchServingToggle">
                            <button class="pre-match-option" data-value="home" onclick="preMatchSelect('serving', 'home')">Jen et ses Saints</button>
                            <button class="pre-match-option selected" data-value="away" onclick="preMatchSelect('serving', 'away')" id="preMatchServingAway">Adversaire</button>
                        </div>
                    </div>
                    <button class="pre-match-start-btn" onclick="confirmPreMatch()">
                        <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        D√©marrer le Set
                    </button>
                </div>
            </div>

            <!-- Phase Indicator -->
            <div class="phase-indicator" id="phaseIndicator">
                <span class="highlight">Service</span> ‚Äî S√©lectionnez le serveur
            </div>

            <!-- Court -->
            <div class="court-container" id="courtContainer">
                <!-- Zone out cliquable (visible pendant serve_end) -->
                <div class="out-area" id="outArea">
                    <span class="out-area-label top" id="outLabelTop">OUT</span>
                    <span class="out-area-label bottom" id="outLabelBottom">OUT</span>
                    <span class="out-area-label left">OUT</span>
                    <span class="out-area-label right">OUT</span>
                </div>
                
                <div class="court" id="court">
                    <!-- Zone de service haut -->
                    <div class="service-zone top" id="serviceZoneTop">
                        <span class="service-zone-label">Zone de service</span>
                    </div>
                    
                    <div class="team-label" id="topTeamLabel">Adversaire</div>
                    <div class="court-half away" id="courtTop" data-team="away">
                        <!-- Zones de position (pour auto-s√©lection r√©ception) -->
                        <div class="position-zones" id="positionZonesTop">
                            <div class="position-zone" data-zone="left"></div>
                            <div class="position-zone" data-zone="center"></div>
                            <div class="position-zone" data-zone="right"></div>
                        </div>
                        <!-- Zones d'attaque (pour auto-s√©lection attaquant) -->
                        <div class="attack-zones" id="attackZonesTop">
                            <div class="attack-zone" data-zone="left"></div>
                            <div class="attack-zone" data-zone="center"></div>
                            <div class="attack-zone" data-zone="right"></div>
                        </div>
                        <!-- Zones de d√©fense (pour auto-s√©lection d√©fenseur) -->
                        <div class="defense-zones" id="defenseZonesTop">
                            <div class="defense-zone" data-zone="line"></div>
                            <div class="defense-zone" data-zone="diagonal"></div>
                            <div class="defense-zone" data-zone="short"></div>
                            <div class="defense-zone" data-zone="extra"></div>
                        </div>
                        <!-- Zones de qualit√© de r√©ception -->
                        <div class="reception-quality-zones" id="qualityZonesTop">
                            <div class="quality-zone average"></div>
                            <div class="quality-zone good"></div>
                            <div class="quality-zone perfect"></div>
                        </div>
                        <!-- Zone de qualit√© de d√©fense (D+) -->
                        <div class="defense-quality-zones" id="defQualityZonesTop">
                            <div class="defense-quality-zone positive"></div>
                        </div>
                        <!-- Zone debug qualit√© de passe (V19.1d) -->
                        <div class="pass-quality-grid" id="passGridTop"></div>
                    </div>
                    <div class="net" id="netZone">
                        <div class="net-click-zone" id="netClickZone">
                            <div class="net-zone-half" id="netZoneLeft"></div>
                            <div class="net-zone-half" id="netZoneRight"></div>
                        </div>
                    </div>
                    <div class="court-half home" id="courtBottom" data-team="home">
                        <!-- Zones de position (pour auto-s√©lection r√©ception) -->
                        <div class="position-zones" id="positionZonesBottom">
                            <div class="position-zone" data-zone="left"></div>
                            <div class="position-zone" data-zone="center"></div>
                            <div class="position-zone" data-zone="right"></div>
                        </div>
                        <!-- Zones d'attaque (pour auto-s√©lection attaquant) -->
                        <div class="attack-zones" id="attackZonesBottom">
                            <div class="attack-zone" data-zone="left"></div>
                            <div class="attack-zone" data-zone="center"></div>
                            <div class="attack-zone" data-zone="right"></div>
                        </div>
                        <!-- Zones de d√©fense (pour auto-s√©lection d√©fenseur) -->
                        <div class="defense-zones" id="defenseZonesBottom">
                            <div class="defense-zone" data-zone="line"></div>
                            <div class="defense-zone" data-zone="diagonal"></div>
                            <div class="defense-zone" data-zone="short"></div>
                            <div class="defense-zone" data-zone="extra"></div>
                        </div>
                        <!-- Zones de qualit√© de r√©ception -->
                        <div class="reception-quality-zones" id="qualityZonesBottom">
                            <div class="quality-zone average"></div>
                            <div class="quality-zone good"></div>
                            <div class="quality-zone perfect"></div>
                        </div>
                        <!-- Zone de qualit√© de d√©fense (D+) -->
                        <div class="defense-quality-zones" id="defQualityZonesBottom">
                            <div class="defense-quality-zone positive"></div>
                        </div>
                        <!-- Zone debug qualit√© de passe (V19.1d) -->
                        <div class="pass-quality-grid" id="passGridBottom"></div>
                    </div>
                    <div class="team-label" id="bottomTeamLabel">Jen et ses Saints</div>
                    
                    <!-- Zone de service bas -->
                    <div class="service-zone bottom" id="serviceZoneBottom">
                        <span class="service-zone-label">Zone de service</span>
                    </div>
                </div>
                
                <!-- SVG for arrows (dans court-container pour couvrir la zone out) -->
                <svg class="arrow-svg" id="arrowSvg">
                    <defs>
                        <marker id="arrowhead-service" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-service" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-reception" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-reception" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-pass" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-pass" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-attack" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-attack" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-attack-feinte" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-attack-feinte" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-attack-relance" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-attack-relance" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-attack-second" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-attack-second" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-defense" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-defense" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-block" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-block" points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-block-touch" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon class="arrow-head-block-touch" points="0 0, 10 3.5, 0 7" />
                        </marker>
                    </defs>
                </svg>
            </div>

            <!-- Tags Container -->
            <div class="tags-container" id="tagsContainer">
                <!-- Server selection (initial) -->
                <div id="serverSelection">
                    <div class="tags-title">Qui sert ?</div>
                    <div class="tags-grid" id="serverTags">
                        <!-- Generated dynamically -->
                    </div>
                </div>

                <!-- Server continue indicator -->
                <div id="serverContinue" class="hidden">
                    <div class="server-continue-banner" id="serverContinueBanner">
                        üèê <span class="server-name" id="serverContinueName">Joueur</span> toujours au service
                    </div>
                </div>

                <!-- Options 2√®me touche (visible uniquement pendant la phase passe) -->
                <div id="secondTouchOptions" class="hidden">
                    <div class="tags-title">Ou action en 2√®me touche</div>
                    <div class="tags-grid">
                        <button class="action-tag second-touch" onclick="WorkflowEngine.handleButton('secondTouch', 'deuxieme_main')">‚úã Deuxi√®me main</button>
                        <button class="action-tag second-touch" onclick="WorkflowEngine.handleButton('secondTouch', 'attaque_directe')">‚ö° Attaque directe</button>
                        <button class="action-tag relance" onclick="WorkflowEngine.handleButton('secondTouch', 'relance')">‚Ü©Ô∏è Relance</button>
                        <button class="action-tag faute" onclick="WorkflowEngine.handleButton('passFault')">‚úñ Faute passe</button>
                    </div>
                </div>

                <!-- Choix retour direct passe (passe qui va chez l'adversaire) -->
                <div id="passDirectReturnChoice" class="hidden">
                    <div class="tags-title">Passe chez l'adversaire ‚Äî Que se passe-t-il ?</div>
                    <div class="tags-grid">
                        <button class="action-tag direct-return" onclick="WorkflowEngine.handleButton('defense')">üõ°Ô∏è D√©fendu</button>
                        <button class="action-tag direct-return" onclick="WorkflowEngine.handleButton('direct_attack')">‚ö° Attaque directe</button>
                        <button class="action-tag direct-return-winner" onclick="WorkflowEngine.handleButton('winner')">‚úÖ Point direct</button>
                    </div>
                </div>

                <!-- Attack type selection -->
                <div id="attackTypeSelection" class="hidden">
                    <div class="tags-title">Type d'attaque</div>
                    <div class="tags-grid">
                        <button class="action-tag feinte" onclick="WorkflowEngine.handleButton('selectAttackType', 'feinte')">üéØ Feinte</button>
                        <button class="action-tag relance" onclick="WorkflowEngine.handleButton('selectAttackType', 'relance')">‚Ü©Ô∏è¬è Relance</button>
                    </div>
                </div>

                <!-- Result selection -->
                <div id="resultSelection" class="hidden">
                    <div class="tags-title">R√©sultat de l'attaque</div>
                    <div class="tags-grid">
                        <button class="action-tag point" onclick="WorkflowEngine.handleButton('point')">‚úî Point</button>
                        <button class="action-tag faute" onclick="WorkflowEngine.handleButton('defenseFault')">‚ùå D√©fense faute</button>
                    </div>
                </div>

                <!-- Faute de r√©ception + Ace -->
                <div id="receptionFaultSection" class="hidden">
                    <div class="tags-grid">
                        <button class="action-tag ace" onclick="WorkflowEngine.handleButton('ace')">üéØ Ace</button>
                        <button class="action-tag faute" onclick="WorkflowEngine.handleButton('receptionFault')">‚ùå Faute r√©ception</button>
                    </div>
                    <div class="quality-legend">
                        <span class="legend-item"><span class="legend-dot perfect"></span>Excellente 4/4</span>
                        <span class="legend-item"><span class="legend-dot good"></span>Positive 3/4</span>
                        <span class="legend-item"><span class="legend-dot average"></span>Jouable 2/4</span>
                        <span class="legend-item"><span class="legend-dot poor"></span>N√©gative 1/4</span>
                    </div>
                </div>

                <!-- Choix retour terrain adverse (r√©ception qui va chez l'adversaire) -->
                <div id="receptionOpponentChoice" class="hidden">
                    <div class="tags-title">Retour direct ‚Äî Que se passe-t-il ?</div>
                    <div class="tags-grid">
                        <button class="action-tag direct-return" onclick="WorkflowEngine.handleButton('defense')">üõ°Ô∏è¬è D√©fendu</button>
                        <button class="action-tag direct-return" onclick="WorkflowEngine.handleButton('direct_attack')">‚ö° Attaque directe</button>
                        <button class="action-tag direct-return-winner" onclick="WorkflowEngine.handleButton('winner')">‚úÖ Retour gagnant</button>
                    </div>
                </div>

                <!-- Choix r√©ception dans le filet -->
                <div id="receptionNetChoice" class="hidden">
                    <div class="tags-title">R√©ception filet ‚Äî Attaque directe ou cliquez le terrain = block</div>
                    <div class="tags-grid">
                        <button class="action-tag direct-return-winner" onclick="WorkflowEngine.handleButton('direct_attack')">‚ö° Attaque directe</button>
                    </div>
                </div>

                <!-- Choix passe dans le filet -->
                <div id="passNetChoice" class="hidden">
                    <div class="tags-title">Passe filet ‚Äî Attaque directe ou cliquez le terrain = block</div>
                    <div class="tags-grid">
                        <button class="action-tag direct-return-winner" onclick="WorkflowEngine.handleButton('direct_attack')">‚ö° Attaque directe</button>
                    </div>
                </div>

                <!-- Choix attaque dans le filet -->
                <div id="attackNetChoice" class="hidden">
                    <div class="tags-title">Attaque dans le filet ‚Äî Faute ou cliquez le terrain = block</div>
                    <div class="tags-grid">
                        <button class="action-tag faute" onclick="WorkflowEngine.handleButton('faute')">‚ùå Faute (filet)</button>
                        <button class="action-tag bloc-out" onclick="WorkflowEngine.handleButton('bloc_out')">üí• Bloc out</button>
                    </div>
                </div>

                <!-- Actions sp√©ciales depuis d√©fense (visible apr√®s block ou en contexte adapt√©) -->
                <div id="defenseDirectAttackSection" class="hidden">
                    <div class="tags-grid">
                        <button class="action-tag direct-return" onclick="WorkflowEngine.handleButton('directAttack')">‚ö° Attaque directe</button>
                        <button id="blockKillBtn" class="action-tag point hidden" onclick="WorkflowEngine.handleButton('blockKill')">üíÄ Bloc Kill</button>
                    </div>
                </div>


                <!-- Choix retour direct d√©fense (d√©fense qui va chez l'adversaire) -->
                <div id="defenseDirectReturnChoice" class="hidden">
                    <div class="tags-title">Retour direct d√©fense ‚Äî Que se passe-t-il ?</div>
                    <div class="tags-grid">
                        <button class="action-tag direct-return" onclick="WorkflowEngine.handleButton('defense')">üõ°Ô∏è D√©fendu</button>
                        <button class="action-tag direct-return" onclick="WorkflowEngine.handleButton('direct_attack')">‚ö° Attaque directe</button>
                        <button class="action-tag direct-return-winner" onclick="WorkflowEngine.handleButton('winner')">‚úÖ Retour gagnant</button>
                    </div>
                </div>
                <!-- D√©fense faute / Point block (visible pendant defense_end) -->
                <div id="defenseFaultSection" class="hidden">
                    <div class="tags-grid">
                        <button class="action-tag point" onclick="WorkflowEngine.handleButton('defensePoint')">‚úî Point</button>
                        <button class="action-tag faute" onclick="WorkflowEngine.handleButton('defenseFault')">‚ùå D√©fense faute</button>
                    </div>
                </div>

                <!-- Phase trajectoire bloc out -->
                <div id="blocOutTrajectory" class="hidden">
                    <div class="tags-title">Cliquez o√π va la balle (trajectoire du bloc out)</div>
                    <div class="tags-grid">
                        <button class="action-tag" onclick="WorkflowEngine.handleButton('skip')">‚è© Passer</button>
                    </div>
                </div>

                <!-- Phase trajectoire faute d√©fense -->
                <div id="defenseFaultTrajectory" class="hidden">
                    <div class="tags-title">Cliquez o√π va la balle (trajectoire de la faute)</div>
                    <div class="tags-grid">
                        <button class="action-tag" onclick="WorkflowEngine.handleButton('skip')">‚è© Passer</button>
                    </div>
                </div>

                <!-- Phase trajectoire faute de passe (V19.3) -->
                <div id="passFaultTrajectory" class="hidden">
                    <div class="tags-title">Cliquez o√π va la balle (trajectoire faute passe)</div>
                    <div class="tags-grid">
                        <button class="action-tag" onclick="WorkflowEngine.handleButton('skip')">‚è© Passer</button>
                    </div>
                </div>

                <!-- Phase trajectoire faute r√©ception -->
                <div id="receptionFaultTrajectory" class="hidden">
                    <div class="tags-title">Cliquez o√π va la balle (trajectoire de la faute)</div>
                    <div class="tags-grid">
                        <button class="action-tag" onclick="WorkflowEngine.handleButton('skip')">‚è© Passer</button>
                    </div>
                </div>

                <!-- Player override/selection tags (en bas pour priorit√© visuelle aux boutons d'action) -->
                <div id="playerSelection" class="hidden">
                    <div class="tags-title" id="playerSelectionTitle">S√©lectionnez le joueur</div>
                    <div class="tags-grid" id="playerTags">
                        <!-- Generated dynamically -->
                    </div>
                </div>

            </div>
        </main>

        <!-- Tableau de statistiques du set -->
        <div class="stats-section">
            <!-- Tableau √©quipe domicile -->
            <div class="stats-table-container">
                <div class="stats-table-title">üìä <span id="homeTeamStatsTitle">Jen et ses Saints</span></div>
                <div class="stats-tables-container" id="homeStatsContainer">
                    <!-- G√©n√©r√© dynamiquement par renderStatsTable() -->
                </div>
            </div>

            <!-- Tableau √©quipe adverse -->
            <div class="stats-table-container">
                <div class="stats-table-title">üìä <span id="awayTeamStatsTitle">Adversaire</span></div>
                <div class="stats-tables-container" id="awayStatsContainer">
                    <!-- G√©n√©r√© dynamiquement par renderStatsTable() -->
                </div>
            </div>
        </div>

        <!-- Tableau passe d√©taill√©e (V19.2) -->
        <div id="passDetailContainer"></div>

        <!-- Mini-timeline du set en cours -->
        <div class="mini-timeline-section" id="miniTimelineSection">
            <div class="mini-timeline-title">S√©ries de points</div>
            <div class="mini-timeline-chart" id="miniTimelineChart"></div>
        </div>

        <!-- Modal de changement -->
        <div class="sub-modal-overlay" id="subModalOverlay" onclick="closeSubModal(event)">
            <div class="sub-modal" onclick="event.stopPropagation()">
                <div class="sub-modal-title">üîÑ Changement / Positions</div>
                
                <div class="sub-modal-tabs">
                    <button class="sub-modal-tab home active" id="subTabHome" onclick="switchSubTeam('home')">Jen et ses Saints</button>
                    <button class="sub-modal-tab away" id="subTabAway" onclick="switchSubTeam('away')">Adversaire</button>
                </div>

                <div class="sub-modal-hint">Cliquez 2 joueurs sur le terrain pour √©changer leurs positions.<br>Cliquez un rempla√ßant puis un joueur sur le terrain pour substituer.</div>
                
                <!-- Mini court -->
                <div class="sub-mini-court" id="subMiniCourt">
                    <div class="sub-court-row front">
                        <div class="sub-court-slot" id="subSlotPasseur" onclick="subSlotClick('Passeur')">
                            <span class="slot-role">Passeur</span>
                            <span class="slot-player">‚Äî</span>
                        </div>
                    </div>
                    <div class="sub-court-row">
                        <div class="sub-court-slot" id="subSlotR4" onclick="subSlotClick('R4')">
                            <span class="slot-role">R4</span>
                            <span class="slot-player">‚Äî</span>
                        </div>
                        <div class="sub-court-slot" id="subSlotCentre" onclick="subSlotClick('Centre')">
                            <span class="slot-role">Centre</span>
                            <span class="slot-player">‚Äî</span>
                        </div>
                        <div class="sub-court-slot" id="subSlotPointu" onclick="subSlotClick('Pointu')">
                            <span class="slot-role">Pointu</span>
                            <span class="slot-player">‚Äî</span>
                        </div>
                    </div>
                </div>

                <!-- Bench -->
                <div class="sub-bench-section">
                    <div class="sub-bench-label">ü™ë Rempla√ßants :</div>
                    <div class="sub-bench-grid" id="subBenchGrid">
                        <!-- Generated dynamically -->
                    </div>
                </div>

                <!-- Blocker config -->
                <div class="sub-bench-section">
                    <div class="sub-bench-label">üõ°Ô∏è Qui bloque (face au R4) :</div>
                    <div class="sub-blocker-toggle" id="subBlockerRightToggle">
                        <!-- Generated dynamically -->
                    </div>
                </div>
                <div class="sub-bench-section">
                    <div class="sub-bench-label">üõ°Ô∏è Bloqueur principal (2/3 filet) :</div>
                    <div class="sub-blocker-toggle" id="subPrimaryBlockerToggle">
                        <!-- Generated dynamically -->
                    </div>
                </div>

                <!-- Mixit√© -->
                <div class="sub-bench-section" id="subMixiteSection">
                    <div class="sub-bench-label">‚öñÔ∏è Points de mixit√© :</div>
                    <div class="sub-mixite-row">
                        <span class="sub-mixite-team">Jen</span>
                        <input type="number" class="sub-mixite-input" id="subMixiteHome" value="0" min="0" max="10" oninput="setMixite()">
                        <span class="sub-mixite-pts">pts</span>
                        <span class="sub-mixite-sep">‚Äî</span>
                        <span class="sub-mixite-team" id="subMixiteAwayLabel">Adv</span>
                        <input type="number" class="sub-mixite-input" id="subMixiteAway" value="0" min="0" max="10" oninput="setMixite()">
                        <span class="sub-mixite-pts">pts</span>
                    </div>
                </div>

                <div class="sub-modal-actions">
                    <button class="sub-modal-btn cancel" onclick="closeSubModal()">Fermer</button>
                </div>
            </div>
        </div>

        <!-- Modal annuler dernier point -->
        <div class="undo-point-overlay" id="undoPointOverlay" onclick="closeUndoPointModal(event)">
            <div class="undo-point-modal" onclick="event.stopPropagation()">
                <div class="undo-point-title">‚ö†¬†Ô∏è Annuler le dernier point ?</div>
                <div class="undo-point-summary" id="undoPointSummary">
                    <!-- Rempli dynamiquement -->
                </div>
                <div class="undo-point-actions">
                    <button class="undo-point-btn keep" onclick="closeUndoPointModal()">Garder</button>
                    <button class="undo-point-btn remove" onclick="confirmUndoLastPoint()">Supprimer ce point</button>
                </div>
            </div>
        </div>

        <!-- Modal fin de set -->
        <div class="end-set-overlay" id="endSetOverlay">
            <div class="end-set-modal" onclick="event.stopPropagation()">
                <div class="end-set-icon" id="endSetIcon">üèÜ</div>
                <div class="end-set-title" id="endSetTitle">Fin du Set</div>
                <div class="end-set-subtitle" id="endSetSubtitle"></div>
                
                <!-- Score actuel -->
                <div class="end-set-score-display" id="endSetScoreDisplay">
                    <div class="team">
                        <div class="team-name">Jen et ses Saints</div>
                        <div class="team-pts" id="endSetHomeScore">0</div>
                    </div>
                    <div class="vs">‚Äî</div>
                    <div class="team">
                        <div class="team-name" id="endSetAwayName">Adversaire</div>
                        <div class="team-pts" id="endSetAwayScore">0</div>
                    </div>
                </div>
                
                <div class="end-set-winner" id="endSetWinner"></div>

                <!-- Choix raison (mode manuel uniquement) -->
                <div class="end-set-reasons" id="endSetReasons" style="display:none;">
                    <button class="end-set-reason-btn" onclick="selectEndReason('camera')">
                        <span class="reason-icon">üîπ</span>
                        <div class="reason-text">
                            <div class="reason-title">Probl√®me cam√©ra</div>
                            <div class="reason-desc">Batterie, chute, obstruction"¬¶ Saisir le score r√©el</div>
                        </div>
                    </button>
                    <button class="end-set-reason-btn" onclick="selectEndReason('time')">
                        <span class="reason-icon">‚è±Ô∏è</span>
                        <div class="reason-text">
                            <div class="reason-title">Fin du cr√©neau</div>
                            <div class="reason-desc">Le set se termine sur le score actuel</div>
                        </div>
                    </button>
                </div>

                <!-- Score r√©el (mode cam√©ra) -->
                <div class="end-set-real-score" id="endSetRealScore">
                    <div class="end-set-real-score-title">Score r√©el de fin de set</div>
                    <div class="end-set-real-score-inputs">
                        <div class="team-input">
                            <label>Jen et ses Saints</label>
                            <input type="number" id="realScoreHome" min="0" max="99" value="0">
                        </div>
                        <div class="input-sep">‚Äî</div>
                        <div class="team-input">
                            <label id="realScoreAwayLabel">Adversaire</label>
                            <input type="number" id="realScoreAway" min="0" max="99" value="0">
                        </div>
                    </div>
                </div>

                <!-- Recap stats -->
                <div class="end-set-stats-recap" id="endSetStatsRecap"></div>

                <!-- Actions -->
                <div class="end-set-actions">
                    <button class="end-set-btn cancel" id="endSetCancelBtn" onclick="closeEndSetModal()">Annuler</button>
                    <button class="end-set-btn cancel" id="endSetBackBtn" onclick="returnToGameForCorrection()">‚Üê¬ê Corriger</button>
                    <button class="end-set-btn confirm" id="endSetConfirmBtn" onclick="confirmEndSet()">Valider</button>
                </div>
            </div>
        </div>

        <!-- ==================== MODAL FIN DE MATCH ==================== -->
        <div class="end-match-overlay" id="endMatchOverlay" onclick="event.stopPropagation()">
            <div class="end-match-modal" onclick="event.stopPropagation()">
                <div class="end-match-icon" id="endMatchIcon">üèÜ</div>
                <div class="end-match-title" id="endMatchTitle">Match termin√© !</div>

                <!-- R√©sultat -->
                <div class="end-match-result">
                    <span class="match-final-score" id="endMatchFinalScore">3 ‚Äì 0</span>
                    <span class="match-final-vs" id="endMatchVs">Jen et ses Saints vs Adversaire</span>
                </div>

                <!-- D√©tail des sets -->
                <div class="end-match-sets-detail" id="endMatchSetsDetail"></div>

                <!-- Stats r√©sum√© du match -->
                <div class="end-match-stats-summary" id="endMatchStatsSummary">
                    <div class="match-stats-grid" id="endMatchStatsGrid"></div>
                </div>

                <!-- Actions -->
                <div class="end-match-actions">
                    <button class="end-set-btn cancel" onclick="returnToGameFromEndMatch()">‚Üê Corriger</button>
                    <button class="end-set-btn confirm" onclick="confirmEndMatch()">Cl√¥turer le match ‚úì</button>
                </div>
            </div>
        </div>

        <!-- ==================== MODAL FIN DE CR√âNEAU (temps √©coul√©) ==================== -->
        <div class="end-match-overlay" id="timeEndOverlay" onclick="event.stopPropagation()">
            <div class="end-match-modal" onclick="event.stopPropagation()">
                <div class="end-match-icon">‚è±Ô∏è</div>
                <div class="end-match-title">Fin du cr√©neau</div>
                <div class="time-end-subtitle">Le match se termine sur le score actuel</div>

                <!-- Score sets -->
                <div class="end-match-result">
                    <span class="match-final-score" id="timeEndFinalScore">0 ‚Äì 0</span>
                    <span class="match-final-vs" id="timeEndVs">Jen et ses Saints vs Adversaire</span>
                </div>

                <!-- D√©tail des sets (avec set en cours) -->
                <div class="end-match-sets-detail" id="timeEndSetsDetail"></div>

                <!-- Stats r√©sum√© du match -->
                <div class="end-match-stats-summary">
                    <div class="match-stats-grid" id="timeEndStatsGrid"></div>
                </div>

                <!-- Actions -->
                <div class="end-match-actions">
                    <button class="end-set-btn cancel" onclick="closeTimeEndModal()">‚Üê Annuler</button>
                    <button class="end-set-btn confirm" onclick="confirmTimeEndMatch()">Cl√¥turer le match ‚úì</button>
                </div>
            </div>
        </div>
    </div>

    <!-- YouTube Panel -->
    <div class="youtube-panel" id="youtubePanel">
        <div class="youtube-player-wrapper" id="youtubePlayerWrapper">
            <div id="youtubePlayer"></div>
        </div>
        <div class="youtube-controls" id="youtubeControls">
            <button class="yt-ctrl-btn" onclick="ytRewind()" title="Reculer 2s (‚Üê)">
                <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/></svg>
                ‚àí2s
            </button>
            <button class="yt-ctrl-btn play-pause" onclick="ytTogglePlayPause()" title="Lecture/Pause (Espace)">
                <svg width="18" height="18" fill="currentColor" viewBox="0 0 24 24" id="ytPlayPauseIcon"><path d="M8 5v14l11-7z"/></svg>
            </button>
            <button class="yt-ctrl-btn" onclick="ytForward()" title="Avancer 2s (‚Üí)">
                <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg>
                +2s
            </button>
            <span class="yt-time" id="ytTimeDisplay">0:00 / 0:00</span>
            <div class="yt-volume">
                <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
                <input type="range" class="yt-volume-slider" id="ytVolumeSlider" min="0" max="100" value="100" oninput="ytSetVolume(this.value)">
            </div>
        </div>
    </div>

    </div><!-- /layout-wrapper -->

    <!-- Modal YouTube URL -->
    <div class="yt-url-overlay" id="ytUrlOverlay" onclick="closeYoutubeModal(event)">
        <div class="yt-url-modal" onclick="event.stopPropagation()">
            <div class="yt-url-title">Lien YouTube</div>
            <input type="url" id="ytUrlInput" class="yt-url-input" placeholder="https://www.youtube.com/watch?v=...">
            <div class="yt-url-actions">
                <button class="yt-url-btn cancel" onclick="closeYoutubeModal()">Annuler</button>
                <button class="yt-url-btn confirm" onclick="confirmYoutubeUrl()">Valider</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK (compat CDN) ‚Äî pour upload du match √† la finalisation -->
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
    <script src="firebase-config.js"></script>
    <script src="admin-config.js"></script>
    <script src="firebase-sync.js"></script>

    <script src="storage.js"></script>
    <script src="match-live-helpers.js"></script>
    <script src="match-live-undo.js"></script>
    <script src="match-live-workflow.js?v=18.0"></script>

    <!-- YouTube iframe API (charg√© dynamiquement) -->
    <script>
        // ==================== YOUTUBE PLAYER ====================
        let ytPlayer = null;
        let ytReady = false;
        let ytTimeInterval = null;

        function loadYouTubeAPI() {
            if (window.YT && window.YT.Player) return Promise.resolve();
            return new Promise((resolve) => {
                window.onYouTubeIframeAPIReady = resolve;
                const tag = document.createElement('script');
                tag.src = 'https://www.youtube.com/iframe_api';
                document.head.appendChild(tag);
            });
        }

        // Parse une URL YouTube et retourne { videoId, playlistId, index }
        function parseYouTubeUrl(url) {
            if (!url) return null;
            const result = { videoId: null, playlistId: null, index: 0 };

            // Playlist URL: youtube.com/playlist?list=PLxxx
            const plMatch = url.match(/[?&]list=([a-zA-Z0-9_-]+)/);
            if (plMatch) result.playlistId = plMatch[1];

            // Video index in playlist: &index=N (1-based dans l'URL)
            const idxMatch = url.match(/[?&]index=(\d+)/);
            if (idxMatch) result.index = Math.max(0, parseInt(idxMatch[1]) - 1);

            // Video ID
            const vidPatterns = [
                /(?:youtube\.com\/watch\?.*v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/)([a-zA-Z0-9_-]{11})/,
                /^([a-zA-Z0-9_-]{11})$/
            ];
            for (const pattern of vidPatterns) {
                const match = url.match(pattern);
                if (match) { result.videoId = match[1]; break; }
            }

            // Au moins un des deux doit √™tre pr√©sent
            if (!result.videoId && !result.playlistId) return null;
            return result;
        }

        async function initYouTubePlayer(parsed) {
            if (!parsed) return;

            document.body.classList.remove('classic-mode');
            document.body.classList.add('video-mode');

            await loadYouTubeAPI();

            const playerVars = {
                autoplay: 0,
                controls: 1,
                modestbranding: 1,
                rel: 0,
                fs: 1,
                iv_load_policy: 3,
                disablekb: 1
            };

            // Si playlist, charger via listType/list
            if (parsed.playlistId) {
                playerVars.listType = 'playlist';
                playerVars.list = parsed.playlistId;
                playerVars.index = parsed.index;
            }

            const opts = {
                playerVars: playerVars,
                events: {
                    onReady: onYTPlayerReady,
                    onStateChange: onYTStateChange
                }
            };

            // Si vid√©o individuelle (sans playlist), sp√©cifier videoId
            if (parsed.videoId && !parsed.playlistId) {
                opts.videoId = parsed.videoId;
            }

            ytPlayer = new YT.Player('youtubePlayer', opts);
        }

        function onYTPlayerReady(event) {
            ytReady = true;
            updateYTTimeDisplay();
            ytTimeInterval = setInterval(updateYTTimeDisplay, 500);
        }

        function onYTStateChange(event) {
            const iconEl = document.getElementById('ytPlayPauseIcon');
            if (!iconEl) return;
            if (event.data === YT.PlayerState.PLAYING) {
                iconEl.innerHTML = '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>';
            } else {
                iconEl.innerHTML = '<path d="M8 5v14l11-7z"/>';
            }
        }

        function ytTogglePlayPause() {
            if (!ytPlayer || !ytReady) return;
            const state = ytPlayer.getPlayerState();
            if (state === YT.PlayerState.PLAYING) {
                ytPlayer.pauseVideo();
            } else {
                ytPlayer.playVideo();
            }
        }

        function ytSetVolume(val) {
            if (!ytPlayer || !ytReady) return;
            ytPlayer.setVolume(parseInt(val));
        }

        function ytRewind() {
            if (!ytPlayer || !ytReady) return;
            const t = ytPlayer.getCurrentTime();
            ytPlayer.seekTo(Math.max(0, t - 2), true);
        }

        function ytForward() {
            if (!ytPlayer || !ytReady) return;
            const t = ytPlayer.getCurrentTime();
            ytPlayer.seekTo(t + 2, true);
        }

        function updateYTTimeDisplay() {
            if (!ytPlayer || !ytReady) return;
            const current = ytPlayer.getCurrentTime() || 0;
            const duration = ytPlayer.getDuration() || 0;
            const fmt = (s) => {
                const m = Math.floor(s / 60);
                const sec = Math.floor(s % 60);
                return `${m}:${sec.toString().padStart(2, '0')}`;
            };
            const el = document.getElementById('ytTimeDisplay');
            if (el) el.textContent = `${fmt(current)} / ${fmt(duration)}`;
        }

        function loadYouTubeForCurrentSet() {
            const match = Storage.getCurrentMatch();
            if (!match) return;
            const si = (match.sets?.length || 1) - 1;
            const set = match.sets?.[si];
            const parsed = parseYouTubeUrl(set?.youtubeUrl);

            if (!parsed) {
                document.body.classList.add('classic-mode');
                document.body.classList.remove('video-mode');
                return;
            }

            if (ytPlayer && ytReady) {
                if (parsed.playlistId) {
                    ytPlayer.loadPlaylist({ list: parsed.playlistId, listType: 'playlist', index: parsed.index });
                } else if (parsed.videoId) {
                    ytPlayer.loadVideoById(parsed.videoId);
                }
            } else {
                initYouTubePlayer(parsed);
            }
        }

        // ==================== MODAL YOUTUBE URL ====================
        function openYoutubeModal() {
            const match = Storage.getCurrentMatch();
            const si = (match?.sets?.length || 1) - 1;
            const currentUrl = match?.sets?.[si]?.youtubeUrl || '';
            const input = document.getElementById('ytUrlInput');
            input.value = currentUrl;
            document.getElementById('ytUrlOverlay').classList.add('active');
            input.focus();
            input.select();
        }

        document.getElementById('ytUrlInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') { e.preventDefault(); confirmYoutubeUrl(); }
            if (e.key === 'Escape') { e.preventDefault(); closeYoutubeModal(); }
        });

        function closeYoutubeModal(e) {
            if (e && e.target !== e.currentTarget) return;
            document.getElementById('ytUrlOverlay').classList.remove('active');
        }

        function confirmYoutubeUrl() {
            const url = document.getElementById('ytUrlInput').value.trim();

            // Mettre √† jour la variable en m√©moire ET le localStorage
            currentSet.youtubeUrl = url;
            currentMatch.sets[setIndex] = currentSet;
            Storage.saveCurrentMatch(currentMatch);

            closeYoutubeModal();

            if (url) {
                loadYouTubeForCurrentSet();
            } else {
                document.body.classList.add('classic-mode');
                document.body.classList.remove('video-mode');
            }
        }

        function updateYoutubeButtonState() {
            // Fonction conserv√©e pour coh√©rence d'appel (init + confirm)
        }

        // Raccourcis clavier pour le player YouTube
        document.addEventListener('keydown', function(e) {
            if (!ytPlayer || !ytReady) return;
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    ytTogglePlayPause();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    ytRewind();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    ytForward();
                    break;
            }
        });
    </script>

    <script>
        // ==================== DONN√âES ====================
        const currentMatch = Storage.getCurrentMatch();
        let currentSet = null;
        let setIndex = 0;

        // √âtat du jeu
        let gameState = {
            phase: 'server_selection', // server_selection, serve_start, serve_end, reception, pass, attack_player, attack_type, attack_start, attack_end, result, defense, defense_end, etc.
            servingTeam: 'away', // qui sert actuellement
            attackingTeam: 'home', // qui attaque actuellement
            currentServer: null,
            clicks: [], // positions cliqu√©es
            currentAction: {}, // action en cours
            rally: [], // toutes les actions du point en cours
            homeScore: 0,
            awayScore: 0,
            setEnded: false,
            receptionAutoSelected: false, // true si le r√©ceptionneur a √©t√© auto-s√©lectionn√© via zone pendant serve_end
            passAutoSelected: false, // true si le passeur a √©t√© auto-s√©lectionn√© (r√©ception excellente)
            attackAutoSelected: false, // true si l'attaquant a √©t√© auto-s√©lectionn√© via zone pendant pass
            receptionOpponentClickData: null, // donn√©es du clic terrain adverse pendant reception_end
            overridePlayer: null, // joueur manuellement overrid√© via tag (Phase 2)
            autoSelectedPlayer: null, // joueur auto-s√©lectionn√© par zone/logique (Phase 2)
            overrideTagsTeam: null, // √©quipe des tags override affich√©s (Phase 2)
            context: null // Objet contexte structur√© (V18.0 ‚Äî initialis√© par WorkflowEngine)
        };

        // Statistiques du set (format unifi√© avec historique)
        let setStats = {
            home: {}, // { playerName: { service: {...}, reception: {...}, attack: {...}, relance: {tot, relplus, relminus, frel}, defense: {...}, block: {...} } }
            away: {}
        };

        function _passCtx() { return { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0 }; }

        function initPlayerStats() {
            return {
                service:   { tot: 0, ace: 0, splus: 0, fser: 0, recSumAdv: 0, recCountAdv: 0 },
                reception: { tot: 0, r4: 0, r3: 0, r2: 0, r1: 0, frec: 0 },
                pass: {
                    tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0,
                    passeur: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0,
                        confort: _passCtx(), contraint: _passCtx(), transition: _passCtx() },
                    autre: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0,
                        contraint: _passCtx(), transition: _passCtx() }
                },
                attack:    { tot: 0, attplus: 0, attminus: 0, bp: 0, fatt: 0 },
                relance:   { tot: 0, relplus: 0, relminus: 0, frel: 0 },
                defense:   { tot: 0, defplus: 0, defneutral: 0, defminus: 0, fdef: 0 },
                block:     { tot: 0, blcplus: 0, blcminus: 0, fblc: 0 }
            };
        }

        function initSetStats() {
            setStats = { home: {}, away: {} };
            
            // Initialiser les stats pour les joueurs de l'√©quipe home
            if (currentSet && currentSet.homeLineup) {
                Object.values(currentSet.homeLineup).forEach(name => {
                    if (name) setStats.home[name] = initPlayerStats(name);
                });
            }
            
            // Initialiser les stats pour les joueurs de l'√©quipe adverse
            if (currentSet && currentSet.awayLineup) {
                Object.values(currentSet.awayLineup).forEach(name => {
                    if (name) setStats.away[name] = initPlayerStats(name);
                });
            }
            
            renderStatsTables();
        }

        function renderStatsTables() {
            renderStatsTable('home', 'homeStatsContainer');
            renderStatsTable('away', 'awayStatsContainer');
            renderPassDetailTable();
        }

        function renderStatsTable(team, containerId) {
            const container = document.getElementById(containerId);
            const stats = setStats[team];
            const players = Object.keys(stats);

            if (players.length === 0) {
                container.innerHTML = '';
                return;
            }

            // Helper pour g√©n√©rer une cellule avec couleur conditionnelle
            function cell(val, cls) {
                return '<td class="' + (val > 0 ? cls : '') + '">' + (val || '-') + '</td>';
            }

            // Calculer les totaux
            const totals = {
                service:   { tot: 0, ace: 0, splus: 0, fser: 0, recSumAdv: 0, recCountAdv: 0 },
                reception: { tot: 0, r4: 0, r3: 0, r2: 0, r1: 0, frec: 0 },
                pass:      { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0 },
                attack:    { tot: 0, attplus: 0, attminus: 0, bp: 0, fatt: 0 },
                relance:   { tot: 0, relplus: 0, relminus: 0, frel: 0 },
                defense:   { tot: 0, defplus: 0, defneutral: 0, defminus: 0, fdef: 0 },
                block:     { tot: 0, blcplus: 0, blcminus: 0, fblc: 0 }
            };

            players.forEach(name => {
                const p = stats[name];
                totals.service.tot += p.service.tot;
                totals.service.ace += p.service.ace;
                totals.service.splus += p.service.splus;
                totals.service.fser += p.service.fser;
                totals.service.recSumAdv += p.service.recSumAdv;
                totals.service.recCountAdv += p.service.recCountAdv;
                totals.reception.tot += p.reception.tot;
                totals.reception.r4 += p.reception.r4;
                totals.reception.r3 += p.reception.r3;
                totals.reception.r2 += p.reception.r2;
                totals.reception.r1 += p.reception.r1;
                totals.reception.frec += p.reception.frec;
                totals.pass.tot += p.pass.tot;
                totals.pass.p4 += p.pass.p4;
                totals.pass.p3 += p.pass.p3;
                totals.pass.p2 += p.pass.p2;
                totals.pass.p1 += p.pass.p1;
                totals.pass.fp += p.pass.fp;
                totals.attack.tot += p.attack.tot;
                totals.attack.attplus += p.attack.attplus;
                totals.attack.attminus += p.attack.attminus;
                totals.attack.bp += p.attack.bp;
                totals.attack.fatt += p.attack.fatt;
                totals.relance.tot += p.relance.tot;
                totals.relance.relplus += p.relance.relplus;
                totals.relance.relminus += p.relance.relminus;
                totals.relance.frel += p.relance.frel;
                totals.defense.tot += p.defense.tot;
                totals.defense.defplus += p.defense.defplus;
                totals.defense.defneutral += p.defense.defneutral;
                totals.defense.defminus += p.defense.defminus;
                totals.defense.fdef += p.defense.fdef;
                totals.block.tot += p.block.tot;
                totals.block.blcplus += p.block.blcplus;
                totals.block.blcminus += p.block.blcminus;
                totals.block.fblc += p.block.fblc;
            });

            let html = '';

            // ===== COLONNE DES NOMS =====
            html += '<div class="stats-players-col">' +
                '<div class="player-header">Joueur</div>' +
                '<div class="player-subheader"></div>';
            players.forEach(name => {
                html += '<div class="player-name">' + name + '</div>';
            });
            html += '<div class="player-name total-row">Total</div></div>';

            // Helper pour calculer la moyenne service (Moy)
            // recCountAdv inclut les r√©ceptions sur ace (note 0)
            function srvMoy(p) {
                const count = p.service.recCountAdv;
                if (count === 0) return '-';
                const moy = p.service.recSumAdv / count;
                return moy.toFixed(1);
            }
            function srvMoyClass(p) {
                const count = p.service.recCountAdv;
                if (count === 0) return '';
                const moy = p.service.recSumAdv / count;
                if (moy <= 1.5) return 'positive';
                if (moy >= 3.0) return 'negative';
                return '';
            }

            // ===== SERVICE =====
            html += '<div class="stat-table-card">' +
                '<div class="stat-table-header service">Service</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th>Tot</th><th>Ace</th><th>S+</th><th>FS</th><th>Moy</th>' +
                '</tr></thead><tbody>';
            players.forEach(name => {
                const p = stats[name];
                html += '<tr>' +
                    '<td>' + (p.service.tot || '-') + '</td>' +
                    cell(p.service.ace, 'positive') +
                    cell(p.service.splus, 'positive') +
                    cell(p.service.fser, 'negative') +
                    '<td class="' + srvMoyClass(p) + '">' + srvMoy(p) + '</td>' +
                '</tr>';
            });
            html += '<tr class="total-row">' +
                '<td>' + (totals.service.tot || '-') + '</td>' +
                cell(totals.service.ace, 'positive') +
                cell(totals.service.splus, 'positive') +
                cell(totals.service.fser, 'negative') +
                '<td class="' + srvMoyClass({ service: totals.service }) + '">' + srvMoy({ service: totals.service }) + '</td>' +
            '</tr></tbody></table></div>';

            // ===== R√âCEPTION =====
            html += '<div class="stat-table-card">' +
                '<div class="stat-table-header reception">R√©ception</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th>Tot</th><th>R4</th><th>R3</th><th>R2</th><th>R1</th><th>FR</th>' +
                '</tr></thead><tbody>';
            players.forEach(name => {
                const p = stats[name];
                html += '<tr>' +
                    '<td>' + (p.reception.tot || '-') + '</td>' +
                    cell(p.reception.r4, 'positive') +
                    cell(p.reception.r3, 'positive') +
                    cell(p.reception.r2, 'neutral') +
                    cell(p.reception.r1, 'negative') +
                    cell(p.reception.frec, 'negative') +
                '</tr>';
            });
            html += '<tr class="total-row">' +
                '<td>' + (totals.reception.tot || '-') + '</td>' +
                cell(totals.reception.r4, 'positive') +
                cell(totals.reception.r3, 'positive') +
                cell(totals.reception.r2, 'neutral') +
                cell(totals.reception.r1, 'negative') +
                cell(totals.reception.frec, 'negative') +
            '</tr></tbody></table></div>';

            // ===== PASSE =====
            html += '<div class="stat-table-card">' +
                '<div class="stat-table-header passe">Passe</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th>Tot</th><th>P4</th><th>P3</th><th>P2</th><th>P1</th><th>FP</th>' +
                '</tr></thead><tbody>';
            players.forEach(name => {
                const p = stats[name];
                html += '<tr>' +
                    '<td>' + (p.pass.tot || '-') + '</td>' +
                    cell(p.pass.p4, 'positive') +
                    cell(p.pass.p3, 'positive') +
                    cell(p.pass.p2, 'neutral') +
                    cell(p.pass.p1, 'negative') +
                    cell(p.pass.fp, 'negative') +
                '</tr>';
            });
            html += '<tr class="total-row">' +
                '<td>' + (totals.pass.tot || '-') + '</td>' +
                cell(totals.pass.p4, 'positive') +
                cell(totals.pass.p3, 'positive') +
                cell(totals.pass.p2, 'neutral') +
                cell(totals.pass.p1, 'negative') +
                cell(totals.pass.fp, 'negative') +
            '</tr></tbody></table></div>';

            // ===== ATTAQUE =====
            html += '<div class="stat-table-card">' +
                '<div class="stat-table-header attack">Attaque</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th>Tot</th><th>A+</th><th>A-</th><th>BP</th><th>FA</th>' +
                '</tr></thead><tbody>';
            players.forEach(name => {
                const p = stats[name];
                html += '<tr>' +
                    '<td>' + (p.attack.tot || '-') + '</td>' +
                    cell(p.attack.attplus, 'positive') +
                    cell(p.attack.attminus, 'neutral') +
                    cell(p.attack.bp, 'negative') +
                    cell(p.attack.fatt, 'negative') +
                '</tr>';
            });
            html += '<tr class="total-row">' +
                '<td>' + (totals.attack.tot || '-') + '</td>' +
                cell(totals.attack.attplus, 'positive') +
                cell(totals.attack.attminus, 'neutral') +
                cell(totals.attack.bp, 'negative') +
                cell(totals.attack.fatt, 'negative') +
            '</tr></tbody></table></div>';

            // ===== RELANCE =====
            html += '<div class="stat-table-card">' +
                '<div class="stat-table-header relance">Relance</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th>Tot</th><th>R+</th><th>R-</th><th>FRel</th>' +
                '</tr></thead><tbody>';
            players.forEach(name => {
                const p = stats[name];
                html += '<tr>' +
                    '<td>' + (p.relance.tot || '-') + '</td>' +
                    cell(p.relance.relplus, 'positive') +
                    cell(p.relance.relminus, 'neutral') +
                    cell(p.relance.frel, 'negative') +
                '</tr>';
            });
            html += '<tr class="total-row">' +
                '<td>' + (totals.relance.tot || '-') + '</td>' +
                cell(totals.relance.relplus, 'positive') +
                cell(totals.relance.relminus, 'neutral') +
                cell(totals.relance.frel, 'negative') +
            '</tr></tbody></table></div>';

            // ===== D√âFENSE (V20.15 : D+/D/D-/FD) =====
            html += '<div class="stat-table-card">' +
                '<div class="stat-table-header defense">D√©fense</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th>Tot</th><th>D+</th><th>D</th><th>D-</th><th>FD</th>' +
                '</tr></thead><tbody>';
            players.forEach(name => {
                const p = stats[name];
                html += '<tr>' +
                    '<td>' + (p.defense.tot || '-') + '</td>' +
                    cell(p.defense.defplus, 'positive') +
                    cell(p.defense.defneutral, 'neutral') +
                    cell(p.defense.defminus, 'negative') +
                    cell(p.defense.fdef, 'negative') +
                '</tr>';
            });
            html += '<tr class="total-row">' +
                '<td>' + (totals.defense.tot || '-') + '</td>' +
                cell(totals.defense.defplus, 'positive') +
                cell(totals.defense.defneutral, 'neutral') +
                cell(totals.defense.defminus, 'negative') +
                cell(totals.defense.fdef, 'negative') +
            '</tr></tbody></table></div>';

            // ===== BLOC =====
            html += '<div class="stat-table-card">' +
                '<div class="stat-table-header block">Bloc</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th>Tot</th><th>B+</th><th>B-</th><th>FB</th>' +
                '</tr></thead><tbody>';
            players.forEach(name => {
                const p = stats[name];
                html += '<tr>' +
                    '<td>' + (p.block.tot || '-') + '</td>' +
                    cell(p.block.blcplus, 'positive') +
                    cell(p.block.blcminus, 'neutral') +
                    cell(p.block.fblc, 'negative') +
                '</tr>';
            });
            html += '<tr class="total-row">' +
                '<td>' + (totals.block.tot || '-') + '</td>' +
                cell(totals.block.blcplus, 'positive') +
                cell(totals.block.blcminus, 'neutral') +
                cell(totals.block.fblc, 'negative') +
            '</tr></tbody></table></div>';

            container.innerHTML = html;
        }

        // V19.2 : Tableau passe detaillee (ventilation Passeur/Autre + contexte)
        function renderPassDetailTable() {
            const container = document.getElementById('passDetailContainer');
            if (!container) return;

            // Agreger les stats pass de tous les joueurs home
            const homeStats = setStats.home;
            const players = Object.keys(homeStats);
            if (players.length === 0) { container.innerHTML = ''; return; }

            // Agreger passeur et autre sur tous les joueurs
            const agg = {
                passeur: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0,
                    confort: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0 },
                    contraint: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0 },
                    transition: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0 } },
                autre: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0,
                    contraint: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0 },
                    transition: { tot: 0, p4: 0, p3: 0, p2: 0, p1: 0, fp: 0 } }
            };
            const keys = ['tot', 'p4', 'p3', 'p2', 'p1', 'fp'];
            players.forEach(function(name) {
                const p = homeStats[name].pass;
                if (!p) return;
                ['passeur', 'autre'].forEach(function(pType) {
                    if (!p[pType]) return;
                    keys.forEach(function(k) { agg[pType][k] += (p[pType][k] || 0); });
                    var ctxs = pType === 'passeur' ? ['confort', 'contraint', 'transition'] : ['contraint', 'transition'];
                    ctxs.forEach(function(ctx) {
                        if (!p[pType][ctx]) return;
                        keys.forEach(function(k) { agg[pType][ctx][k] += (p[pType][ctx][k] || 0); });
                    });
                });
            });

            var totalPasses = (agg.passeur.tot || 0) + (agg.autre.tot || 0);
            if (totalPasses === 0) { container.innerHTML = ''; return; }

            function cell(val, cls) {
                return '<td class="' + (val > 0 ? cls : '') + '">' + (val || '-') + '</td>';
            }
            function passRow(label, data, cls) {
                return '<tr class="' + cls + '">' +
                    '<td>' + label + '</td>' +
                    '<td>' + (data.tot || '-') + '</td>' +
                    cell(data.p4, 'positive') +
                    cell(data.p3, 'positive') +
                    cell(data.p2, 'neutral') +
                    cell(data.p1, 'negative') +
                    cell(data.fp, 'negative') +
                '</tr>';
            }

            var html = '<div class="stat-table-card pass-detail-card">' +
                '<div class="stat-table-header passe">Passe d\u00e9taill\u00e9e</div>' +
                '<table class="detail-stats-table"><thead><tr>' +
                '<th></th><th>Tot</th><th>P4</th><th>P3</th><th>P2</th><th>P1</th><th>FP</th>' +
                '</tr></thead><tbody>';

            // Passeur
            if (agg.passeur.tot > 0) {
                html += passRow('Passeur', agg.passeur, 'pass-type-row');
                if (agg.passeur.confort.tot > 0) html += passRow('\u2514 Confort', agg.passeur.confort, 'pass-ctx-row');
                if (agg.passeur.contraint.tot > 0) html += passRow('\u2514 Contraint', agg.passeur.contraint, 'pass-ctx-row');
                if (agg.passeur.transition.tot > 0) html += passRow('\u2514 Transition', agg.passeur.transition, 'pass-ctx-row');
            }
            // Autres
            if (agg.autre.tot > 0) {
                html += passRow('Autres', agg.autre, 'pass-type-row');
                if (agg.autre.contraint.tot > 0) html += passRow('\u2514 Contraint', agg.autre.contraint, 'pass-ctx-row');
                if (agg.autre.transition.tot > 0) html += passRow('\u2514 Transition', agg.autre.transition, 'pass-ctx-row');
            }

            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

        // Configuration cam√©ra (qui est en bas)
        let cameraSide = 'home'; // 'home' = Jen en bas, 'away' = adversaire en bas

        // ==================== V18.0 BRIDGE FUNCTIONS ====================
        // Undo = WorkflowEngine.popState()
        function undoLastAction() {
            WorkflowEngine.popState();
        }

        // Cancel point : en d√©but de point ‚Üí undo dernier point valid√©, sinon ‚Üí annuler le rally en cours
        function cancelPoint() {
            if (gameState.phase === 'server_selection' ||
                (gameState.phase === 'serve_start' && gameState.currentServer && gameState.rally.length === 0)) {
                if (currentSet.points && currentSet.points.length > 0) {
                    showUndoPointModal();
                } else {
                    alert('Aucun point √† annuler.');
                }
                return;
            }
            // En cours de rally ‚Üí annuler le rally complet
            if (!confirm('Annuler ce point et recommencer ?')) return;
            WorkflowEngine._resetRallyState();
            WorkflowEngine.clearStack();
            gameState.currentServer = null;
            WorkflowEngine.transition('server_selection');
        }

        // Bridge pour les anciennes fonctions appel√©es par les handlers HTML
        // Ces fonctions ne sont plus directement utilis√©es mais certains onclick les r√©f√©rencent encore
        function handleAceFromReception() { WorkflowEngine.handleButton('ace'); }
        function handleReceptionFault() { WorkflowEngine.handleButton('receptionFault'); }
        function handleReceptionFaultFromTags() { WorkflowEngine.handleButton('receptionFault'); }

        // ==================== INITIALISATION ====================
        function init() {
            // V19.1 : charger les grilles de passe calibr√©es depuis localStorage
            if (typeof loadPassGridsFromStorage === 'function') loadPassGridsFromStorage();

            // V19.23 : Tenter de charger les grilles depuis Firebase (async, non-bloquant)
            // Firebase fait autorite si les grilles locales sont vides/default
            // Seuil : v > 2 (P3/P4) = donnees reellement calibrees
            if (typeof FirebaseSync !== 'undefined' && FirebaseSync.isConfigured()) {
                FirebaseSync.getPassGrids().then(remoteGrids => {
                    if (!remoteGrids) return;
                    const hasRemoteData = Object.values(remoteGrids).some(zone =>
                        zone && Object.values(zone).some(ctx =>
                            Array.isArray(ctx) && ctx.some(row =>
                                Array.isArray(row) && row.some(v => v > 2)
                            )
                        )
                    );
                    if (!hasRemoteData) return;
                    const localRaw = localStorage.getItem('volleyball_pass_grids');
                    let hasLocalData = false;
                    if (localRaw) {
                        try {
                            const local = JSON.parse(localRaw);
                            hasLocalData = Object.values(local).some(zone =>
                                zone && Object.values(zone).some(ctx =>
                                    Array.isArray(ctx) && ctx.some(row =>
                                        Array.isArray(row) && row.some(v => v > 2)
                                    )
                                )
                            );
                        } catch(e) {}
                    }
                    if (!hasLocalData) {
                        localStorage.setItem('volleyball_pass_grids', JSON.stringify(remoteGrids));
                        if (typeof loadPassGridsFromStorage === 'function') loadPassGridsFromStorage();
                        console.log('[V19.23] Grilles de passe restaur√©es depuis Firebase');
                    }
                }).catch(() => {});
            }

            if (!currentMatch) {
                window.location.href = 'nouveau-match.html';
                return;
            }

            // R√©cup√©rer le set actuel
            setIndex = (currentMatch.sets?.length || 1) - 1;
            currentSet = currentMatch.sets?.[setIndex];

            if (!currentSet) {
                window.location.href = 'match-set-composition.html';
                return;
            }

            // Defaults bloqueur (backward compat)
            if (!currentSet.homeBlockerRight) currentSet.homeBlockerRight = 'Pointu';
            if (!currentSet.awayBlockerRight) currentSet.awayBlockerRight = 'Pointu';
            // Migration : ancien format 'Pointu'/'Passeur' ‚Üí nouveau format 'right'/'R4'
            if (currentSet.homePrimaryBlocker === 'Pointu' || currentSet.homePrimaryBlocker === 'Passeur') {
                currentSet.homePrimaryBlocker = 'right';
            }
            if (currentSet.awayPrimaryBlocker === 'Pointu' || currentSet.awayPrimaryBlocker === 'Passeur') {
                currentSet.awayPrimaryBlocker = 'right';
            }
            if (!currentSet.homePrimaryBlocker) currentSet.homePrimaryBlocker = 'right';
            if (!currentSet.awayPrimaryBlocker) currentSet.awayPrimaryBlocker = 'right';
            gameState.homeScore = currentSet.homeScore || 0;
            gameState.awayScore = currentSet.awayScore || 0;

            // Sauvegarder le score initial (bonus) si pas encore fait
            if (currentSet.initialHomeScore === undefined) {
                currentSet.initialHomeScore = gameState.homeScore;
                currentSet.initialAwayScore = gameState.awayScore;
            }

            // Set frais (aucun point), film√©, ET pas encore confirm√© ‚Üí afficher overlay pr√©-match
            const isFilmedSet = currentSet.isFilmed !== false; // par d√©faut film√©
            const isFreshSet = isFilmedSet && (!currentSet.points || currentSet.points.length === 0) && !currentSet.preMatchConfirmed;
            if (isFreshSet) {
                showPreMatchOverlay();
                // On ne d√©marre PAS le workflow ‚Äî on attend confirmPreMatch()
            } else {
                // Configuration d√©j√† d√©finie (reprise ou confirm√©e)
                cameraSide = currentSet.cameraSide || 'home';
                gameState.servingTeam = currentSet.servingTeam || 'away';
                startMatch();
            }

            // Mettre √† jour l'affichage de base (score header, labels)
            updateLabels();
            updateScore();

            // Mettre √† jour les titres des tableaux de stats
            const opponent = currentMatch.opponent || 'Adversaire';
            document.getElementById('homeTeamStatsTitle').textContent = 'Jen et ses Saints';
            document.getElementById('awayTeamStatsTitle').textContent = opponent;

            // Initialiser le lecteur YouTube si URL disponible
            loadYouTubeForCurrentSet();
            updateYoutubeButtonState();
        }

        // D√©marrer le match (apr√®s confirmation pr√©-match ou en reprise)
        function startMatch() {
            updatePhase();
            // V18.0 : WorkflowEngine remplace renderServerSelection() + setupCourtListeners()
            WorkflowEngine.start();

            // Initialiser les statistiques du set
            initSetStats();

            // Reprise d'un set en cours : recalculer depuis les points
            if (currentSet.points && currentSet.points.length > 0) {
                const lastPt = currentSet.points[currentSet.points.length - 1];
                gameState.homeScore = lastPt.homeScore;
                gameState.awayScore = lastPt.awayScore;
                const prevHome = currentSet.points.length >= 2
                    ? currentSet.points[currentSet.points.length - 2].homeScore
                    : (currentSet.initialHomeScore || 0);
                if (lastPt.homeScore > prevHome) {
                    gameState.servingTeam = 'home';
                } else {
                    gameState.servingTeam = 'away';
                }
                gameState.currentServer = null;
                updateScore();
                recalculateAllStats();
            }
        }

        // ==================== PRE-MATCH OVERLAY ====================
        function showPreMatchOverlay() {
            const overlay = document.getElementById('preMatchOverlay');
            const opponent = currentMatch.opponent || 'Adversaire';

            // Labels adversaire
            document.getElementById('preMatchCameraAway').textContent = opponent;
            document.getElementById('preMatchServingAway').textContent = opponent;

            // Pr√©-s√©lection : valeurs du set (auto-flip entre sets) ou d√©fauts
            const defaultCamera = currentSet.cameraSide || 'home';
            const defaultServing = currentSet.servingTeam || 'away';
            preMatchSelect('camera', defaultCamera);
            preMatchSelect('serving', defaultServing);

            overlay.classList.add('active');

            // Masquer les √©l√©ments du workflow (phase indicator, tags)
            document.getElementById('phaseIndicator').style.display = 'none';
            document.getElementById('tagsContainer').style.display = 'none';
        }

        function preMatchSelect(type, value) {
            const toggleId = type === 'camera' ? 'preMatchCameraToggle' : 'preMatchServingToggle';
            const toggle = document.getElementById(toggleId);
            toggle.querySelectorAll('.pre-match-option').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.value === value);
            });
        }

        function confirmPreMatch() {
            const cameraToggle = document.getElementById('preMatchCameraToggle');
            const servingToggle = document.getElementById('preMatchServingToggle');

            const selectedCamera = cameraToggle.querySelector('.pre-match-option.selected')?.dataset.value || 'home';
            const selectedServing = servingToggle.querySelector('.pre-match-option.selected')?.dataset.value || 'away';

            // Appliquer au set et au gameState
            currentSet.cameraSide = selectedCamera;
            currentSet.servingTeam = selectedServing;
            currentSet.preMatchConfirmed = true;
            cameraSide = selectedCamera;
            gameState.servingTeam = selectedServing;

            // Sauvegarder
            Storage.saveCurrentMatch(currentMatch);

            // Masquer l'overlay, r√©afficher le workflow
            document.getElementById('preMatchOverlay').classList.remove('active');
            document.getElementById('phaseIndicator').style.display = '';
            document.getElementById('tagsContainer').style.display = '';

            // Mettre √† jour les labels du terrain (cam√©ra d√©termine qui est en haut/bas)
            updateLabels();
            updateScore();

            // D√©marrer le workflow
            startMatch();
        }

        // ==================== INITIALISATION (suite) ====================
        // (vide ‚Äî la logique de reprise est dans startMatch via le bloc existant dans init)

        // ==================== AFFICHAGE ====================
        function updateLabels() {
            const opponent = currentMatch.opponent || 'Adversaire';
            
            document.getElementById('awayTeamName').textContent = opponent;
            document.getElementById('setIndicator').textContent = `SET ${setIndex + 1}`;

            // Labels du terrain selon c√¥t√© cam√©ra
            if (cameraSide === 'home') {
                document.getElementById('topTeamLabel').textContent = opponent;
                document.getElementById('bottomTeamLabel').textContent = 'Jen et ses Saints';
            } else {
                document.getElementById('topTeamLabel').textContent = 'Jen et ses Saints';
                document.getElementById('bottomTeamLabel').textContent = opponent;
            }
        }

        function updateScore() {
            document.getElementById('homePoints').textContent = gameState.homeScore;
            document.getElementById('awayPoints').textContent = gameState.awayScore;

            const homeDisplay = document.getElementById('homeScoreDisplay');
            const awayDisplay = document.getElementById('awayScoreDisplay');

            if (gameState.servingTeam === 'home') {
                homeDisplay.style.opacity = '1';
                awayDisplay.style.opacity = '0.6';
            } else {
                homeDisplay.style.opacity = '0.6';
                awayDisplay.style.opacity = '1';
            }
        }

        function updatePhase() {
            const phaseEl = document.getElementById('phaseIndicator');
            const phases = {
                'server_selection': '<span class="highlight">Service</span> ‚Äî S√©lectionnez le serveur',
                'serve_start': '<span class="highlight">Service</span> ‚Äî Cliquez le point de d√©part',
                'serve_end': '<span class="highlight">Service</span> ‚Äî Cliquez le point d\'arriv√©e',
                'reception': '<span class="highlight">R√©ception</span> ‚Äî S√©lectionnez le r√©ceptionneur',
                'reception_end': '<span class="highlight">R√©ception</span> ‚Äî _RECEIVER_ Cliquez o√π arrive la r√©ception',
                'reception_fault_trajectory': '<span class="highlight">Faute r√©ception</span> ‚Äî Cliquez o√π va la balle',
                'reception_opponent_choice': '<span class="highlight">R√©ception</span> ‚Äî Que se passe-t-il ?',
                'reception_net_choice': '<span class="highlight">R√©ception filet</span> ‚Äî Att. directe ou cliquez le terrain = block',
                'reception_net_block_player': '<span class="highlight">Block au filet</span> ‚Äî Qui block ?',
                'reception_net_block_end': '<span class="highlight">Block au filet</span> ‚Äî Cliquez o√π arrive le block',
                'pass_net_choice': '<span class="highlight">Passe filet</span> ‚Äî Att. directe ou cliquez le terrain = block',
                'pass_net_block_player': '<span class="highlight">Block au filet</span> ‚Äî Qui block ?',
                'pass_net_block_end': '<span class="highlight">Block au filet</span> ‚Äî Cliquez o√π arrive le block',
                'attack_net_choice': '<span class="highlight">Attaque filet</span> ‚Äî Faute ou cliquez le terrain = block',
                'attack_net_block_player': '<span class="highlight">Block au filet</span> ‚Äî Qui block ?',
                'attack_net_block_end': '<span class="highlight">Block au filet</span> ‚Äî Cliquez o√π arrive le block',
                'bloc_out_player': '<span class="highlight">Bloc out</span> ‚Äî Qui a bloqu√© ?',
                'bloc_out_trajectory': '<span class="highlight">Bloc out</span> ‚Äî Cliquez o√π va la balle',
                'direct_return_end': '<span class="highlight">Retour direct</span> ‚Äî Cliquez o√π arrive le retour',
                'defense_direct_return_choice': '<span class="highlight">D√©fense</span> ‚Äî Retour direct, que se passe-t-il ?',
                'pass': '<span class="highlight">Passe</span> ‚Äî Cliquez le terrain (= _AUTOPASS_) ou s√©lectionnez un joueur',
                'pass_end': '<span class="highlight">Passe</span> ‚Äî _PASSER_ Cliquez o√π arrive la passe',
                'pass_direct_return_choice': '<span class="highlight">Passe</span> ‚Äî Passe chez l\'adversaire, que se passe-t-il ?',
                'attack_player': '<span class="highlight">Attaque</span> ‚Äî Cliquez le terrain ou s√©lectionnez un joueur',
                'attack_type': '<span class="highlight">Attaque</span> ‚Äî _ATTACKER_ Type ou cliquez = <span class="phase-smash-badge">üí™ Smash</span>',
                'attack_end': '<span class="highlight">Attaque</span> ‚Äî _ATTACKER_ Cliquez o√π arrive l\'attaque',
                'result': '<span class="highlight">R√©sultat</span> ‚Äî Cliquez le terrain = <span class="phase-defended-badge">üõ°Ô∏è D√©fendu</span>',
                'block_end': '<span class="highlight">Block</span> ‚Äî Cliquez o√π arrive le block',
                'defense': '<span class="highlight">D√©fense</span> ‚Äî S√©lectionnez le d√©fenseur',
                'defense_end': '<span class="highlight">D√©fense</span> ‚Äî _DEFENDER_ Cliquez o√π arrive la d√©fense',
                'defense_fault_trajectory': '<span class="highlight">Faute d√©fense</span> ‚Äî Cliquez o√π va la balle',
                'ace_reception': '<span class="highlight">Ace !</span> ‚Äî Qui a rat√© la r√©ception ?',
                'net_block_player': '<span class="highlight">Block au filet</span> ‚Äî Qui block ?',
                'net_block_end': '<span class="highlight">Block au filet</span> ‚Äî Cliquez o√π arrive le block'
            };
            let phaseText = phases[gameState.phase] || '';

            // Helper : g√©n√®re un badge joueur color√© par r√¥le
            function playerBadge(playerName, role) {
                const color = ROLE_COLORS[role] || '#8b5cf6';
                return '<span class="phase-player-badge" style="background:' + color + '">' + playerName + '</span> ‚Äî';
            }

            // Injecter le nom de l'attaquant dans le bandeau
            if (phaseText.includes('_ATTACKER_')) {
                const player = gameState.currentAction && gameState.currentAction.player;
                const role = gameState.currentAction && gameState.currentAction.role;
                phaseText = phaseText.replace('_ATTACKER_', player ? playerBadge(player, role) : '');
            }

            // Injecter le nom du d√©fenseur dans le bandeau
            if (phaseText.includes('_DEFENDER_')) {
                const player = gameState.currentAction && gameState.currentAction.player;
                const role = gameState.currentAction && gameState.currentAction.role;
                phaseText = phaseText.replace('_DEFENDER_', player ? playerBadge(player, role) : '');
            }

            // Injecter le nom du r√©ceptionneur dans le bandeau
            if (phaseText.includes('_RECEIVER_')) {
                const player = gameState.currentAction && gameState.currentAction.player;
                const role = gameState.currentAction && gameState.currentAction.role;
                phaseText = phaseText.replace('_RECEIVER_', player ? playerBadge(player, role) : '');
            }

            // Injecter le nom du passeur dans le bandeau
            if (phaseText.includes('_PASSER_')) {
                const player = gameState.currentAction && gameState.currentAction.player;
                const role = gameState.currentAction && gameState.currentAction.role;
                phaseText = phaseText.replace('_PASSER_', player ? playerBadge(player, role) : '');
            }

            // Injecter le joueur auto-s√©lectionn√© pour la passe (toujours le Passeur)
            if (phaseText.includes('_AUTOPASS_')) {
                const team = gameState.attackingTeam;
                const passeur = getPlayerByRole(team, 'Passeur');
                const autoPassName = passeur || 'Passeur';
                const autoPassRole = 'Passeur';
                phaseText = phaseText.replace('_AUTOPASS_', '<span class="phase-player-badge" style="background:' + (ROLE_COLORS[autoPassRole] || '#8b5cf6') + '">' + autoPassName + '</span>');
            }

            phaseEl.innerHTML = phaseText;

            // Afficher le bouton Changement pendant la s√©lection du serveur ou au d√©but du service
            const btnSub = document.getElementById('btnSubstitute');
            if (btnSub) {
                btnSub.style.display = (gameState.phase === 'server_selection' || gameState.phase === 'serve_start') ? 'flex' : 'none';
            }
            
            // Afficher le bouton Fin du Set pendant la s√©lection du serveur ou au d√©but du service
            const btnEnd = document.getElementById('btnEndSet');
            if (btnEnd) {
                btnEnd.style.display = (gameState.phase === 'server_selection' || gameState.phase === 'serve_start') ? 'flex' : 'none';
            }
        }

        // ==================== S√âLECTION SERVEUR ====================
        function renderServerSelection() {
            const container = document.getElementById('serverTags');
            const servingTeam = gameState.servingTeam;
            
            let players = [];
            if (servingTeam === 'home') {
                players = currentMatch.players || [];
            } else {
                players = (currentMatch.adversePlayers || []).map(name => ({ prenom: name }));
            }

            // Filtrer pour n'avoir que les 4 joueurs sur le terrain
            const lineup = servingTeam === 'home' 
                ? currentSet.homeLineup 
                : currentSet.awayLineup;
            
            const onCourtPlayers = Object.values(lineup).filter(p => p !== null);

            container.innerHTML = onCourtPlayers.map((playerName, idx) => `
                <button class="player-tag ${servingTeam}" onclick="selectServer('${playerName}')">
                    ${playerName}
                </button>
            `).join('');

            showSection('serverSelection');
        }

        function selectServer(playerName) {
            gameState.currentServer = playerName;
            gameState.currentAction = {
                type: 'service',
                player: playerName,
                team: gameState.servingTeam,
                role: getPlayerRole(gameState.servingTeam, playerName)
            };
            gameState.phase = 'serve_start';
            updatePhase();
            hideAllSections();
            highlightCourt(null);
            showServiceZone();
        }

        function showServerContinueBanner() {
            const banner = document.getElementById('serverContinue');
            const bannerInner = document.getElementById('serverContinueBanner');
            const nameSpan = document.getElementById('serverContinueName');
            
            nameSpan.textContent = gameState.currentServer;
            
            // Style selon l'√©quipe
            if (gameState.servingTeam === 'away') {
                bannerInner.classList.add('away');
            } else {
                bannerInner.classList.remove('away');
            }
            
            banner.classList.remove('hidden');
        }

        // ==================== GESTION DU TERRAIN ====================
        function setupCourtListeners() {
            const courtTop = document.getElementById('courtTop');
            const courtBottom = document.getElementById('courtBottom');
            const serviceZoneTop = document.getElementById('serviceZoneTop');
            const serviceZoneBottom = document.getElementById('serviceZoneBottom');
            const outArea = document.getElementById('outArea');

            courtTop.addEventListener('click', (e) => handleCourtClick(e, 'top'));
            courtBottom.addEventListener('click', (e) => handleCourtClick(e, 'bottom'));
            serviceZoneTop.addEventListener('click', (e) => handleServiceZoneClick(e, 'top'));
            serviceZoneBottom.addEventListener('click', (e) => handleServiceZoneClick(e, 'bottom'));
            outArea.addEventListener('click', (e) => handleOutAreaClick(e));
            
            // Zone filet cliquable
            const netClickZone = document.getElementById('netClickZone');
            netClickZone.addEventListener('click', (e) => {
                e.stopPropagation();
                const zoneHalf = e.target.closest('.net-zone-half');
                if (zoneHalf && netClickZone.classList.contains('split')) {
                    // Mode split : auto-s√©lection du bloqueur
                    gameState.autoSelectedBlocker = zoneHalf.dataset.player;
                    gameState.autoSelectedBlockerRole = zoneHalf.dataset.role;
                }
                handleNetZoneClick(e);
            });
            
            // Position zones click handlers (auto-select receiver)
            document.querySelectorAll('.position-zone').forEach(zone => {
                zone.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const player = e.currentTarget.dataset.player;
                    if (!player) return;
                    
                    if (gameState.phase === 'ace_reception') {
                        // Clic zone pendant ace_reception: auto-s√©lection du r√©ceptionneur qui a rat√©
                        handleAceReceptionPlayer(player);
                        return;
                    } else if (gameState.phase === 'reception') {
                        // S√©lection du r√©ceptionneur via zone (ou override si tag cliqu√©)
                        const effectivePlayer = getEffectivePlayer() || player;
                        hidePositionZones();
                        selectReceptioner(effectivePlayer);
                    } else if (gameState.phase === 'serve_end') {
                        // Clic dans une zone pendant serve_end
                        const courtHalf = e.currentTarget.closest('.court-half');
                        const rect = courtHalf.getBoundingClientRect();
                        const x = ((e.clientX - rect.left) / rect.width) * 100;
                        const y = ((e.clientY - rect.top) / rect.height) * 100;
                        const courtSide = courtHalf.id === 'courtTop' ? 'top' : 'bottom';
                        const clickData = { x, y, courtSide };

                        // Auto-s√©lection directe du r√©ceptionneur
                        // Enregistrer le point d'arriv√©e du service
                        gameState.currentAction.endPos = clickData;
                        addMarker(clickData, 'service');
                        
                        // D√©sactiver les zones serve_end
                        document.getElementById('outArea').classList.remove('active');
                        deactivateNetZone();
                        hidePositionZones();
                        
                        // Pousser l'action de service dans le rally
                        gameState.rally.push({ ...gameState.currentAction });
                        
                        // Configurer la r√©ception auto-s√©lectionn√©e
                        const receivingTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
                        gameState.attackingTeam = receivingTeam;
                        gameState.receptionAutoSelected = true;
                        
                        // Auto-s√©lection du r√©ceptionneur (passe directement en reception_end)
                        selectReceptioner(player);
                    }
                });
            });

            // Attack zones click handlers (auto-select attacker)
            document.querySelectorAll('.attack-zone').forEach(zone => {
                zone.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const attackerPlayer = e.currentTarget.dataset.player;
                    if (!attackerPlayer) return;
                    if (e.currentTarget.classList.contains('disabled')) return;

                    if (gameState.phase === 'pass') {
                        // Clic zone pendant passe = auto-passe (ou override) + auto-attaquant en 1 clic
                        const team = gameState.attackingTeam;
                        const passeur = getPlayerByRole(team, 'Passeur');
                        if (!passeur) return;

                        // D√©terminer le passeur : override > Passeur par d√©faut
                        const effectiveOverride = getEffectivePlayer();
                        const selectedPasser = effectiveOverride || passeur;
                        const selectedRole = getPlayerRole(team, selectedPasser);

                        // Calculer la position du clic sur le terrain
                        const courtHalf = e.currentTarget.closest('.court-half');
                        const rect = courtHalf.getBoundingClientRect();
                        const x = ((e.clientX - rect.left) / rect.width) * 100;
                        const y = ((e.clientY - rect.top) / rect.height) * 100;
                        const courtSide = courtHalf.id === 'courtTop' ? 'top' : 'bottom';
                        const clickData = { x, y, courtSide };

                        // Enregistrer la passe (m√™me logique que handlePassCourtClick)
                        gameState.passAutoSelected = true;
                        gameState.attackAutoSelected = true;
                        gameState.currentAction = {
                            type: 'pass',
                            player: selectedPasser,
                            team: team,
                            role: selectedRole,
                            endPos: clickData
                        };
                        const lastActionForPassStart = gameState.rally[gameState.rally.length - 1];
                        if (lastActionForPassStart && lastActionForPassStart.endPos) {
                            gameState.currentAction.startPos = lastActionForPassStart.endPos;
                        } else if (lastActionForPassStart && lastActionForPassStart.isDirectReturn && lastActionForPassStart.directReturnEndPos) {
                            gameState.currentAction.startPos = lastActionForPassStart.directReturnEndPos;
                        }

                        addMarker(clickData, 'pass');
                        document.getElementById('outArea').classList.remove('active');

                        const lastAction = gameState.rally[gameState.rally.length - 1];
                        if (lastAction && lastAction.endPos) {
                            drawArrow(lastAction.endPos, clickData, 'pass');
                        } else if (lastAction && lastAction.isDirectReturn && lastAction.directReturnEndPos) {
                            drawArrow(lastAction.directReturnEndPos, clickData, 'pass');
                        }

                        gameState.rally.push({ ...gameState.currentAction });
                        hideAttackZones();

                        // Passer directement √† la s√©lection de l'attaquant (skip attack_player)
                        selectAttacker(attackerPlayer);

                    } else if (gameState.phase === 'pass_end') {
                        // Clic zone pendant passe manuelle = enregistrer la passe + auto-attaquant
                        const courtHalf = e.currentTarget.closest('.court-half');
                        const rect = courtHalf.getBoundingClientRect();
                        const x = ((e.clientX - rect.left) / rect.width) * 100;
                        const y = ((e.clientY - rect.top) / rect.height) * 100;
                        const courtSide = courtHalf.id === 'courtTop' ? 'top' : 'bottom';
                        const clickData = { x, y, courtSide };

                        // Compl√©ter la passe avec le passeur d√©j√† s√©lectionn√©
                        gameState.currentAction.endPos = clickData;
                        const lastActionForPassStart = gameState.rally[gameState.rally.length - 1];
                        if (lastActionForPassStart && lastActionForPassStart.endPos) {
                            gameState.currentAction.startPos = lastActionForPassStart.endPos;
                        } else if (lastActionForPassStart && lastActionForPassStart.isDirectReturn && lastActionForPassStart.directReturnEndPos) {
                            gameState.currentAction.startPos = lastActionForPassStart.directReturnEndPos;
                        }

                        addMarker(clickData, 'pass');
                        document.getElementById('outArea').classList.remove('active');
                        deactivateNetZone();

                        const lastAction = gameState.rally[gameState.rally.length - 1];
                        if (lastAction && lastAction.endPos) {
                            drawArrow(lastAction.endPos, clickData, 'pass');
                        } else if (lastAction && lastAction.isDirectReturn && lastAction.directReturnEndPos) {
                            drawArrow(lastAction.directReturnEndPos, clickData, 'pass');
                        }

                        gameState.rally.push({ ...gameState.currentAction });
                        hideAttackZones();

                        // Auto-s√©lection de l'attaquant cliqu√©
                        const passer = gameState.currentAction.player;
                        if (attackerPlayer !== passer) {
                            gameState.attackAutoSelected = true;
                            selectAttacker(attackerPlayer);
                        } else {
                            gameState.attackAutoSelected = false;
                            gameState.phase = 'attack_player';
                            updatePhase();
                            renderAttackPlayerSelection();
                        }

                    } else if (gameState.phase === 'attack_player') {
                        const effectiveAttacker = getEffectivePlayer() || attackerPlayer;
                        hideAttackZones();
                        selectAttacker(effectiveAttacker);
                    }
                });
            });

            // Defense zones click handlers (sur le container, avec point-in-polygon)
            document.querySelectorAll('.defense-zones').forEach(container => {
                container.addEventListener('click', (e) => {
                    e.stopPropagation();

                    // D√©terminer dans quelle zone le clic tombe
                    const rect = container.getBoundingClientRect();
                    const xPct = ((e.clientX - rect.left) / rect.width) * 100;
                    const yPct = ((e.clientY - rect.top) / rect.height) * 100;

                    let clickedPlayer = null;
                    const zones = container.querySelectorAll('.defense-zone');
                    for (const zone of zones) {
                        const clipPath = getComputedStyle(zone).clipPath;
                        if (!clipPath || clipPath === 'none') continue;
                        const polygon = parseClipPathPolygon(clipPath);
                        if (polygon && pointInPolygon(xPct, yPct, polygon)) {
                            clickedPlayer = zone.dataset.player;
                            break;
                        }
                    }
                    if (!clickedPlayer) return;

                    if (gameState.phase === 'result') {
                        // Phase r√©sultat : clic zone d√©fense = tout en 1 clic
                        // D√©fendu + d√©fenseur + position d√©fense ‚Üí directement phase passe
                        const courtHalf = container.closest('.court-half');
                        const courtRect = courtHalf.getBoundingClientRect();
                        const cx = ((e.clientX - courtRect.left) / courtRect.width) * 100;
                        const cy = ((e.clientY - courtRect.top) / courtRect.height) * 100;
                        const cSide = courtHalf.id === 'courtTop' ? 'top' : 'bottom';
                        const defClickData = { x: cx, y: cy, courtSide: cSide };

                        handleResultDefenseZoneClick(clickedPlayer, defClickData);

                    } else if (gameState.phase === 'defense') {
                        // Phase defense : s√©lection du d√©fenseur (override > zone auto)
                        const effectiveDefender = getEffectivePlayer() || clickedPlayer;
                        hideDefenseZones();
                        selectDefender(effectiveDefender);

                    } else if (gameState.phase === 'attack_type' || gameState.phase === 'attack_end') {
                        // Phase attaque : enregistrer le smash + pr√©-s√©lectionner le d√©fenseur
                        // Calculer clickData relatif au court-half
                        const courtHalf = container.closest('.court-half');
                        const courtRect = courtHalf.getBoundingClientRect();
                        const x = ((e.clientX - courtRect.left) / courtRect.width) * 100;
                        const y = ((e.clientY - courtRect.top) / courtRect.height) * 100;
                        const courtSide = courtHalf.id === 'courtTop' ? 'top' : 'bottom';
                        const clickData = { x, y, courtSide };

                        // Si attack_type, auto-s√©lectionner smash
                        if (gameState.phase === 'attack_type') {
                            gameState.currentAction.attackType = 'smash';
                            gameState.phase = 'attack_end';
                        }

                        // Stocker le d√©fenseur pr√©-s√©lectionn√©
                        gameState.defenseAutoSelected = true;
                        gameState.defenseAutoPlayer = clickedPlayer;

                        handleAttackEnd(clickData);

                    } else if (gameState.phase === 'attack_net_choice') {
                        // Phase attaque filet : clic zone d√©fense = block auto + destination + d√©fenseur auto
                        // Calculer clickData relatif au court-half
                        const courtHalf = container.closest('.court-half');
                        const courtRect = courtHalf.getBoundingClientRect();
                        const x = ((e.clientX - courtRect.left) / courtRect.width) * 100;
                        const y = ((e.clientY - courtRect.top) / courtRect.height) * 100;
                        const courtSide = courtHalf.id === 'courtTop' ? 'top' : 'bottom';
                        const clickData = { x, y, courtSide };

                        // Stocker la position comme destination du block (comme handleNetChoiceCourtClick)
                        gameState.pendingBlockEndPos = clickData;
                        addMarker(clickData, 'block-touch');
                        gameState.blockMarkerAlreadyAdded = true;

                        // Stocker le d√©fenseur pr√©-s√©lectionn√© pour apr√®s le block
                        gameState.defenseAutoSelected = true;
                        gameState.defenseAutoPlayer = clickedPlayer;

                        // Lancer le flow block
                        handleAttackNetChoice('block');
                    }
                });
            });
        }

        function handleOutAreaClick(event) {
            // Calculer la position relative au container
            const container = document.getElementById('courtContainer');
            const rect = container.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 100;
            const y = ((event.clientY - rect.top) / rect.height) * 100;

            // Marquer comme "out" (hors terrain)
            const clickData = { x, y, courtSide: 'out' };

            // Auto-s√©lection d√©fenseur via zones de d√©fense prolong√©es hors terrain
            // Pour les phases o√π les zones sont visibles, projeter le clic sur le terrain
            // pour d√©terminer quel d√©fenseur est le plus proche
            if (gameState.phase === 'result') {
                // Phase r√©sultat : clic out = auto "D√©fendu" + position D- stock√©e
                gameState.pendingDefenseClickData = clickData;
                hideDefenseQualityZones();
                selectResult('defended');
                return;
            } else if (gameState.phase === 'defense') {
                // Apr√®s un block, la balle peut sortir du terrain mais √™tre d√©fendue
                const nearestPlayer = findNearestDefenseZonePlayer(event);
                if (nearestPlayer) {
                    hideDefenseZones();
                    selectDefender(nearestPlayer);
                    return;
                }
            } else if (gameState.phase === 'attack_net_choice') {
                // Block qui envoie la balle out ‚Üí d√©fendable, auto-s√©lectionner le d√©fenseur
                const nearestPlayer = findNearestDefenseZonePlayer(event);
                if (nearestPlayer) {
                    gameState.defenseAutoSelected = true;
                    gameState.defenseAutoPlayer = nearestPlayer;
                }
            }

            if (gameState.phase === 'serve_end') {
                handleServeEnd(clickData);
            } else if (gameState.phase === 'reception_end') {
                handleReceptionEnd(clickData);
            } else if (gameState.phase === 'reception_fault_trajectory') {
                handleReceptionFaultTrajectoryEnd(clickData);
            } else if (gameState.phase === 'defense_fault_trajectory') {
                handleDefenseFaultTrajectoryEnd(clickData);
            } else if (gameState.phase === 'bloc_out_trajectory') {
                handleBlocOutTrajectoryEnd(clickData);
            } else if (gameState.phase === 'pass_end') {
                handlePassEnd(clickData);
            } else if (gameState.phase === 'pass') {
                handlePassCourtClick(clickData);
            } else if (gameState.phase === 'attack_type') {
                // Clic OUT direct = smash out
                gameState.currentAction.attackType = 'smash';
                gameState.phase = 'attack_end';
                handleAttackEnd(clickData);
            } else if (gameState.phase === 'attack_end') {
                handleAttackEnd(clickData);
            } else if (gameState.phase === 'defense_end') {
                handleDefenseEnd(clickData);
            } else if (gameState.phase === 'reception_net_block_end') {
                handleNetBlockEnd(clickData);
            } else if (gameState.phase === 'pass_net_block_end') {
                handlePassNetBlockEnd(clickData);
            } else if (gameState.phase === 'attack_net_block_end') {
                handleAttackNetBlockEnd(clickData);
            } else if (gameState.phase === 'attack_net_choice') {
                handleNetChoiceCourtClick(clickData, 'attack');
            } else if (gameState.phase === 'reception_net_choice') {
                handleNetChoiceCourtClick(clickData, 'reception');
            } else if (gameState.phase === 'pass_net_choice') {
                handleNetChoiceCourtClick(clickData, 'pass');
            }
        }

        function handleServiceZoneClick(event, zoneSide) {
            if (gameState.phase !== 'serve_start') return;

            const rect = event.currentTarget.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 100;
            const y = ((event.clientY - rect.top) / rect.height) * 100;

            const clickData = { x, y, courtSide: zoneSide === 'top' ? 'service_top' : 'service_bottom' };
            handleServeStart(clickData);
        }

        function showServiceZone() {
            const serviceZoneTop = document.getElementById('serviceZoneTop');
            const serviceZoneBottom = document.getElementById('serviceZoneBottom');
            
            // Masquer les deux d'abord
            serviceZoneTop.classList.remove('active');
            serviceZoneBottom.classList.remove('active');

            // Afficher la bonne zone selon l'√©quipe qui sert
            const servingCourtSide = getCourtSideForTeam(gameState.servingTeam);
            
            if (servingCourtSide === 'top') {
                serviceZoneTop.classList.add('active');
            } else {
                serviceZoneBottom.classList.add('active');
            }
        }

        function hideServiceZones() {
            document.getElementById('serviceZoneTop').classList.remove('active');
            document.getElementById('serviceZoneBottom').classList.remove('active');
        }

        function handleCourtClick(event, courtSide) {
            const rect = event.currentTarget.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 100;
            const y = ((event.clientY - rect.top) / rect.height) * 100;

            const clickData = { x, y, courtSide };

            // Auto-s√©lection d√©fenseur via prolongation des zones hors terrain
            // Si le clic est en dehors du terrain (x<0, x>100, y<0, y>100) et zones actives
            if (x < 0 || x > 100 || y < 0 || y > 100) {
                const _np = findNearestDefenseZonePlayer(event);
                if (gameState.phase === 'attack_net_choice') {
                    if (_np) {
                        gameState.defenseAutoSelected = true;
                        gameState.defenseAutoPlayer = _np;
                    }
                } else if (gameState.phase === 'defense') {
                    if (_np) {
                        hideDefenseZones();
                        selectDefender(_np);
                        return;
                    }
                }
            }

            switch (gameState.phase) {
                case 'serve_start':
                    handleServeStart(clickData);
                    break;
                case 'serve_end':
                    handleServeEnd(clickData);
                    break;
                case 'reception_end':
                    handleReceptionEnd(clickData);
                    break;
                case 'reception_fault_trajectory':
                    handleReceptionFaultTrajectoryEnd(clickData);
                    break;
                case 'direct_return_end':
                    handleDirectReturnEnd(clickData);
                    break;
                case 'pass_end':
                    handlePassEnd(clickData);
                    break;
                case 'pass':
                    handlePassCourtClick(clickData);
                    break;
                case 'attack_end':
                    handleAttackEnd(clickData);
                    break;
                case 'attack_type':
                    // Clic direct sur le terrain = smash par d√©faut
                    gameState.currentAction.attackType = 'smash';
                    gameState.phase = 'attack_end';
                    handleAttackEnd(clickData);
                    break;
                case 'block_end':
                    handleBlockEnd(clickData);
                    break;
                case 'reception_net_block_end':
                    handleNetBlockEnd(clickData);
                    break;
                case 'pass_net_block_end':
                    handlePassNetBlockEnd(clickData);
                    break;
                case 'attack_net_block_end':
                    handleAttackNetBlockEnd(clickData);
                    break;
                case 'attack_net_choice':
                    // Clic sur l'aire de jeu = Block automatique
                    handleNetChoiceCourtClick(clickData, 'attack');
                    break;
                case 'reception_net_choice':
                    handleNetChoiceCourtClick(clickData, 'reception');
                    break;
                case 'pass_net_choice':
                    handleNetChoiceCourtClick(clickData, 'pass');
                    break;
                case 'result':
                    // Clic terrain en phase r√©sultat = auto "D√©fendu"
                    handleResultCourtClick(clickData);
                    break;
                case 'defense_end':
                    handleDefenseEnd(clickData);
                    break;
                case 'defense_fault_trajectory':
                    handleDefenseFaultTrajectoryEnd(clickData);
                    break;
                case 'bloc_out_trajectory':
                    handleBlocOutTrajectoryEnd(clickData);
                    break;
            }
        }

        function handleServeStart(clickData) {
            gameState.currentAction.startPos = clickData;
            addMarker(clickData, 'service');
            gameState.phase = 'serve_end';
            updatePhase();
            
            // Masquer la zone de service
            hideServiceZones();
            
            // Activer la zone out pour permettre les clics hors terrain
            document.getElementById('outArea').classList.add('active');
            
            // Masquer le label OUT c√¥t√© serveur, afficher les autres
            const servingCourtSide = getCourtSideForTeam(gameState.servingTeam);
            document.getElementById('outLabelTop').style.display = servingCourtSide === 'top' ? 'none' : 'block';
            document.getElementById('outLabelBottom').style.display = servingCourtSide === 'bottom' ? 'none' : 'block';
            
            // Activer la zone filet cliquable
            activateNetZone();
            
            // Highlight receiving team's court
            const receivingTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
            highlightCourt(receivingTeam);
            
            // Show position zones for auto-selection during serve landing
            showPositionZones(receivingTeam);
        }

        function handleServeEnd(clickData) {
            gameState.currentAction.endPos = clickData;
            // On ne dessine pas de fl√®che ici, elle sera dessin√©e √† la r√©ception
            // On garde le marker pour montrer o√π le service est all√©
            addMarker(clickData, 'service');
            
            // D√©sactiver la zone out et la zone filet
            document.getElementById('outArea').classList.remove('active');
            deactivateNetZone();
            hidePositionZones();

            // V√©rifier si service faute (hors du terrain receveur)
            const receivingTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
            const expectedCourtSide = getCourtSideForTeam(receivingTeam);

            if (clickData.courtSide !== expectedCourtSide) {
                // Service faute out ! On dessine la fl√®che quand m√™me pour montrer l'erreur
                drawArrow(gameState.currentAction.startPos, clickData, 'service');
                handleServiceFaultOut();
            } else {
                // Service bon, passer √† la r√©ception (s√©lection manuelle)
                gameState.rally.push({ ...gameState.currentAction });
                gameState.attackingTeam = receivingTeam;
                gameState.receptionAutoSelected = false;
                gameState.phase = 'reception';
                showPositionZones(receivingTeam);
                renderOverrideTags({
                    team: receivingTeam,
                    phaseLabel: 'R√©ception',
                    autoPlayer: null,
                    autoRole: null,
                    eligiblePlayers: getLineupPlayers(receivingTeam),
                    mode: 'override',
                    showAceButton: true
                });
            }
        }

        function handleServiceFault() {
            // Marquer le service comme fault (g√©n√©rique, utilis√© par bouton depuis reception)
            gameState.currentAction.result = 'fault';
            gameState.rally.push({ ...gameState.currentAction });
            
            // Point pour l'√©quipe qui re√ßoit
            const receivingTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
            awardPoint(receivingTeam);
            endRally();
        }

        function handleServiceFaultOut() {
            // Service out (hors terrain)
            gameState.currentAction.result = 'fault_out';
            gameState.rally.push({ ...gameState.currentAction });
            
            // Point pour l'√©quipe qui re√ßoit
            const receivingTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
            awardPoint(receivingTeam);
            endRally();
        }

        function handleNetZoneClick(event) {
            // Capturer les coordonn√©es relatives au courtContainer
            // Le X est conserv√© tel quel, le Y est centr√© sur le filet
            const container = document.getElementById('courtContainer');
            const rect = container.getBoundingClientRect();
            const netElement = document.getElementById('netZone');
            const netRect = netElement.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 100;
            const y = ((netRect.top + netRect.height / 2 - rect.top) / rect.height) * 100;
            const clickData = { x, y, courtSide: 'net' };

            if (gameState.phase === 'serve_end') {
                // Faute de service dans le filet
                gameState.currentAction.endPos = clickData;
                addMarker(clickData, 'fault');
                
                // Tracer la fl√®che du service vers le filet
                if (gameState.currentAction.startPos) {
                    drawArrow(gameState.currentAction.startPos, clickData, 'service');
                }
                
                // D√©sactiver zones
                document.getElementById('outArea').classList.remove('active');
                deactivateNetZone();
                hidePositionZones();
                
                gameState.currentAction.result = 'fault_net';
                gameState.rally.push({ ...gameState.currentAction });
                
                // Point pour l'√©quipe qui re√ßoit
                const receivingTeam = gameState.servingTeam === 'home' ? 'away' : 'home';
                awardPoint(receivingTeam);
                endRally();

            } else if (gameState.phase === 'reception_end') {
                // R√©ception dans le filet ‚Üê‚Äô afficher choix Attaque directe / Block
                gameState.currentAction.endPos = clickData;
                // startPos = arrivee du service (point de contact reception)
                const svcForRecNet = gameState.rally.find(a => a.type === 'service');
                if (svcForRecNet && svcForRecNet.endPos) { gameState.currentAction.startPos = svcForRecNet.endPos; }
                addMarker(clickData, 'reception');
                
                // Tracer fl√®che du service
                const serviceAction = gameState.rally.find(a => a.type === 'service');
                if (serviceAction && serviceAction.startPos && serviceAction.endPos) {
                    drawArrow(serviceAction.startPos, serviceAction.endPos, 'service');
                }
                
                // Tracer fl√®che de r√©ception vers le filet
                if (serviceAction && serviceAction.endPos) {
                    addMarker(serviceAction.endPos, 'reception');
                    drawArrow(serviceAction.endPos, clickData, 'reception');
                }
                
                // D√©sactiver zones
                document.getElementById('outArea').classList.remove('active');
                deactivateNetZone();
                hideReceptionQualityZones();
                document.getElementById('receptionFaultSection').classList.add('hidden');
                
                // Afficher les choix
                gameState.phase = 'reception_net_choice';
                updatePhase();
                hideAllSections();
                document.getElementById('receptionNetChoice').classList.remove('hidden');
                // R√©activer la zone out pour permettre les clics block out
                document.getElementById('outArea').classList.add('active');
                document.getElementById('outLabelTop').style.display = 'block';
                document.getElementById('outLabelBottom').style.display = 'block';

            } else if (gameState.phase === 'pass') {
                // Passe dans le filet en mode auto-s√©lection passeur (ou Pointu si exclu)
                const team = gameState.attackingTeam;
                const passeur = getPlayerByRole(team, 'Passeur');
                const lastToucher = getLastTouchPlayer(team);
                if (!passeur) return;

                let selectedPasser, selectedRole;
                if (passeur === lastToucher) {
                    const pointu = getPlayerByRole(team, 'Pointu');
                    if (!pointu || pointu === lastToucher) return;
                    selectedPasser = pointu;
                    selectedRole = 'Pointu';
                } else {
                    selectedPasser = passeur;
                    selectedRole = 'Passeur';
                }

                gameState.passAutoSelected = true;
                gameState.currentAction = {
                    type: 'pass',
                    player: selectedPasser,
                    team: team,
                    role: selectedRole,
                    endPos: clickData
                };
                // startPos = arriv√©e de la r√©ception/d√©fense pr√©c√©dente
                const prevForPassAutoNet = gameState.rally[gameState.rally.length - 1];
                if (prevForPassAutoNet && prevForPassAutoNet.endPos) { gameState.currentAction.startPos = prevForPassAutoNet.endPos; }
                else if (prevForPassAutoNet && prevForPassAutoNet.isDirectReturn && prevForPassAutoNet.directReturnEndPos) { gameState.currentAction.startPos = prevForPassAutoNet.directReturnEndPos; }
                addMarker(clickData, 'pass');

                // Tracer fl√®che
                if (prevForPassAutoNet && prevForPassAutoNet.endPos) {
                    drawArrow(prevForPassAutoNet.endPos, clickData, 'pass');
                }

                // D√©sactiver zones
                document.getElementById('outArea').classList.remove('active');
                deactivateNetZone();

                // Sauvegarder la passe dans le rally
                gameState.currentAction.isNetPass = true;
                gameState.rally.push({ ...gameState.currentAction });

                // Afficher les choix
                gameState.phase = 'pass_net_choice';
                updatePhase();
                hideAllSections();
                document.getElementById('passNetChoice').classList.remove('hidden');
                document.getElementById('outArea').classList.add('active');
                document.getElementById('outLabelTop').style.display = 'block';
                document.getElementById('outLabelBottom').style.display = 'block';

            } else if (gameState.phase === 'pass_end') {
                // Passe dans le filet ‚Üê' afficher choix Attaque directe / Block
                gameState.currentAction.endPos = clickData;
                // startPos = arrivee de la reception/defense precedente
                const prevForPassNet = gameState.rally[gameState.rally.length - 1];
                if (prevForPassNet && prevForPassNet.endPos) { gameState.currentAction.startPos = prevForPassNet.endPos; }
                else if (prevForPassNet && prevForPassNet.isDirectReturn && prevForPassNet.directReturnEndPos) { gameState.currentAction.startPos = prevForPassNet.directReturnEndPos; }
                addMarker(clickData, 'pass');
                
                // Tracer fl√®che de la passe vers le filet
                const lastActionPass = gameState.rally[gameState.rally.length - 1];
                if (lastActionPass && lastActionPass.endPos) {
                    drawArrow(lastActionPass.endPos, clickData, 'pass');
                }
                
                // D√©sactiver zones
                document.getElementById('outArea').classList.remove('active');
                deactivateNetZone();

                // Sauvegarder la passe dans le rally
                gameState.currentAction.isNetPass = true;
                gameState.rally.push({ ...gameState.currentAction });
                
                // Afficher les choix
                gameState.phase = 'pass_net_choice';
                updatePhase();
                hideAllSections();
                document.getElementById('passNetChoice').classList.remove('hidden');
                // R√©activer la zone out pour permettre les clics block out
                document.getElementById('outArea').classList.add('active');
                document.getElementById('outLabelTop').style.display = 'block';
                document.getElementById('outLabelBottom').style.display = 'block';

            } else if (gameState.phase === 'attack_type' || gameState.phase === 'attack_end') {
                // Attaque dans le filet ‚Üê' afficher choix Faute / Block
                // Les zones de d√©fense restent visibles car le block ne compte pas comme une touche
                // et l'utilisateur peut cliquer une zone pour auto-block + auto-d√©fenseur
                if (gameState.phase === 'attack_type') {
                    gameState.currentAction.attackType = 'smash';
                }
                gameState.currentAction.endPos = clickData;
                // startPos = arrivee de la passe precedente
                const prevForAttNet = gameState.rally[gameState.rally.length - 1];
                if (prevForAttNet && prevForAttNet.endPos) { gameState.currentAction.startPos = prevForAttNet.endPos; }
                
                // D√©terminer le type de fl√®che
                let attackArrowType = 'attack';
                if (gameState.currentAction.attackType === 'feinte') attackArrowType = 'attack-feinte';
                else if (gameState.currentAction.attackType === 'relance') attackArrowType = 'attack-relance';
                else if (gameState.currentAction.attackType === 'deuxieme_main' || gameState.currentAction.attackType === 'attaque_directe') attackArrowType = 'attack-second';
                
                addMarker(clickData, attackArrowType);
                
                // Tracer fl√®che de l'attaque vers le filet
                const lastActionAttack = gameState.rally[gameState.rally.length - 1];
                if (lastActionAttack && lastActionAttack.endPos) {
                    drawArrow(lastActionAttack.endPos, clickData, attackArrowType);
                }
                
                // D√©sactiver zones
                document.getElementById('outArea').classList.remove('active');
                deactivateNetZone();
                
                // Sauvegarder l'attaque dans le rally
                gameState.currentAction.isNetAttack = true;
                gameState.rally.push({ ...gameState.currentAction });
                
                // Sauvegarder la position filet pour le block √©ventuel
                gameState.netBlockPos = clickData;
                
                // Afficher les choix
                gameState.phase = 'attack_net_choice';
                updatePhase();
                hideAllSections();
                document.getElementById('attackNetChoice').classList.remove('hidden');
                // R√©activer la zone out pour permettre les clics block out
                document.getElementById('outArea').classList.add('active');
                document.getElementById('outLabelTop').style.display = 'block';
                document.getElementById('outLabelBottom').style.display = 'block';
            }
        }

        function _OLD_handleAceFromReception() {
            // [DEAD CODE V18.0] Remplac√© par WorkflowEngine ‚Äî Ace signal√© depuis la phase reception
            // ou depuis la phase reception_end (r√©ceptionneur d√©j√† s√©lectionn√©)
            const team = gameState.attackingTeam;

            // Retrouver l'action de service et la marquer comme ace
            const serviceAction = gameState.rally.find(a => a.type === 'service');
            if (serviceAction) {
                serviceAction.result = 'ace';
            }

            // Tracer la fl√®che du service
            if (serviceAction && serviceAction.startPos && serviceAction.endPos) {
                drawArrow(serviceAction.startPos, serviceAction.endPos, 'service');
            }

            if (gameState.phase === 'reception_end') {
                // R√©ceptionneur d√©j√† connu (auto-s√©lectionn√© ou choisi via tag)
                const playerName = gameState.currentAction.player;
                const receptionAction = {
                    type: 'reception',
                    player: playerName,
                    team: team,
                    role: getPlayerRole(team, playerName),
                    quality: { score: 0, label: 'Faute' }
                };
                if (serviceAction && serviceAction.endPos) {
                    receptionAction.startPos = serviceAction.endPos;
                    receptionAction.endPos = serviceAction.endPos;
                }
                gameState.rally.push(receptionAction);

                hideAllSections();
                hidePositionZones();
                hideReceptionQualityZones();
                awardPoint(gameState.servingTeam);
                endRally();
            } else {
                // Phase reception (tags visibles) : demander qui a rat√©
                // Utiliser le joueur s√©lectionn√© via override/auto s'il y en a un
                const selectedPlayer = getEffectivePlayer();
                if (selectedPlayer) {
                    const receptionAction = {
                        type: 'reception',
                        player: selectedPlayer,
                        team: team,
                        role: getPlayerRole(team, selectedPlayer),
                        quality: { score: 0, label: 'Faute' }
                    };
                    if (serviceAction && serviceAction.endPos) {
                        receptionAction.startPos = serviceAction.endPos;
                        receptionAction.endPos = serviceAction.endPos;
                    }
                    gameState.rally.push(receptionAction);

                    hideAllSections();
                    hidePositionZones();
                    gameState.overridePlayer = null;
                    awardPoint(gameState.servingTeam);
                    endRally();
                } else {
                    // Aucun joueur s√©lectionn√©, afficher les tags pour choisir
                    hideAllSections();
                    gameState.phase = 'ace_reception';
                    updatePhase();
                    showPositionZones(team);
                    renderAceReceptionSelection(team);
                }
            }
        }

        function renderAceReceptionSelection(team) {
            const container = document.getElementById('playerTags');
            document.getElementById('playerSelectionTitle').textContent = 'Qui a rat√© la r√©ception ?';

            const lineup = team === 'home' ? currentSet.homeLineup : currentSet.awayLineup;
            const players = Object.values(lineup).filter(p => p !== null);

            container.innerHTML = players.map(playerName => `
                <button class="player-tag ${team}" onclick="handleAceReceptionPlayer('${playerName}')">
                    ${playerName}
                </button>
            `).join('');

            showSection('playerSelection');
        }

        function handleAceReceptionPlayer(playerName) {
            const team = gameState.attackingTeam;

            // Enregistrer une action r√©ception "Faute" (score 0) pour ce joueur
            const receptionAction = {
                type: 'reception',
                player: playerName,
                team: team,
                role: getPlayerRole(team, playerName),
                quality: { score: 0, label: 'Faute' }
            };

            // Ajouter la position d'arriv√©e du service comme startPos de la r√©ception
            const serviceAction = gameState.rally.find(a => a.type === 'service');
            if (serviceAction && serviceAction.endPos) {
                receptionAction.startPos = serviceAction.endPos;
                receptionAction.endPos = serviceAction.endPos;
            }

            gameState.rally.push(receptionAction);

            // Nettoyage
            hideAllSections();
            hidePositionZones();

            // Point pour l'√©quipe qui sert
            awardPoint(gameState.servingTeam);
            endRally();
        }

        // ==================== R√âCEPTION ====================
        function selectReceptioner(playerName) {
            gameState.currentAction = {
                type: 'reception',
                player: playerName,
                team: gameState.attackingTeam,
                role: getPlayerRole(gameState.attackingTeam, playerName)
            };
            gameState.phase = 'reception_end';
            updatePhase();
            hideAllSections();

            // Afficher les tags override avec le r√©ceptionneur s√©lectionn√©
            renderOverrideTags({
                team: gameState.attackingTeam,
                phaseLabel: 'R√©ception',
                autoPlayer: playerName,
                autoRole: gameState.currentAction.role,
                eligiblePlayers: getLineupPlayers(gameState.attackingTeam),
                mode: 'override'
            });

            highlightCourt(gameState.attackingTeam);

            // Afficher les zones de qualit√© et le bouton faute
            showReceptionQualityZones();
            document.getElementById('receptionFaultSection').classList.remove('hidden');
            
            // Activer la zone out pour les r√©ceptions hors terrain
            document.getElementById('outArea').classList.add('active');
            // Activer la zone filet cliquable pour les r√©ceptions dans le filet
            activateNetZone(true);
            // Masquer les labels OUT c√¥t√© adverse (on ne r√©ceptionne pas chez l'adversaire)
            const receivingCourtSide = getCourtSideForTeam(gameState.attackingTeam);
            document.getElementById('outLabelTop').style.display = receivingCourtSide === 'top' ? 'block' : 'none';
            document.getElementById('outLabelBottom').style.display = receivingCourtSide === 'bottom' ? 'block' : 'none';
        }

        function _OLD_handleReceptionFaultFromTags() {
            // [DEAD CODE V18.0] Remplac√© par WorkflowEngine ‚Äî Faute r√©ception depuis les tags
            // Utiliser le joueur s√©lectionn√© via override/auto s'il y en a un
            const selectedPlayer = getEffectivePlayer();
            if (selectedPlayer) {
                // S√©lectionner le r√©ceptionneur puis d√©clencher la faute
                selectReceptioner(selectedPlayer);
                gameState.overridePlayer = null;
                handleReceptionFault();
            }
            // Si aucun joueur s√©lectionn√©, ne rien faire (l'utilisateur doit d'abord cliquer un tag)
        }

        function handleReceptionEnd(clickData) {
            gameState.currentAction.endPos = clickData;
            // Enregistrer le startPos de la reception = arrivee du service (point de contact)
            const serviceActionForStart = gameState.rally.find(a => a.type === 'service');
            if (serviceActionForStart && serviceActionForStart.endPos) {
                gameState.currentAction.startPos = serviceActionForStart.endPos;
            }
            
            // D√©sactiver la zone out et la zone filet
            document.getElementById('outArea').classList.remove('active');
            deactivateNetZone();
            
            // V√©rifier si la r√©ception va dans le terrain adverse (retour direct)
            const receivingTeam = gameState.attackingTeam;
            const receivingCourtSide = getCourtSideForTeam(receivingTeam);
            const oppositeCourtSide = receivingCourtSide === 'top' ? 'bottom' : 'top';
            
            if (clickData.courtSide === oppositeCourtSide) {
                // La r√©ception va dans le terrain adverse ‚Äî afficher les choix
                // Retour direct = R1 (non ma√Ætris√© mais pas une faute ‚Äî sera ajust√© en FR si exploit√©)
                gameState.currentAction.quality = { score: 1, label: 'N√©gative' };
                gameState.currentAction.endPos = clickData;

                // Enregistrer le point de contact de la r√©ception = l'arriv√©e du service
                const serviceAction = gameState.rally.find(a => a.type === 'service');
                if (serviceAction && serviceAction.endPos) {
                    // Le point de contact est l'arriv√©e du service
                    addMarker(serviceAction.endPos, 'reception');
                }
                
                // Tracer fl√®che du service
                if (serviceAction && serviceAction.startPos && serviceAction.endPos) {
                    drawArrow(serviceAction.startPos, serviceAction.endPos, 'service');
                }
                
                // Tracer la fl√®che de la r√©ception vers le terrain adverse
                const receptionStartPos = serviceAction ? serviceAction.endPos : null;
                if (receptionStartPos) {
                    drawArrow(receptionStartPos, clickData, 'reception');
                }
                addMarker(clickData, 'reception');
                
                // Sauvegarder les donn√©es pour les choix ult√©rieurs
                gameState.receptionOpponentClickData = clickData;
                
                // Masquer les zones de qualit√©
                hideReceptionQualityZones();
                document.getElementById('receptionFaultSection').classList.add('hidden');
                
                // Afficher les choix
                gameState.phase = 'reception_opponent_choice';
                updatePhase();
                hideAllSections();
                document.getElementById('receptionOpponentChoice').classList.remove('hidden');
                return;
            }
            
            // Calculer la qualit√© de la r√©ception selon la zone
            // Si c'est hors terrain, c'est automatiquement une r√©ception n√©gative (1/4)
            let quality;
            if (clickData.courtSide === 'out') {
                quality = { score: 1, label: 'N√©gative' };
            } else {
                quality = calculateReceptionQuality(clickData);
            }
            gameState.currentAction.quality = quality;
            gameState.currentAction.endPos = clickData;

            addMarker(clickData, 'reception');
            
            // Masquer les zones de qualit√©
            hideReceptionQualityZones();
            document.getElementById('receptionFaultSection').classList.add('hidden');
            
            // Tracer fl√®che du SERVICE depuis son point de d√©part jusqu'au point de contact (endPos du service)
            const serviceAction = gameState.rally.find(a => a.type === 'service');
            if (serviceAction && serviceAction.startPos && serviceAction.endPos) {
                drawArrow(serviceAction.startPos, serviceAction.endPos, 'service');
                
                // Tracer fl√®che de R√âCEPTION depuis le point de contact jusqu'√† l'arriv√©e de la r√©ception
                drawArrow(serviceAction.endPos, clickData, 'reception');
            }

            gameState.rally.push({ ...gameState.currentAction });
            
            // Toujours passer en phase pass avec terrain actif
            // Clic terrain = passeur auto-s√©lectionn√©, clic joueur = passe manuelle
            gameState.passAutoSelected = false;
            gameState.phase = 'pass';
            updatePhase();
            hideAllSections();
            highlightCourt(null);
            
            // Activer le terrain et la zone out pour clic direct (= passeur auto)
            document.getElementById('outArea').classList.add('active');
            document.getElementById('outLabelTop').style.display = 'block';
            document.getElementById('outLabelBottom').style.display = 'block';
            activateNetZone(true);

            // Afficher les boutons joueurs (non-passeur) + options 2√®me touche + faute
            renderPassPlayerSelection();
        }

        function calculateReceptionQuality(clickData) {
            // Calculer la distance par rapport au filet
            const courtSide = getCourtSideForTeam(gameState.attackingTeam);
            
            // Distance depuis le filet (en %)
            let distanceFromNet;
            if (courtSide === 'top') {
                // Terrain du haut : filet en bas (y=100%)
                distanceFromNet = 100 - clickData.y;
            } else {
                // Terrain du bas : filet en haut (y=0%)
                distanceFromNet = clickData.y;
            }
            
            // Distance horizontale depuis le centre (en %)
            const distX = Math.abs(clickData.x - 50);
            
            // Calcul bas√© sur la forme elliptique des demi-cercles (75% de l'original)
            // Zone parfaite: width 30%, height 22.5% ‚Üí ratio x/15, y/22.5
            // Zone correcte: width 52.5%, height 41% ‚Üí ratio x/26.25, y/41
            // Zone moyenne: width 75%, height 60% ‚Üí ratio x/37.5, y/60

            const perfectRatio = Math.sqrt(Math.pow(distX / 15, 2) + Math.pow(distanceFromNet / 22.5, 2));
            const goodRatio = Math.sqrt(Math.pow(distX / 26.25, 2) + Math.pow(distanceFromNet / 41, 2));
            const averageRatio = Math.sqrt(Math.pow(distX / 37.5, 2) + Math.pow(distanceFromNet / 60, 2));
            
            if (perfectRatio <= 1) {
                return { score: 4, label: 'Excellente' };
            } else if (goodRatio <= 1) {
                return { score: 3, label: 'Positive' };
            } else if (averageRatio <= 1) {
                return { score: 2, label: 'Jouable' };
            } else {
                return { score: 1, label: 'N√©gative' };
            }
        }

        function showReceptionQualityZones() {
            const courtSide = getCourtSideForTeam(gameState.attackingTeam);
            if (courtSide === 'top') {
                document.getElementById('qualityZonesTop').classList.add('active');
            } else {
                document.getElementById('qualityZonesBottom').classList.add('active');
            }
        }

        function hideReceptionQualityZones() {
            document.getElementById('qualityZonesTop').classList.remove('active');
            document.getElementById('qualityZonesBottom').classList.remove('active');
        }

        function showDefenseQualityZones(team) {
            // Afficher la zone D+ sur le terrain de l'√©quipe qui d√©fend
            const defendingTeam = team || gameState.attackingTeam;
            const courtSide = getCourtSideForTeam(defendingTeam);

            // Zone D+ r√©duite si relance (m√™me taille que R√©ception 4/4 : 40% √ó 30%)
            const lastAttack = gameState.rally.slice().reverse().find(a => a.type === 'attack');
            const isRelance = lastAttack && lastAttack.attackType === 'relance';
            const zoneWidth = isRelance ? '40%' : '43%';
            const zoneHeight = isRelance ? '30%' : '50%';

            // Couleur bleu clair pour relance, bleu normal sinon
            const zoneColor = isRelance ? '#60a5fa' : '';

            // Appliquer les dimensions et couleur dynamiques sur les deux zones
            document.querySelectorAll('.defense-quality-zone.positive').forEach(z => {
                z.style.width = zoneWidth;
                z.style.height = zoneHeight;
                z.style.background = zoneColor;
            });

            if (courtSide === 'top') {
                document.getElementById('defQualityZonesTop').classList.add('active');
            } else {
                document.getElementById('defQualityZonesBottom').classList.add('active');
            }
        }

        function hideDefenseQualityZones() {
            document.getElementById('defQualityZonesTop').classList.remove('active');
            document.getElementById('defQualityZonesBottom').classList.remove('active');
            // Reset les dimensions au d√©faut CSS
            const zones = document.querySelectorAll('.defense-quality-zone.positive');
            zones.forEach(z => { z.style.width = ''; z.style.height = ''; z.style.background = ''; });
        }

        function calculateDefenseQuality(clickData) {
            // Calculer si le clic est dans la zone D+ (demi-cercle proche du filet)
            const courtSide = getCourtSideForTeam(gameState.attackingTeam);

            // Distance depuis le filet (en %)
            let distanceFromNet;
            if (courtSide === 'top') {
                distanceFromNet = 100 - clickData.y;
            } else {
                distanceFromNet = clickData.y;
            }

            // Distance horizontale depuis le centre (en %)
            const distX = Math.abs(clickData.x - 50);

            // Relance ‚Üí zone D+ r√©duite (m√™me taille que R√©ception 4/4 : 40%√ó30%)
            const lastAttack = gameState.rally.slice().reverse().find(a => a.type === 'attack');
            const isRelance = lastAttack && lastAttack.attackType === 'relance';
            const semiAxisX = isRelance ? 20 : 21.5;
            const semiAxisY = isRelance ? 30 : 50;

            // Zone D+ : demi-ellipse (semi-axes variables selon type d'attaque)
            const ratio = Math.sqrt(Math.pow(distX / semiAxisX, 2) + Math.pow(distanceFromNet / semiAxisY, 2));

            if (ratio <= 1) {
                return 'positive'; // D+
            } else {
                return 'negative'; // D-
            }
        }

        // ==================== DEBUG : GRILLE QUALITE PASSE (V19.1d) ====================
        // Affiche l'overlay colore sur le terrain (touche G)
        let passGridDebugActive = false;

        function togglePassQualityGrid() {
            if (passGridDebugActive) {
                hidePassQualityGrid();
            } else {
                showPassQualityGrid(gameState.attackingTeam);
            }
        }

        function showPassQualityGrid(team) {
            if (!team) return;

            const courtSide = getCourtSideForTeam(team);
            const gridId = courtSide === 'top' ? 'passGridTop' : 'passGridBottom';
            const gridEl = document.getElementById(gridId);
            if (!gridEl) return;

            // Determiner le contexte depuis le rally en cours
            const passeur = getPlayerByRole(team, 'Passeur');
            const effectivePlayer = getEffectivePlayer && getEffectivePlayer();
            const passer = effectivePlayer || passeur;
            const passerRole = passer ? (getPlayerRole(team, passer) || 'transition') : 'transition';
            const contextObj = getPassContext(gameState.rally || [], passerRole);
            const context = contextObj.context;

            const colors = {
                4: '#22c55e',  // Vert ‚Äî Optimale
                3: '#a3e635',  // Vert-jaune ‚Äî Bonne
                2: '#f97316',  // Orange ‚Äî Jouable
                1: '#ef4444'   // Rouge ‚Äî Mauvaise
            };

            let html = '';
            const cellHeight = PASS_GRID_DEPTH / PASS_GRID_ROWS;

            // Chaque grille (R4/Centre/Pointu) couvre les 9m COMPLETS du terrain (18 cols de 50cm)
            // R4 et Pointu ont 4 cols extra (2m) hors-terrain ‚Üí 22 cols = 11m
            // L'overlay composite montre le TIERS pertinent de chaque grille + le debordement hors-terrain
            //
            // Pour le tiers R4 (bottom=gauche, top=droite) : on affiche les colonnes de la grille R4
            //   qui correspondent a x ‚àà [0%, 33.33%] du terrain, + les cols hors-terrain
            // Pour le tiers Centre : colonnes de la grille Centre pour x ‚àà [33.33%, 66.67%]
            // Pour le tiers Pointu : colonnes de la grille Pointu pour x ‚àà [66.67%, 100%] + hors-terrain

            const zones = courtSide === 'bottom'
                ? [{ zone: 'R4', xStart: 0, xEnd: 33.33 }, { zone: 'Centre', xStart: 33.33, xEnd: 66.67 }, { zone: 'Pointu', xStart: 66.67, xEnd: 100 }]
                : [{ zone: 'Pointu', xStart: 0, xEnd: 33.33 }, { zone: 'Centre', xStart: 33.33, xEnd: 66.67 }, { zone: 'R4', xStart: 66.67, xEnd: 100 }];

            zones.forEach(function(zoneInfo) {
                const zoneGrid = PASS_GRIDS[zoneInfo.zone] && PASS_GRIDS[zoneInfo.zone][context];
                if (!zoneGrid) return;

                const totalCols = getPassGridCols(zoneInfo.zone);
                const isExtended = (zoneInfo.zone === 'R4' || zoneInfo.zone === 'Pointu');

                // Largeur d'une colonne en % du terrain = largeur grille / nb cols
                // Grille couvre 100% (18 cols) ou 122.22% (22 cols) du terrain
                const totalGridWidth = 100 + (isExtended ? PASS_GRID_OVERFLOW : 0); // 122.22 ou 100
                const colWidthPct = totalGridWidth / totalCols; // % du terrain par colonne

                // Debut X de la grille complete en % du terrain
                // R4 bottom / Pointu top : debordement a GAUCHE ‚Üí grille commence a -22.22%
                // Pointu bottom / R4 top : debordement a DROITE ‚Üí grille commence a 0%
                const overflowLeft = isExtended && (
                    (zoneInfo.zone === 'R4' && courtSide === 'bottom') ||
                    (zoneInfo.zone === 'Pointu' && courtSide === 'top')
                );
                const gridXStart = overflowLeft ? -PASS_GRID_OVERFLOW : 0;

                // Determiner quelles colonnes tombent dans le tiers [xStart, xEnd] + hors-terrain
                for (let ci = 0; ci < totalCols; ci++) {
                    const cellLeft = gridXStart + ci * colWidthPct;
                    const cellRight = cellLeft + colWidthPct;

                    // La colonne est-elle dans le tiers visible ou dans le debordement hors-terrain ?
                    const inThird = (cellRight > zoneInfo.xStart && cellLeft < zoneInfo.xEnd);
                    const isOffCourt = (cellLeft < 0 || cellRight > 100);

                    if (!inThird && !isOffCourt) continue; // Hors du tiers et pas hors-terrain ‚Üí skip

                    // Miroir top court : les grilles sont calibrees en perspective bottom
                    // col 0 = gauche ‚Üí en top court gauche/droite inverses ‚Üí lire colonnes a l'envers
                    // row 0 = filet ‚Üí en top court le filet est en bas ‚Üí lire rows a l'envers
                    const gridCol = (courtSide === 'top') ? (totalCols - 1 - ci) : ci;

                    for (let row = 0; row < PASS_GRID_ROWS; row++) {
                        const gridRow = (courtSide === 'top') ? (PASS_GRID_ROWS - 1 - row) : row;
                        const score = zoneGrid[gridRow] ? (zoneGrid[gridRow][gridCol] || 1) : 1;
                        const color = colors[score];

                        const left = cellLeft.toFixed(2) + '%';
                        const width = colWidthPct.toFixed(2) + '%';
                        let top;
                        if (courtSide === 'bottom') {
                            top = (row * cellHeight).toFixed(2) + '%';
                        } else {
                            top = (100 - PASS_GRID_DEPTH + row * cellHeight).toFixed(2) + '%';
                        }
                        const height = cellHeight.toFixed(2) + '%';

                        // Hachures diagonales pour les zones hors-terrain
                        const offCourtStyle = isOffCourt
                            ? 'background-image:repeating-linear-gradient(45deg,transparent,transparent 2px,rgba(0,0,0,0.15) 2px,rgba(0,0,0,0.15) 4px);'
                            : '';

                        html += '<div style="position:absolute;left:' + left + ';top:' + top +
                            ';width:' + width + ';height:' + height +
                            ';background-color:' + color + ';' + offCourtStyle +
                            'border:1px solid rgba(255,255,255,0.3);' +
                            'font-size:8px;font-weight:bold;display:flex;align-items:center;justify-content:center;color:rgba(255,255,255,0.85);">' +
                            score + '</div>';
                    }
                }
            });

            gridEl.innerHTML = html;
            gridEl.classList.add('active');
            passGridDebugActive = true;

            // √âlever .court au-dessus de svg.arrow-svg pour que l'overlay soit visible
            const courtEl = document.querySelector('.court');
            if (courtEl) courtEl.classList.add('pass-grid-debug-active');
        }

        function hidePassQualityGrid() {
            const top = document.getElementById('passGridTop');
            const bottom = document.getElementById('passGridBottom');
            if (top) { top.classList.remove('active'); top.innerHTML = ''; }
            if (bottom) { bottom.classList.remove('active'); bottom.innerHTML = ''; }
            passGridDebugActive = false;

            // Remettre .court √† son z-index normal
            const courtEl = document.querySelector('.court');
            if (courtEl) courtEl.classList.remove('pass-grid-debug-active');
        }

        // Touche G pour toggle l'overlay grille passe
        // Active en phase pass/pass_end, masque automatiquement sinon
        document.addEventListener('keydown', function(e) {
            if (e.key === 'g' || e.key === 'G') {
                if (gameState.phase === 'pass' || gameState.phase === 'pass_end') {
                    togglePassQualityGrid();
                } else if (passGridDebugActive) {
                    // Auto-masquer si on appuie G hors phase pass
                    hidePassQualityGrid();
                }
            }
        });

        // Masquer l'overlay automatiquement quand la phase change (clic terrain, bouton, etc.)
        // On observe les changements via un poll l√©ger sur requestAnimationFrame
        (function autoHidePassGrid() {
            let lastPhase = '';
            function checkPhase() {
                if (passGridDebugActive && gameState.phase !== 'pass' && gameState.phase !== 'pass_end') {
                    hidePassQualityGrid();
                }
                lastPhase = gameState.phase;
                requestAnimationFrame(checkPhase);
            }
            requestAnimationFrame(checkPhase);
        })();

        function _OLD_handleReceptionFault() {
            // [DEAD CODE V18.0] Remplac√© par WorkflowEngine ‚Äî Faute de r√©ception
            gameState.currentAction.quality = { score: 0, label: 'Faute' };
            
            // Masquer les zones de qualit√© et d√©sactiver le filet
            hideReceptionQualityZones();
            document.getElementById('receptionFaultSection').classList.add('hidden');
            deactivateNetZone();
            
            // Tracer fl√®che du service quand m√™me
            const serviceAction = gameState.rally.find(a => a.type === 'service');
            if (serviceAction && serviceAction.startPos && serviceAction.endPos) {
                drawArrow(serviceAction.startPos, serviceAction.endPos, 'service');
            }
            
            // Passer en mode trajectoire
            gameState.phase = 'reception_fault_trajectory';
            updatePhase();
            hideAllSections();
            document.getElementById('receptionFaultTrajectory').classList.remove('hidden');
            
            // Activer la zone out et les deux terrains pour cliquer o√π va la balle
            document.getElementById('outArea').classList.add('active');
            document.getElementById('outLabelTop').style.display = 'block';
            document.getElementById('outLabelBottom').style.display = 'block';
            highlightCourt(null);
        }

        function handleReceptionFaultTrajectoryEnd(clickData) {
            // Enregistrer la trajectoire de la faute de r√©ception
            gameState.currentAction.faultTrajectory = clickData;
            
            // Tracer la fl√®che de la trajectoire de faute
            const serviceAction = gameState.rally.find(a => a.type === 'service');
            if (serviceAction && serviceAction.endPos) {
                drawArrow(serviceAction.endPos, clickData, 'reception');
                addMarker(serviceAction.endPos, 'reception');
            }
            addMarker(clickData, 'reception');
            
            // D√©sactiver zones
            document.getElementById('outArea').classList.remove('active');
            document.getElementById('receptionFaultTrajectory').classList.add('hidden');
            
            // Finaliser la faute de r√©ception
            finalizeReceptionFault();
        }

        function skipReceptionFaultTrajectory() {
            // Passer la trajectoire, finaliser directement
            document.getElementById('outArea').classList.remove('active');
            document.getElementById('receptionFaultTrajectory').classList.add('hidden');
            finalizeReceptionFault();
        }

        function finalizeReceptionFault() {
            gameState.currentAction.endPos = gameState.currentAction.faultTrajectory || null;
            // startPos = arrivee du service (point de contact reception)
            const svcForRecFault = gameState.rally.find(a => a.type === 'service');
            if (svcForRecFault && svcForRecFault.endPos) { gameState.currentAction.startPos = svcForRecFault.endPos; }
            gameState.rally.push({ ...gameState.currentAction });
            
            // Marquer le service comme ace
            const serviceAction = gameState.rally.find(a => a.type === 'service');
            if (serviceAction) {
                serviceAction.result = 'ace';
            }
            
            // Point pour l'√©quipe qui sert
            awardPoint(gameState.servingTeam);
            endRally();
        }

        function handleDirectReturn() {
            // Retour direct = la balle va dans le terrain adverse, ils doivent d√©fendre
            // R1 (non ma√Ætris√© mais pas une faute ‚Äî sera ajust√© en FR si exploit√©)
            gameState.currentAction.quality = { score: 1, label: 'N√©gative' };
            gameState.currentAction.isDirectReturn = true;
            
            // Le point de contact de la r√©ception = l'arriv√©e du service
            const serviceAction = gameState.rally.find(a => a.type === 'service');
            if (serviceAction && serviceAction.endPos) {
                gameState.currentAction.endPos = serviceAction.endPos;
                gameState.currentAction.startPos = serviceAction.endPos;
                // Ajouter un marker au point de contact
                addMarker(serviceAction.endPos, 'reception');
            }
            
            // Ne pas encore pusher dans rally, on attend le clic de l'arriv√©e
            
            // Masquer les zones
            hideReceptionQualityZones();
            document.getElementById('receptionFaultSection').classList.add('hidden');
            
            // Tracer fl√®che du service
            if (serviceAction && serviceAction.startPos && serviceAction.endPos) {
                drawArrow(serviceAction.startPos, serviceAction.endPos, 'service');
            }
            
            // L'√©quipe adverse (qui servait) doit maintenant d√©fendre
            const defendingTeam = gameState.servingTeam;
            
            // Mettre en surbrillance le terrain de l'√©quipe qui d√©fend (qui servait)
            highlightCourt(defendingTeam);
            
            // Phase pour cliquer l'arriv√©e du retour direct
            gameState.phase = 'direct_return_end';
            updatePhase();
            hideAllSections();
        }

        function handleDirectReturnEnd(clickData) {
            // Enregistrer l'arriv√©e du retour direct
            gameState.currentAction.directReturnEndPos = clickData;
            gameState.rally.push({ ...gameState.currentAction });
            
            // Tracer la fl√®che du retour direct (depuis r√©ception vers arriv√©e)
            const receptionStartPos = gameState.currentAction.endPos; // endPos de la r√©ception = point de contact
            if (receptionStartPos) {
                drawArrow(receptionStartPos, clickData, 'reception');
            }
            
            // Ajouter un marker pour l'arriv√©e
            addMarker(clickData, 'reception');
            
            // L'√©quipe adverse (qui servait) doit maintenant d√©fendre
            const defendingTeam = gameState.servingTeam;
            gameState.attackingTeam = defendingTeam;
            
            gameState.phase = 'defense';
            renderDefenseSelection(defendingTeam, null);
        }

        function handleDirectReturnWinner() {
            // Retour direct gagnant = point direct pour l'√©quipe qui r√©ceptionne
            gameState.currentAction.quality = { score: 1, label: 'N√©gative' };
            gameState.currentAction.isDirectReturnWinner = true;
            const serviceActionForStart = gameState.rally.find(a => a.type === 'service');
            if (serviceActionForStart && serviceActionForStart.endPos) {
                gameState.currentAction.startPos = serviceActionForStart.endPos;
            }
            gameState.rally.push({ ...gameState.currentAction });
            
            // Masquer les zones
            hideReceptionQualityZones();
            document.getElementById('receptionFaultSection').classList.add('hidden');
            
            // Tracer fl√®che du service
            const serviceAction = gameState.rally.find(a => a.type === 'service');
            if (serviceAction && serviceAction.startPos && serviceAction.endPos) {
                drawArrow(serviceAction.startPos, serviceAction.endPos, 'service');
            }
            
            // Point pour l'√©quipe qui r√©ceptionne (attackingTeam)
            awardPoint(gameState.attackingTeam);
            endRally();
        }

        // ==================== CHOIX RETOUR TERRAIN ADVERSE ====================
        function handleOpponentChoice(choice) {
            hideAllSections();

            const clickData = gameState.receptionOpponentClickData;
            const serviceAction = gameState.rally.find(a => a.type === 'service');

            // Retour direct = R1 (non ma√Ætris√© mais pas une faute)
            gameState.currentAction.isDirectReturn = true;
            gameState.currentAction.directReturnEndPos = clickData;

            // Le point de contact = arriv√©e du service
            if (serviceAction && serviceAction.endPos) {
                gameState.currentAction.endPos = serviceAction.endPos;
            }

            if (choice === 'winner') {
                // Retour gagnant = R1 + point direct (pas d'Att+ ‚Äî ce n'est pas une attaque)
                gameState.currentAction.isDirectReturnWinner = true;
                gameState.rally.push({ ...gameState.currentAction });

                // Point pour l'√©quipe qui r√©ceptionne
                awardPoint(gameState.attackingTeam);
                endRally();

            } else if (choice === 'direct_attack') {
                // Attaque directe = R1 + l'adversaire attaque directement la balle
                gameState.rally.push({ ...gameState.currentAction });

                // L'√©quipe adverse (qui servait) passe en attaque directe
                const attackingTeam = gameState.servingTeam;
                gameState.attackingTeam = attackingTeam;
                gameState.defenseDirectAttack = true;
                gameState.receptionDirectAttackSource = true; // Pour distinguer dans le undo

                gameState.phase = 'attack_player';
                updatePhase();
                renderAttackPlayerSelection();

            } else if (choice === 'defense') {
                // D√©fendu = R1 + l'adversaire d√©fend
                gameState.rally.push({ ...gameState.currentAction });

                // L'√©quipe adverse (qui servait) doit maintenant d√©fendre
                const defendingTeam = gameState.servingTeam;
                gameState.attackingTeam = defendingTeam;

                highlightCourt(defendingTeam);
                gameState.phase = 'defense';
                renderDefenseSelection(defendingTeam, null);
            }
        }

        // ==================== CHOIX R√âCEPTION DANS LE FILET ====================
        function handleReceptionNetChoice(choice) {
            hideAllSections();
            
            const serviceAction = gameState.rally.find(a => a.type === 'service');
            
            if (choice === 'attaque_directe') {
                // R√©ception dans le filet qui passe ‚Üê‚Äô l'√©quipe au service attaque
                // Finaliser la r√©ception comme 0/4
                gameState.currentAction.quality = { score: 0, label: 'Filet - Att. directe' };
                gameState.currentAction.isNetDirect = true;
                gameState.rally.push({ ...gameState.currentAction });
                
                // Changer l'√©quipe attaquante ‚Üê‚Äô c'est l'√©quipe au service qui r√©cup√®re
                gameState.attackingTeam = gameState.servingTeam;
                gameState.netDirectAttack = true; // Flag pour tracer la fl√®che depuis le filet
                gameState.phase = 'attack_player';
                updatePhase();
                renderAttackPlayerSelection();
                
            } else if (choice === 'block') {
                // R√©ception dans le filet ‚Üê' l'adversaire (√©quipe au service) block
                // Finaliser la r√©ception comme 0/4
                gameState.currentAction.quality = { score: 0, label: 'Filet - Block' };
                gameState.currentAction.isNetBlock = true;
                gameState.rally.push({ ...gameState.currentAction });

                // Sauvegarder la position du bloc au filet pour les fl√®ches
                gameState.netBlockPos = gameState.currentAction.endPos;

                // Auto-s√©lection du bloqueur si clic sur zone split
                if (gameState.autoSelectedBlocker) {
                    const blocker = gameState.autoSelectedBlocker;
                    delete gameState.autoSelectedBlocker;
                    delete gameState.autoSelectedBlockerRole;
                    selectNetBlocker(blocker);
                    return;
                }

                // S√©lection du bloqueur dans l'√©quipe au service
                const blockingTeam = gameState.servingTeam;
                gameState.phase = 'reception_net_block_player';
                renderOverrideTags({
                    team: blockingTeam, phaseLabel: 'Block au filet',
                    autoPlayer: null, autoRole: null,
                    eligiblePlayers: getLineupPlayers(blockingTeam), mode: 'select'
                });
            }
        }

        // ==================== PASSE DANS LE FILET ====================
        function handlePassNetChoice(choice) {
            hideAllSections();
            
            if (choice === 'attaque_directe') {
                // Passe dans le filet qui passe ‚Üê‚Äô l'√©quipe adverse attaque
                const opposingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                gameState.attackingTeam = opposingTeam;
                gameState.netDirectAttack = true;
                gameState.phase = 'attack_player';
                updatePhase();
                renderAttackPlayerSelection();
                
            } else if (choice === 'block') {
                // Passe dans le filet ‚Üê' l'√©quipe adverse block
                const blockingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                gameState.netBlockPos = gameState.rally[gameState.rally.length - 1].endPos; // Position filet de la passe

                // Auto-s√©lection du bloqueur si clic sur zone split
                if (gameState.autoSelectedBlocker) {
                    const blocker = gameState.autoSelectedBlocker;
                    delete gameState.autoSelectedBlocker;
                    delete gameState.autoSelectedBlockerRole;
                    selectPassNetBlocker(blocker);
                    return;
                }

                gameState.phase = 'pass_net_block_player';
                renderOverrideTags({
                    team: blockingTeam, phaseLabel: 'Block au filet',
                    autoPlayer: null, autoRole: null,
                    eligiblePlayers: getLineupPlayers(blockingTeam), mode: 'select'
                });
            }
        }

        function selectPassNetBlocker(playerName) {
            const passingTeam = gameState.attackingTeam;
            const blockingTeam = passingTeam === 'home' ? 'away' : 'home';
            gameState.currentAction = {
                type: 'block',
                player: playerName,
                team: blockingTeam,
                role: getPlayerRole(blockingTeam, playerName),
                startPos: gameState.netBlockPos
            };
            
            // Si la position d'arriv√©e du block a d√©j√† √©t√© cliqu√©e (via clic terrain auto)
            if (gameState.pendingBlockEndPos) {
                const clickData = gameState.pendingBlockEndPos;
                delete gameState.pendingBlockEndPos;
                handlePassNetBlockEnd(clickData);
                return;
            }
            
            gameState.phase = 'pass_net_block_end';
            updatePhase();
            hideAllSections();

            // Afficher les tags avec le bloqueur s√©lectionn√©
            const passingTeamForTags = gameState.attackingTeam;
            const blockingTeamForTags = passingTeamForTags === 'home' ? 'away' : 'home';
            renderOverrideTags({
                team: blockingTeamForTags,
                phaseLabel: 'Block au filet',
                autoPlayer: playerName,
                autoRole: gameState.currentAction.role,
                eligiblePlayers: getLineupPlayers(blockingTeamForTags),
                mode: 'override'
            });

            highlightCourt(null);
            document.getElementById('outArea').classList.add('active');
            document.getElementById('outLabelTop').style.display = 'block';
            document.getElementById('outLabelBottom').style.display = 'block';
        }

        function handlePassNetBlockEnd(clickData) {
            gameState.currentAction.endPos = clickData;
            if (!gameState.blockMarkerAlreadyAdded) {
                addMarker(clickData, 'block-touch');
            }
            delete gameState.blockMarkerAlreadyAdded;
            document.getElementById('outArea').classList.remove('active');

            if (gameState.netBlockPos) {
                const netPos = getNetCenteredPos(gameState.netBlockPos);
                drawArrow(netPos, clickData, 'block-touch');
            }
            
            gameState.rally.push({ ...gameState.currentAction });
            
            // D√©terminer o√π le block atterrit
            const passingTeam = gameState.attackingTeam;
            const blockingTeam = passingTeam === 'home' ? 'away' : 'home';
            const blockingCourtSide = getCourtSideForTeam(blockingTeam);
            const passingCourtSide = getCourtSideForTeam(passingTeam);
            
            if (clickData.courtSide === passingCourtSide || clickData.courtSide === 'out') {
                // Block va chez l'√©quipe qui a fait la passe ‚Üê' d√©fense pour eux
                gameState.attackingTeam = passingTeam;
                gameState.phase = 'defense';
                document.getElementById('outArea').classList.add('active');
                renderDefenseSelection(passingTeam, null, true);
            } else if (clickData.courtSide === blockingCourtSide) {
                // Block revient chez le bloqueur ‚Üê' d√©fense pour eux
                gameState.attackingTeam = blockingTeam;
                gameState.phase = 'defense';
                document.getElementById('outArea').classList.add('active');
                renderDefenseSelection(blockingTeam, null, true);
            }
        }

        // ==================== ATTAQUE DANS LE FILET ====================
        // ==================== CLIC TERRAIN PENDANT CHOIX FILET (BLOCK AUTO) ====================
        function handleNetChoiceCourtClick(clickData, netType) {
            // D√©terminer l'√©quipe qui blocke selon le type de filet
            let blockingTeam;

            if (netType === 'attack') {
                blockingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
            } else if (netType === 'reception') {
                blockingTeam = gameState.servingTeam;
            } else if (netType === 'pass') {
                blockingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
            }

            // Tout clic sur l'aire de jeu (terrain ou out) = Block automatique
            // Le block peut aller n'importe o√π : terrain d√©fenseur, terrain attaquant, ou out
            {
                // Sauvegarder la position du clic pour l'utiliser apr√®s s√©lection du bloqueur
                gameState.pendingBlockEndPos = clickData;
                // Afficher le marqueur imm√©diatement pour feedback visuel
                addMarker(clickData, 'block-touch');
                gameState.blockMarkerAlreadyAdded = true;

                // Auto-s√©lection du bloqueur si pas d√©j√† fait via zone filet split
                // On d√©termine le c√¥t√© du clic (gauche/droite) pour choisir le bon bloqueur
                if (!gameState.autoSelectedBlocker) {
                    const blockingCourtSide = getCourtSideForTeam(blockingTeam);
                    // D√©terminer la zone (left/right) en fonction de la position X du clic
                    // Pour out : utiliser x relatif au container (50% = centre)
                    let xRef = clickData.x;
                    // Pour les clics sur le terrain, x est en % du court-half (0-100)
                    const zone = (xRef < 50) ? 'left' : 'right';
                    const blocker = getBlockerForNetZone(blockingTeam, zone);
                    if (blocker && blocker.player) {
                        gameState.autoSelectedBlocker = blocker.player;
                        gameState.autoSelectedBlockerRole = blocker.role;
                    }
                }

                if (netType === 'attack') {
                    handleAttackNetChoice('block');
                } else if (netType === 'reception') {
                    handleReceptionNetChoice('block');
                } else if (netType === 'pass') {
                    handlePassNetChoice('block');
                }
            }
        }

        function handleAttackNetChoice(choice) {
            hideAllSections();

            if (choice === 'faute') {
                // Nettoyer les flags de d√©fense auto si pr√©sents
                gameState.defenseAutoSelected = false;
                gameState.defenseAutoPlayer = null;
                hideDefenseZones();
                // Attaque dans le filet = faute directe, point pour l'adversaire
                const lastAttackAction = gameState.rally[gameState.rally.length - 1];
                if (lastAttackAction) {
                    lastAttackAction.result = 'fault_net';
                }
                const defendingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                awardPoint(defendingTeam);
                endRally();

            } else if (choice === 'bloc_out') {
                // Bloc out depuis attaque filet : la balle sort du bloc, point pour l'attaquant
                const blockingTeamBO = gameState.attackingTeam === 'home' ? 'away' : 'home';
                const lastAttackActionBO = gameState.rally[gameState.rally.length - 1];
                if (lastAttackActionBO) {
                    lastAttackActionBO.result = 'bloc_out';
                }

                // Auto-s√©lection du bloqueur si disponible
                if (gameState.autoSelectedBlocker) {
                    const blocker = gameState.autoSelectedBlocker;
                    delete gameState.autoSelectedBlocker;
                    delete gameState.autoSelectedBlockerRole;
                    gameState.defenseAutoSelected = false;
                    gameState.defenseAutoPlayer = null;
                    hideDefenseZones();
                    // Enregistrer le block out puis demander la trajectoire
                    gameState.rally.push({
                        type: 'block',
                        player: blocker,
                        team: blockingTeamBO,
                        role: getPlayerRole(blockingTeamBO, blocker),
                        result: 'bloc_out'
                    });
                    startBlocOutTrajectory();
                    return;
                }

                hideDefenseZones();
                gameState.blocOutPending = true;
                gameState.phase = 'bloc_out_player';
                renderOverrideTags({
                    team: blockingTeamBO, phaseLabel: 'Bloc out',
                    autoPlayer: null, autoRole: null,
                    eligiblePlayers: getLineupPlayers(blockingTeamBO), mode: 'select'
                });
            } else if (choice === 'block') {
                // Attaque dans le filet ‚Üê l'√©quipe adverse block
                const blockingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';

                // Marquer l'attaque comme "defended" (le block d√©vie la balle ‚Üí d√©fense)
                const lastAttackAction = gameState.rally[gameState.rally.length - 1];
                if (lastAttackAction && lastAttackAction.type === 'attack') {
                    lastAttackAction.result = 'defended';
                }

                // Auto-s√©lection du bloqueur si clic sur zone split
                if (gameState.autoSelectedBlocker) {
                    const blocker = gameState.autoSelectedBlocker;
                    delete gameState.autoSelectedBlocker;
                    delete gameState.autoSelectedBlockerRole;
                    // Cacher les zones seulement si pas de d√©fenseur auto-s√©lectionn√©
                    // (si d√©fenseur auto, les zones seront cach√©es dans selectDefender)
                    if (!gameState.defenseAutoSelected) {
                        hideDefenseZones();
                    }
                    selectAttackNetBlocker(blocker);
                    return;
                }

                hideDefenseZones();
                gameState.phase = 'attack_net_block_player';
                renderOverrideTags({
                    team: blockingTeam, phaseLabel: 'Block au filet',
                    autoPlayer: null, autoRole: null,
                    eligiblePlayers: getLineupPlayers(blockingTeam), mode: 'select'
                });
            }
        }

        function selectAttackNetBlocker(playerName) {
            const blockingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
            gameState.currentAction = {
                type: 'block',
                player: playerName,
                team: blockingTeam,
                role: getPlayerRole(blockingTeam, playerName),
                startPos: gameState.netBlockPos
            };
            
            // Si la position d'arriv√©e du block a d√©j√† √©t√© cliqu√©e (via clic terrain auto)
            if (gameState.pendingBlockEndPos) {
                const clickData = gameState.pendingBlockEndPos;
                delete gameState.pendingBlockEndPos;
                handleAttackNetBlockEnd(clickData);
                return;
            }
            
            gameState.phase = 'attack_net_block_end';
            updatePhase();
            hideAllSections();

            // Afficher les tags avec le bloqueur s√©lectionn√©
            renderOverrideTags({
                team: blockingTeam,
                phaseLabel: 'Block au filet',
                autoPlayer: playerName,
                autoRole: gameState.currentAction.role,
                eligiblePlayers: getLineupPlayers(blockingTeam),
                mode: 'override'
            });

            highlightCourt(null);
            document.getElementById('outArea').classList.add('active');
            document.getElementById('outLabelTop').style.display = 'block';
            document.getElementById('outLabelBottom').style.display = 'block';
        }

        function handleAttackNetBlockEnd(clickData) {
            gameState.currentAction.endPos = clickData;
            // Ajouter le marqueur seulement s'il n'a pas d√©j√† √©t√© ajout√© (clic terrain auto)
            if (!gameState.blockMarkerAlreadyAdded) {
                addMarker(clickData, 'block-touch');
            }
            delete gameState.blockMarkerAlreadyAdded;
            document.getElementById('outArea').classList.remove('active');

            if (gameState.netBlockPos) {
                const netPos = getNetCenteredPos(gameState.netBlockPos);
                drawArrow(netPos, clickData, 'block-touch');
            }
            
            gameState.rally.push({ ...gameState.currentAction });
            
            // D√©terminer o√π le block atterrit
            const attackingTeam = gameState.attackingTeam;
            const blockingTeam = attackingTeam === 'home' ? 'away' : 'home';
            const attackingCourtSide = getCourtSideForTeam(attackingTeam);
            const blockingCourtSide = getCourtSideForTeam(blockingTeam);
            
            // Trouver le r√¥le de l'attaquant pour les zones de d√©fense
            const lastAttackForZones = [...gameState.rally].reverse().find(a => a.type === 'attack');
            const attackerRoleForZones = lastAttackForZones ? lastAttackForZones.role : null;

            // Apr√®s un block, pas d'auto-s√©lection par d√©faut du d√©fenseur
            // (la balle est d√©vi√©e de mani√®re impr√©visible)
            // SAUF si l'utilisateur a cliqu√© dans une zone de d√©fense pendant attack_net_choice
            // (dans ce cas defenseAutoSelected est d√©j√† true via handleNetChoiceCourtClick)
            if (!gameState.defenseAutoSelected) {
                gameState.defenseAutoSelected = false;
                gameState.defenseAutoPlayer = null;
            }

            if (clickData.courtSide === blockingCourtSide) {
                // Block revient chez le bloqueur ‚Üí d√©fense pour eux
                gameState.attackingTeam = blockingTeam;
            }
            // Sinon (attackingCourtSide ou out) ‚Üí d√©fense pour l'attaquant (pas de changement)

            gameState.phase = 'defense';
            document.getElementById('outArea').classList.add('active');

            if (gameState.defenseAutoSelected && gameState.defenseAutoPlayer) {
                // D√©fenseur pr√©-s√©lectionn√© (clic zone de d√©fense pendant attack_net_choice)
                // ‚Üí aller directement √† la zone D+ sans repasser par la s√©lection
                const autoPlayer = gameState.defenseAutoPlayer;
                gameState.defenseAutoSelected = false;
                gameState.defenseAutoPlayer = null;
                updatePhase();
                selectDefender(autoPlayer);
            } else {
                // Apr√®s un bloc : PAS de zones auto-select (soutien = al√©atoire)
                // On passe null comme attackerRole pour ne pas afficher les zones color√©es
                renderDefenseSelection(gameState.attackingTeam, null, true);
            }
        }

        function selectNetBlocker(playerName) {
            const blockingTeam = gameState.servingTeam;
            gameState.currentAction = {
                type: 'block',
                player: playerName,
                team: blockingTeam,
                role: getPlayerRole(blockingTeam, playerName),
                startPos: gameState.netBlockPos // Position du filet
            };
            
            // Si la position d'arriv√©e du block a d√©j√† √©t√© cliqu√©e (via clic terrain auto)
            if (gameState.pendingBlockEndPos) {
                const clickData = gameState.pendingBlockEndPos;
                delete gameState.pendingBlockEndPos;
                handleNetBlockEnd(clickData);
                return;
            }
            
            gameState.phase = 'reception_net_block_end';
            updatePhase();
            hideAllSections();

            // Afficher les tags avec le bloqueur s√©lectionn√©
            renderOverrideTags({
                team: blockingTeam,
                phaseLabel: 'Block au filet',
                autoPlayer: playerName,
                autoRole: gameState.currentAction.role,
                eligiblePlayers: getLineupPlayers(blockingTeam),
                mode: 'override'
            });

            // Les deux terrains sont cliquables
            highlightCourt(null);

            // Activer la zone out
            document.getElementById('outArea').classList.add('active');
            document.getElementById('outLabelTop').style.display = 'block';
            document.getElementById('outLabelBottom').style.display = 'block';
        }

        function handleNetBlockEnd(clickData) {
            gameState.currentAction.endPos = clickData;
            if (!gameState.blockMarkerAlreadyAdded) {
                addMarker(clickData, 'block-touch');
            }
            delete gameState.blockMarkerAlreadyAdded;

            // D√©sactiver zones
            document.getElementById('outArea').classList.remove('active');

            // Tracer fl√®che du block (depuis le centre du filet vers l'arriv√©e)
            if (gameState.netBlockPos) {
                const netPos = getNetCenteredPos(gameState.netBlockPos);
                drawArrow(netPos, clickData, 'block-touch');
            }
            
            gameState.rally.push({ ...gameState.currentAction });
            
            // D√©terminer o√π le block atterrit
            const blockingTeam = gameState.servingTeam;
            const receivingTeam = gameState.attackingTeam; // L'√©quipe qui a r√©ceptionn√©
            const blockingCourtSide = getCourtSideForTeam(blockingTeam);
            const receivingCourtSide = getCourtSideForTeam(receivingTeam);
            
            if (clickData.courtSide === receivingCourtSide || clickData.courtSide === 'out') {
                // Block va chez l'√©quipe qui a r√©ceptionn√© ‚Üê' d√©fense pour eux
                gameState.attackingTeam = receivingTeam;
                gameState.phase = 'defense';
                document.getElementById('outArea').classList.add('active');
                renderDefenseSelection(receivingTeam, null, true);
            } else if (clickData.courtSide === blockingCourtSide) {
                // Block revient chez l'√©quipe qui a block√© ‚Üê' d√©fense pour eux
                // (le block ne compte pas comme une touche au volleyball)
                gameState.attackingTeam = blockingTeam;
                gameState.phase = 'defense';
                document.getElementById('outArea').classList.add('active');
                renderDefenseSelection(blockingTeam, null, true);
            }
        }

        // ==================== PASSE ====================
        // Affiche les tags override pour la passe + options 2√®me touche
        function renderPassPlayerSelection() {
            const team = gameState.attackingTeam;
            const passeur = getPlayerByRole(team, 'Passeur');
            const lastToucher = getLastTouchPlayer(team);

            // Auto-s√©lection : Pointu si le Passeur est lastToucher, sinon Passeur
            let autoPlayer, autoRole;
            if (passeur && passeur === lastToucher) {
                const pointu = getPlayerByRole(team, 'Pointu');
                autoPlayer = pointu || null;
                autoRole = pointu ? 'Pointu' : null;
            } else {
                autoPlayer = passeur || null;
                autoRole = passeur ? 'Passeur' : null;
            }

            // Afficher les zones d'attaque (anticipation visuelle)
            showAttackZones(team);

            renderOverrideTags({
                team,
                phaseLabel: 'Passe',
                autoPlayer,
                autoRole,
                eligiblePlayers: getLineupPlayers(team),
                mode: autoPlayer ? 'override' : 'select'
            });

            // Afficher les options de 2√®me touche
            document.getElementById('secondTouchOptions').classList.remove('hidden');
        }
        
        // D√©termine l'attaquant auto-s√©lectionn√© selon la position X du clic
        // excludePlayer : joueur qui fait la passe (ne peut pas attaquer)
        // Retourne le nom du joueur ou null
        function getAttackerFromClickX(clickData, excludePlayer) {
            const team = gameState.attackingTeam;
            const courtSide = getCourtSideForTeam(team);

            // Config attaque centre pour cette √©quipe
            const centreAttackEnabled = team === 'home'
                ? (currentSet.homeCentreAttack === true)
                : (currentSet.awayCentreAttack !== false);

            // D√©terminer la position X et Y relative au terrain de l'√©quipe
            let xPercent, yPercent;
            if (clickData.courtSide === 'out') {
                // Clic out : calculer X/Y par rapport au court-half de l'√©quipe
                const courtId = courtSide === 'top' ? 'courtTop' : 'courtBottom';
                const courtEl = document.getElementById(courtId);
                const container = document.getElementById('courtContainer');
                const containerRect = container.getBoundingClientRect();
                const courtRect = courtEl.getBoundingClientRect();
                const clickAbsX = (clickData.x / 100) * containerRect.width + containerRect.left;
                xPercent = ((clickAbsX - courtRect.left) / courtRect.width) * 100;
                yPercent = ((clickData.y / 100) * containerRect.height + containerRect.top - courtRect.top) / courtRect.height * 100;
            } else {
                xPercent = clickData.x;
                yPercent = clickData.y;
            }

            let role;

            // Si attaque centre activ√©e, tester d'abord le demi-cercle
            if (centreAttackEnabled) {
                // Demi-cercle centr√© au milieu du filet, rayon 16.65% en X et Y
                // Bottom court : filet en Y=0%, Top court : filet en Y=100%
                const filetY = courtSide === 'bottom' ? 0 : 100;
                const dx = (xPercent - 50) / 16.65;
                const dy = (yPercent - filetY) / 16.65;
                // V√©rifier que le clic est dans le demi-cercle ET du bon c√¥t√© du filet
                const inSemiCircle = (dx * dx + dy * dy <= 1) &&
                    (courtSide === 'bottom' ? yPercent >= 0 : yPercent <= 100);

                if (inSemiCircle) {
                    role = 'Centre';
                }
            }

            // Sinon : gauche/droite classique
            if (!role) {
                if (courtSide === 'bottom') {
                    role = xPercent < 50 ? 'R4' : 'Pointu';
                } else {
                    role = xPercent < 50 ? 'Pointu' : 'R4';
                }
            }

            let player = getPlayerByRole(team, role);

            // Si le joueur trouv√© est celui qui a fait la passe, il ne peut pas attaquer
            if (player && excludePlayer && player === excludePlayer) {
                if (role === 'Pointu') {
                    // Pointu exclu c√¥t√© droit ‚Üí Passeur prend sa place
                    player = getPlayerByRole(team, 'Passeur');
                } else {
                    // R4 ou Centre exclu ‚Üí pas d'auto-s√©lection
                    player = null;
                }
            }

            return player;
        }

        // Convertit un clic outArea (coordonn√©es courtContainer %) en coordonn√©es court-half
        // Retourne { x, y, courtSide } si le clic tombe dans la bande Y d'un court-half, null sinon
        function convertOutToCourtHalf(containerClickData) {
            const container = document.getElementById('courtContainer');
            const courtTop = document.getElementById('courtTop');
            const courtBottom = document.getElementById('courtBottom');
            const containerRect = container.getBoundingClientRect();
            const topRect = courtTop.getBoundingClientRect();
            const bottomRect = courtBottom.getBoundingClientRect();

            // Position du clic en pixels absolus dans le container
            const clickPxX = containerClickData.x / 100 * containerRect.width;
            const clickPxY = containerClickData.y / 100 * containerRect.height;

            // Positions relatives des court-halves dans le container
            const topRelY = topRect.top - containerRect.top;
            const topH = topRect.height;
            const bottomRelY = bottomRect.top - containerRect.top;
            const bottomH = bottomRect.height;

            // X relatif au court (centr√© dans le container)
            const court = document.getElementById('court');
            const courtRect = court.getBoundingClientRect();
            const courtRelX = courtRect.left - containerRect.left;
            const xInCourt = (clickPxX - courtRelX) / courtRect.width * 100;

            if (clickPxY >= topRelY && clickPxY <= topRelY + topH) {
                const yInHalf = (clickPxY - topRelY) / topH * 100;
                return { x: xInCourt, y: yInHalf, courtSide: 'top' };
            } else if (clickPxY >= bottomRelY && clickPxY <= bottomRelY + bottomH) {
                const yInHalf = (clickPxY - bottomRelY) / bottomH * 100;
                return { x: xInCourt, y: yInHalf, courtSide: 'bottom' };
            }

            return null; // Vraiment hors zone (au-dessus ou en-dessous des deux terrains)
        }

        // Clic terrain pendant phase pass = auto-s√©lection du passeur + enregistrement position
        // + auto-s√©lection de l'attaquant selon le c√¥t√© gauche/droite
        function handlePassCourtClick(clickData) {
            const team = gameState.attackingTeam;
            const passeur = getPlayerByRole(team, 'Passeur');
            if (!passeur) return;

            // D√©terminer le passeur : override > Pointu (si Passeur est lastToucher) > Passeur
            const effectiveOverride = getEffectivePlayer();
            let defaultPasser = passeur;
            const lastToucher = getLastTouchPlayer(team);
            if (passeur === lastToucher) {
                const pointu = getPlayerByRole(team, 'Pointu');
                if (pointu) defaultPasser = pointu;
            }
            const selectedPasser = effectiveOverride || defaultPasser;
            const selectedRole = getPlayerRole(team, selectedPasser);

            // V√©rifier si la passe va dans le terrain adverse (retour direct)
            const passingCourtSide = getCourtSideForTeam(team);
            const oppositeCourtSide = passingCourtSide === 'top' ? 'bottom' : 'top';
            if (clickData.courtSide === oppositeCourtSide) {
                // Passe chez l'adversaire ‚Äî cr√©er l'action et afficher popup de choix
                gameState.passAutoSelected = true;
                gameState.currentAction = {
                    type: 'pass',
                    player: selectedPasser,
                    team: team,
                    role: selectedRole,
                    endPos: clickData,
                    isDirectReturn: true,
                    directReturnEndPos: clickData
                };
                // startPos = arriv√©e de la r√©ception/d√©fense pr√©c√©dente
                const lastActionForStart = gameState.rally[gameState.rally.length - 1];
                if (lastActionForStart && lastActionForStart.endPos) {
                    gameState.currentAction.startPos = lastActionForStart.endPos;
                } else if (lastActionForStart && lastActionForStart.isDirectReturn && lastActionForStart.directReturnEndPos) {
                    gameState.currentAction.startPos = lastActionForStart.directReturnEndPos;
                }
                addMarker(clickData, 'pass');
                // Tracer fl√®che depuis la r√©ception ou d√©fense
                const lastAction = gameState.rally[gameState.rally.length - 1];
                if (lastAction && lastAction.endPos) {
                    drawArrow(lastAction.endPos, clickData, 'pass');
                } else if (lastAction && lastAction.isDirectReturn && lastAction.directReturnEndPos) {
                    drawArrow(lastAction.directReturnEndPos, clickData, 'pass');
                }
                document.getElementById('outArea').classList.remove('active');
                gameState.passDirectReturnClickData = clickData;
                gameState.rally.push({ ...gameState.currentAction });
                hideAttackZones();

                gameState.phase = 'pass_direct_return_choice';
                updatePhase();
                hideAllSections();
                document.getElementById('passDirectReturnChoice').classList.remove('hidden');
                return;
            }

            // Passe out ‚Üí convertir en coordonn√©es court-half si possible
            if (clickData.courtSide === 'out') {
                const converted = convertOutToCourtHalf(clickData);

                if (converted && converted.courtSide === passingCourtSide) {
                    // Clic out mais c√¥t√© propre terrain ‚Üí traiter comme passe normale
                    // La grille de qualit√© g√®re les zones hors-terrain via les extensions R4/Pointu
                    clickData = converted;
                    // NE PAS return ‚Äî continuer dans le flow normal ci-dessous
                } else if (converted && converted.courtSide === oppositeCourtSide) {
                    // V20.18 : Relance passe out c√¥t√© adverse ‚Üí faute imm√©diate (comme attaque out)
                    if (gameState.context.passRelance) {
                        gameState.passAutoSelected = true;
                        gameState.currentAction = {
                            type: 'pass',
                            player: selectedPasser,
                            team: team,
                            role: selectedRole,
                            endPos: converted,
                            passType: 'relance',
                            result: 'out'
                        };
                        const lastActionForStart = gameState.rally[gameState.rally.length - 1];
                        if (lastActionForStart && lastActionForStart.endPos) {
                            gameState.currentAction.startPos = lastActionForStart.endPos;
                        } else if (lastActionForStart && lastActionForStart.isDirectReturn && lastActionForStart.directReturnEndPos) {
                            gameState.currentAction.startPos = lastActionForStart.directReturnEndPos;
                        }
                        addMarker(converted, 'pass');
                        const lastAction = gameState.rally[gameState.rally.length - 1];
                        if (lastAction && lastAction.endPos) {
                            drawArrow(lastAction.endPos, converted, 'pass');
                        } else if (lastAction && lastAction.isDirectReturn && lastAction.directReturnEndPos) {
                            drawArrow(lastAction.directReturnEndPos, converted, 'pass');
                        }
                        gameState.context.passRelance = false;
                        gameState.rally.push({ ...gameState.currentAction });
                        document.getElementById('outArea').classList.remove('active');
                        hideAttackZones();
                        const otherTeam = team === 'home' ? 'away' : 'home';
                        awardPoint(otherTeam);
                        endRally();
                        return;
                    }
                    // Clic out c√¥t√© adverse ‚Üí retour direct
                    gameState.passAutoSelected = true;
                    gameState.currentAction = {
                        type: 'pass',
                        player: selectedPasser,
                        team: team,
                        role: selectedRole,
                        endPos: converted,
                        isDirectReturn: true,
                        directReturnEndPos: converted
                    };
                    const lastActionForStart = gameState.rally[gameState.rally.length - 1];
                    if (lastActionForStart && lastActionForStart.endPos) {
                        gameState.currentAction.startPos = lastActionForStart.endPos;
                    } else if (lastActionForStart && lastActionForStart.isDirectReturn && lastActionForStart.directReturnEndPos) {
                        gameState.currentAction.startPos = lastActionForStart.directReturnEndPos;
                    }
                    addMarker(converted, 'pass');
                    const lastAction = gameState.rally[gameState.rally.length - 1];
                    if (lastAction && lastAction.endPos) {
                        drawArrow(lastAction.endPos, converted, 'pass');
                    } else if (lastAction && lastAction.isDirectReturn && lastAction.directReturnEndPos) {
                        drawArrow(lastAction.directReturnEndPos, converted, 'pass');
                    }
                    document.getElementById('outArea').classList.remove('active');
                    gameState.passDirectReturnClickData = converted;
                    gameState.rally.push({ ...gameState.currentAction });
                    hideAttackZones();
                    gameState.phase = 'pass_direct_return_choice';
                    updatePhase();
                    hideAllSections();
                    document.getElementById('passDirectReturnChoice').classList.remove('hidden');
                    return;
                } else {
                    // Vraiment hors zone ‚Üí FP comme avant
                    gameState.passAutoSelected = true;
                    gameState.currentAction = {
                        type: 'pass',
                        player: selectedPasser,
                        team: team,
                        role: selectedRole,
                        endPos: clickData
                    };
                    // V20.18 : propager le flag relance si actif
                    if (gameState.context.passRelance) {
                        gameState.currentAction.passType = 'relance';
                        gameState.currentAction.result = 'out';
                        gameState.context.passRelance = false;
                    }
                    const lastActionForStart = gameState.rally[gameState.rally.length - 1];
                    if (lastActionForStart && lastActionForStart.endPos) {
                        gameState.currentAction.startPos = lastActionForStart.endPos;
                    } else if (lastActionForStart && lastActionForStart.isDirectReturn && lastActionForStart.directReturnEndPos) {
                        gameState.currentAction.startPos = lastActionForStart.directReturnEndPos;
                    }
                    gameState.rally.push({ ...gameState.currentAction });
                    const otherTeam = team === 'home' ? 'away' : 'home';
                    awardPoint(otherTeam);
                    endRally();
                    return;
                }
            }

            // Passe normale sur son propre terrain
            // D√©terminer l'attaquant selon le c√¥t√© du clic
            const autoAttacker = getAttackerFromClickX(clickData, selectedPasser);

            gameState.passAutoSelected = true;
            gameState.attackAutoSelected = !!autoAttacker;
            gameState.currentAction = {
                type: 'pass',
                player: selectedPasser,
                team: team,
                role: selectedRole,
                endPos: clickData
            };
            // V20.18 : propager le flag relance passe
            if (gameState.context.passRelance) {
                gameState.currentAction.passType = 'relance';
                gameState.context.passRelance = false;
            }

            // startPos = arrivee de la reception/defense precedente
            const lastActionForPassStart = gameState.rally[gameState.rally.length - 1];
            if (lastActionForPassStart && lastActionForPassStart.endPos) {
                gameState.currentAction.startPos = lastActionForPassStart.endPos;
            } else if (lastActionForPassStart && lastActionForPassStart.isDirectReturn && lastActionForPassStart.directReturnEndPos) {
                gameState.currentAction.startPos = lastActionForPassStart.directReturnEndPos;
            }

            addMarker(clickData, 'pass');

            // D√©sactiver la zone out
            document.getElementById('outArea').classList.remove('active');

            // Tracer fl√®che depuis la r√©ception ou d√©fense
            const lastAction = gameState.rally[gameState.rally.length - 1];
            if (lastAction && lastAction.endPos) {
                drawArrow(lastAction.endPos, clickData, 'pass');
            } else if (lastAction && lastAction.isDirectReturn && lastAction.directReturnEndPos) {
                drawArrow(lastAction.directReturnEndPos, clickData, 'pass');
            }

            gameState.rally.push({ ...gameState.currentAction });
            hideAttackZones();

            if (autoAttacker) {
                // Passe + attaque auto ‚Üí skip attack_player, aller directement √† attack_type
                selectAttacker(autoAttacker);
            } else {
                // Pas d'auto-attaquant ‚Üí flow classique
                gameState.phase = 'attack_player';
                updatePhase();
                hideAllSections();
                renderAttackPlayerSelection();
            }
        }

        function selectPasser(playerName) {
            gameState.passAutoSelected = false;
            gameState.currentAction = {
                type: 'pass',
                player: playerName,
                team: gameState.attackingTeam,
                role: getPlayerRole(gameState.attackingTeam, playerName)
            };
            gameState.phase = 'pass_end';
            updatePhase();
            hideAllSections();

            // Afficher les tags override avec le passeur s√©lectionn√©
            renderOverrideTags({
                team: gameState.attackingTeam,
                phaseLabel: 'Passe',
                autoPlayer: playerName,
                autoRole: gameState.currentAction.role,
                eligiblePlayers: getLineupPlayers(gameState.attackingTeam),
                mode: 'override'
            });

            highlightCourt(null); // Les deux terrains actifs (passe peut aller chez l'adversaire)

            // Activer la zone out pour les passes hors terrain
            document.getElementById('outArea').classList.add('active');
            // Activer la zone filet cliquable pour les passes dans le filet
            activateNetZone(true);
            // OUT des deux c√¥t√©s (passe peut aller n'importe o√π)
            document.getElementById('outLabelTop').style.display = 'block';
            document.getElementById('outLabelBottom').style.display = 'block';

            // Afficher les zones d'attaque (visual-only) pour anticiper le choix de l'attaquant
            showAttackZones(gameState.attackingTeam, playerName);
        }

        function handleSecondTouch(type) {
            // Attaque en 2√®me touche (deuxieme_main ou attaque_directe)
            // Le joueur est celui auto-s√©lectionn√© (ou overrid√©) en phase passe
            const player = getEffectivePlayer();
            if (!player) return;

            const team = gameState.attackingTeam;
            const role = getPlayerRole(team, player);

            // Cr√©er l'action d'attaque avec le type pr√©-d√©fini
            gameState.currentAction = {
                type: 'attack',
                player: player,
                team: team,
                attackType: type,
                role: role
            };

            // Passer directement √† attack_end (type d√©j√† connu, pas de choix feinte/relance)
            gameState.phase = 'attack_end';
            updatePhase();
            hideAllSections();

            // Afficher terrain adverse avec zones de d√©fense + filet
            const defendingTeam = team === 'home' ? 'away' : 'home';
            highlightCourt(defendingTeam);
            document.getElementById('outArea').classList.add('active');
            activateNetZone(true);
            const defendingCourtSide = getCourtSideForTeam(defendingTeam);
            document.getElementById('outLabelTop').style.display = defendingCourtSide === 'top' ? 'block' : 'none';
            document.getElementById('outLabelBottom').style.display = defendingCourtSide === 'bottom' ? 'block' : 'none';
            if (role) {
                showDefenseZones(defendingTeam, role);
            }

            // Override tags pour corriger le joueur si besoin
            renderOverrideTags({
                team,
                phaseLabel: type === 'deuxieme_main' ? '2√®me main' : 'Attaque directe',
                autoPlayer: player,
                autoRole: role,
                eligiblePlayers: getLineupPlayers(team),
                mode: 'override'
            });
        }

        function handlePassEnd(clickData) {
            gameState.currentAction.endPos = clickData;
            // startPos = arrivee de la reception/defense precedente
            const lastActionForPassStart = gameState.rally[gameState.rally.length - 1];
            if (lastActionForPassStart && lastActionForPassStart.endPos) {
                gameState.currentAction.startPos = lastActionForPassStart.endPos;
            } else if (lastActionForPassStart && lastActionForPassStart.isDirectReturn && lastActionForPassStart.directReturnEndPos) {
                gameState.currentAction.startPos = lastActionForPassStart.directReturnEndPos;
            }
            addMarker(clickData, 'pass');

            // D√©sactiver la zone out et le filet
            document.getElementById('outArea').classList.remove('active');
            deactivateNetZone();

            // Tracer fl√®che depuis la r√©ception ou d√©fense
            const lastAction = gameState.rally[gameState.rally.length - 1];
            if (lastAction && lastAction.endPos) {
                drawArrow(lastAction.endPos, clickData, 'pass');
            } else if (lastAction && lastAction.isDirectReturn && lastAction.directReturnEndPos) {
                drawArrow(lastAction.directReturnEndPos, clickData, 'pass');
            }

            // V√©rifier si la passe va dans le terrain adverse (retour direct)
            const passingTeam = gameState.attackingTeam;
            const passingCourtSide = getCourtSideForTeam(passingTeam);
            const oppositeCourtSide = passingCourtSide === 'top' ? 'bottom' : 'top';

            if (clickData.courtSide === oppositeCourtSide) {
                // Passe chez l'adversaire ‚Äî afficher popup de choix
                gameState.currentAction.isDirectReturn = true;
                gameState.currentAction.directReturnEndPos = clickData;
                gameState.passDirectReturnClickData = clickData;

                gameState.rally.push({ ...gameState.currentAction });

                gameState.phase = 'pass_direct_return_choice';
                updatePhase();
                hideAllSections();
                document.getElementById('passDirectReturnChoice').classList.remove('hidden');
                return;
            }

            if (clickData.courtSide === 'out') {
                // Rescue : convertir les coordonn√©es container ‚Üí court-half
                const converted = convertOutToCourtHalf(clickData);

                if (converted && converted.courtSide === passingCourtSide) {
                    // Clic out mais c√¥t√© propre terrain ‚Üí traiter comme passe normale
                    clickData = converted;
                    gameState.currentAction.endPos = clickData;
                    // NE PAS return ‚Äî continuer dans le flow normal ci-dessous
                } else if (converted && converted.courtSide === oppositeCourtSide) {
                    // V20.18 : Relance passe out c√¥t√© adverse ‚Üí faute imm√©diate (comme attaque out)
                    if (gameState.context.passRelance) {
                        gameState.currentAction.endPos = converted;
                        gameState.currentAction.passType = 'relance';
                        gameState.currentAction.result = 'out';
                        gameState.context.passRelance = false;
                        gameState.rally.push({ ...gameState.currentAction });
                        const otherTeam = passingTeam === 'home' ? 'away' : 'home';
                        awardPoint(otherTeam);
                        endRally();
                        return;
                    }
                    // Clic out c√¥t√© adverse ‚Üí retour direct
                    clickData = converted;
                    gameState.currentAction.endPos = clickData;
                    gameState.currentAction.isDirectReturn = true;
                    gameState.currentAction.directReturnEndPos = clickData;
                    gameState.passDirectReturnClickData = clickData;
                    gameState.rally.push({ ...gameState.currentAction });
                    gameState.phase = 'pass_direct_return_choice';
                    updatePhase();
                    hideAllSections();
                    document.getElementById('passDirectReturnChoice').classList.remove('hidden');
                    return;
                } else {
                    // Vraiment hors zone ‚Üí FP, point adversaire
                    // V20.18 : propager le flag relance si actif
                    if (gameState.context.passRelance) {
                        gameState.currentAction.passType = 'relance';
                        gameState.currentAction.result = 'out';
                        gameState.context.passRelance = false;
                    }
                    gameState.rally.push({ ...gameState.currentAction });
                    const otherTeam = passingTeam === 'home' ? 'away' : 'home';
                    awardPoint(otherTeam);
                    endRally();
                    return;
                }
            }

            // Passe normale sur son propre terrain
            const passer = gameState.currentAction.player;
            gameState.rally.push({ ...gameState.currentAction });

            // Auto-s√©lection de l'attaquant selon le c√¥t√© du clic
            const autoAttacker = getAttackerFromClickX(clickData, passer);

            if (autoAttacker && autoAttacker !== passer) {
                gameState.attackAutoSelected = true;
                selectAttacker(autoAttacker);
            } else {
                gameState.attackAutoSelected = false;
                gameState.phase = 'attack_player';
                updatePhase();
                renderAttackPlayerSelection();
            }
        }

        // ==================== CHOIX RETOUR DIRECT PASSE ====================
        function handlePassDirectReturnChoice(choice) {
            hideAllSections();

            if (choice === 'winner') {
                // Point direct pour l'√©quipe qui passe (la balle est tomb√©e chez l'adversaire)
                awardPoint(gameState.attackingTeam);
                endRally();

            } else if (choice === 'direct_attack') {
                // L'adversaire attaque directement la balle
                const attackingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                gameState.attackingTeam = attackingTeam;
                gameState.defenseDirectAttack = true;
                gameState.passDirectReturnAttackSource = true;

                gameState.phase = 'attack_player';
                updatePhase();
                renderAttackPlayerSelection();

            } else if (choice === 'defense') {
                // L'adversaire d√©fend
                const defendingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                gameState.attackingTeam = defendingTeam;

                highlightCourt(defendingTeam);
                gameState.phase = 'defense';
                renderDefenseSelection(defendingTeam, null);
            }
        }

        // ==================== ATTAQUE ====================
        // Affiche les zones d'attaque + tags joueurs restants pour la s√©lection de l'attaquant.
        // Affiche tags override pour s√©lection attaquant
        // Cas standard : zones R4/Pointu sur terrain + tags override (Centre, etc.)
        // Cas attaque directe (defense/filet) : pas de zones, mode select
        function renderAttackPlayerSelection() {
            const team = gameState.attackingTeam;
            const lastToucher = getLastTouchPlayer(team);

            // Pas de zones pour les attaques directes (depuis d√©fense ou filet)
            if (gameState.defenseDirectAttack || gameState.netDirectAttack) {
                renderOverrideTags({
                    team,
                    phaseLabel: 'Attaque',
                    autoPlayer: null,
                    autoRole: null,
                    eligiblePlayers: getLineupPlayers(team),
                    mode: 'select'
                });
                return;
            }

            // Afficher les zones d'attaque en excluant le joueur qui a fait la passe
            showAttackZones(team, lastToucher);

            // Tags override : tous les joueurs (la zone fournira l'auto-select au clic terrain)
            renderOverrideTags({
                team,
                phaseLabel: 'Attaque',
                autoPlayer: null,
                autoRole: null,
                eligiblePlayers: getLineupPlayers(team),
                mode: 'override'
            });
        }

        function selectAttacker(playerName) {
            hideAttackZones();
            gameState.currentAction = {
                type: 'attack',
                player: playerName,
                team: gameState.attackingTeam,
                role: getPlayerRole(gameState.attackingTeam, playerName)
            };

            // Si c'est une attaque directe depuis la d√©fense, marquer le type
            if (gameState.defenseDirectAttack) {
                gameState.currentAction.isDefenseDirectAttack = true;
                gameState.defenseDirectAttack = false; // Reset le flag
            }
            
            // Si c'est une attaque directe depuis une r√©ception dans le filet
            if (gameState.netDirectAttack) {
                gameState.currentAction.isNetDirectAttack = true;
                gameState.netDirectAttack = false; // Reset le flag
            }
            
            gameState.phase = 'attack_type';
            updatePhase();
            showSection('attackTypeSelection');

            // Afficher les tags override avec l'attaquant s√©lectionn√©
            renderOverrideTags({
                team: gameState.attackingTeam,
                phaseLabel: 'Attaque',
                autoPlayer: playerName,
                autoRole: gameState.currentAction.role,
                eligiblePlayers: getLineupPlayers(gameState.attackingTeam),
                mode: 'override'
            });

            // Activer le terrain adverse pour permettre un clic direct = smash
            const defendingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
            highlightCourt(defendingTeam);
            document.getElementById('outArea').classList.add('active');
            activateNetZone(true);
            // Afficher les labels OUT c√¥t√© d√©fenseur (haut/bas + lat√©raux)
            const defendingCourtSide = getCourtSideForTeam(defendingTeam);
            document.getElementById('outLabelTop').style.display = defendingCourtSide === 'top' ? 'block' : 'none';
            document.getElementById('outLabelBottom').style.display = defendingCourtSide === 'bottom' ? 'block' : 'none';
            // Afficher les zones de d√©fense sur le terrain d√©fenseur
            const attackerRole = gameState.currentAction.role;
            if (attackerRole) {
                showDefenseZones(defendingTeam, attackerRole);
            }
        }

        function selectAttackType(type) {
            gameState.currentAction.attackType = type;

            // Passer directement √† attack_end (le d√©part sera la position de la passe)
            gameState.phase = 'attack_end';
            updatePhase();
            hideAllSections();

            // Afficher les tags override avec l'attaquant
            const attacker = gameState.currentAction.player;
            const attackerRoleForTags = gameState.currentAction.role;
            renderOverrideTags({
                team: gameState.attackingTeam,
                phaseLabel: 'Attaque',
                autoPlayer: attacker,
                autoRole: attackerRoleForTags,
                eligiblePlayers: getLineupPlayers(gameState.attackingTeam),
                mode: 'override'
            });

            // Highlight terrain adverse pour l'arriv√©e de l'attaque
            const defendingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
            highlightCourt(defendingTeam);
            document.getElementById('outArea').classList.add('active');
            activateNetZone(true);
            // Afficher les zones de d√©fense sur le terrain d√©fenseur
            const attackerRole = gameState.currentAction.role;
            if (attackerRole) {
                showDefenseZones(defendingTeam, attackerRole);
            }
        }

        function handleAttackEnd(clickData) {
            hideDefenseZones();
            gameState.currentAction.endPos = clickData;
            // startPos = arrivee de la passe (ou reception/defense pour attaque directe)
            const lastActionForAttStart = gameState.rally[gameState.rally.length - 1];
            if (gameState.currentAction.isDefenseDirectAttack) {
                if (lastActionForAttStart && lastActionForAttStart.isDirectReturn && lastActionForAttStart.directReturnEndPos) {
                    gameState.currentAction.startPos = lastActionForAttStart.directReturnEndPos;
                } else if (lastActionForAttStart && lastActionForAttStart.endPos) {
                    gameState.currentAction.startPos = lastActionForAttStart.endPos;
                }
            } else if (lastActionForAttStart && lastActionForAttStart.endPos) {
                gameState.currentAction.startPos = lastActionForAttStart.endPos;
            }
            deactivateNetZone();
            
            // D√©terminer le type de marker/fl√®che selon le type d'attaque
            let arrowType = 'attack';
            if (gameState.currentAction.attackType === 'feinte') {
                arrowType = 'attack-feinte';
            } else if (gameState.currentAction.attackType === 'relance') {
                arrowType = 'attack-relance';
            } else if (gameState.currentAction.attackType === 'deuxieme_main' || gameState.currentAction.attackType === 'attaque_directe') {
                arrowType = 'attack-second';
            }
            
            addMarker(clickData, arrowType);
            
            // Tracer fl√®che depuis la passe (ou r√©ception/d√©fense si 2√®me touche, ou action pr√©c√©dente si attaque directe d√©fense)
            const lastAction = gameState.rally[gameState.rally.length - 1];
            
            if (gameState.currentAction.isDefenseDirectAttack) {
                // Attaque directe depuis la d√©fense: la fl√®che part de l'action pr√©c√©dente (attaque adverse, block, ou retour direct)
                if (lastAction && lastAction.type === 'reception' && lastAction.isDirectReturn && lastAction.directReturnEndPos) {
                    drawArrow(lastAction.directReturnEndPos, clickData, arrowType);
                } else if (lastAction && lastAction.type === 'defense' && lastAction.isDirectReturn && lastAction.directReturnEndPos) {
                    drawArrow(lastAction.directReturnEndPos, clickData, arrowType);
                } else if (lastAction && lastAction.endPos) {
                    drawArrow(lastAction.endPos, clickData, arrowType);
                }
            } else if (gameState.currentAction.isNetDirectAttack) {
                // Attaque directe depuis r√©ception filet: la fl√®che part de la position du filet (endPos de la r√©ception)
                if (lastAction && lastAction.endPos) {
                    drawArrow(lastAction.endPos, clickData, arrowType);
                }
            } else if (lastAction && lastAction.endPos) {
                drawArrow(lastAction.endPos, clickData, arrowType);
            }

            // V√©rifier si attaque faute (hors du terrain d√©fenseur)
            const defendingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
            const expectedCourtSide = getCourtSideForTeam(defendingTeam);

            if (clickData.courtSide !== expectedCourtSide) {
                // Attaque out = point pour l'adversaire
                gameState.currentAction.result = 'out';
                gameState.rally.push({ ...gameState.currentAction });
                awardPoint(defendingTeam);
                endRally();
            } else {
                // Attaque dans le terrain, demander le r√©sultat
                gameState.rally.push({ ...gameState.currentAction });
                gameState.phase = 'result';
                updatePhase();
                showSection('resultSelection');

                // Activer la zone out pour les d√©fenses hors terrain
                const defTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                document.getElementById('outArea').classList.add('active');
                const defCourtSide = getCourtSideForTeam(defTeam);
                document.getElementById('outLabelTop').style.display = defCourtSide === 'top' ? 'block' : 'none';
                document.getElementById('outLabelBottom').style.display = defCourtSide === 'bottom' ? 'block' : 'none';

                // Afficher la zone Def+ (pas les zones de d√©fense ‚Äî elles sont affich√©es plus t√¥t en phase attaque)
                hideDefenseZones();
                showDefenseQualityZones(defTeam);

                // Afficher les tags override pour le r√©sultat (d√©fenseur pr√©-s√©lectionn√© ou non)
                const defAutoPlayer = (gameState.defenseAutoSelected && gameState.defenseAutoPlayer) ? gameState.defenseAutoPlayer : null;
                const defAutoRole = defAutoPlayer ? getPlayerRole(defTeam, defAutoPlayer) : null;
                renderOverrideTags({
                    team: defTeam,
                    phaseLabel: 'R√©sultat',
                    autoPlayer: defAutoPlayer,
                    autoRole: defAutoRole,
                    eligiblePlayers: getLineupPlayers(defTeam),
                    mode: 'override'
                });
            }
        }

        function handleResultCourtClick(clickData) {
            // En phase r√©sultat, un clic sur le terrain = auto "D√©fendu"
            // La zone Def+ est affich√©e : on stocke la position pour qualifier D+/D-
            gameState.pendingDefenseClickData = clickData;
            hideDefenseQualityZones();
            selectResult('defended');
        }

        function handleResultDefenseZoneClick(defenderName, clickData) {
            // Clic dans une zone de d√©fense en phase r√©sultat :
            // 1 clic = D√©fendu + d√©fenseur auto-s√©lectionn√© ‚Üí affiche zone D+ pour le 2√®me clic

            // 1. Marquer l'attaque comme "defended"
            const lastAction = gameState.rally[gameState.rally.length - 1];
            lastAction.result = 'defended';

            // 2. Cacher les zones de d√©fense et le panneau r√©sultat
            hideDefenseZones();
            document.getElementById('outArea').classList.remove('active');

            // 3. Changer l'√©quipe attaquante (celle qui d√©fend va contre-attaquer)
            const newAttackingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
            gameState.attackingTeam = newAttackingTeam;

            // 4. Passer par selectDefender qui affiche la zone D+ pour qualifier la d√©fense
            gameState.defenseAutoSelected = false;
            gameState.defenseAutoPlayer = null;
            selectDefender(defenderName);
        }

        function completeDefenseFromResult(defenderName, clickData) {
            // D√©fense compl√®te : d√©fenseur + position D+/D- connus
            gameState.currentAction = {
                type: 'defense',
                player: defenderName,
                team: gameState.attackingTeam,
                role: getPlayerRole(gameState.attackingTeam, defenderName)
            };

            // V√©rifier si le clic est sur le terrain adverse ‚Üí retour direct de d√©fense
            const defendingTeam = gameState.attackingTeam;
            const defendingCourtSide = getCourtSideForTeam(defendingTeam);
            const oppositeCourtSide = defendingCourtSide === 'top' ? 'bottom' : 'top';

            if (clickData.courtSide === oppositeCourtSide) {
                // Retour direct : router vers handleDefenseDirectReturn
                handleDefenseDirectReturn(clickData);
                return;
            }

            // Calculer la qualit√© D+/D-
            if (clickData.courtSide === 'out') {
                gameState.currentAction.defenseQuality = 'negative';
            } else {
                gameState.currentAction.defenseQuality = calculateDefenseQuality(clickData);
            }

            // Positions
            gameState.currentAction.endPos = clickData;
            const prevActionForDefStart = gameState.rally[gameState.rally.length - 1];
            if (prevActionForDefStart && prevActionForDefStart.isDirectReturn && prevActionForDefStart.directReturnEndPos) {
                gameState.currentAction.startPos = prevActionForDefStart.directReturnEndPos;
            } else if (prevActionForDefStart && prevActionForDefStart.endPos) {
                gameState.currentAction.startPos = prevActionForDefStart.endPos;
            }

            // Markers et fl√®ches
            addMarker(clickData, 'defense');
            const prevAction = gameState.rally[gameState.rally.length - 1];
            if (prevAction && prevAction.type === 'reception' && prevAction.isDirectReturn && prevAction.directReturnEndPos) {
                drawArrow(prevAction.directReturnEndPos, clickData, 'defense');
            } else if (prevAction && prevAction.type === 'defense' && prevAction.isDirectReturn && prevAction.directReturnEndPos) {
                drawArrow(prevAction.directReturnEndPos, clickData, 'defense');
            } else if (prevAction && prevAction.endPos) {
                if (prevAction.type === 'block' || prevAction.type === 'attack') {
                    drawArrow(prevAction.endPos, clickData, 'defense');
                }
            }

            // Ajouter au rally
            gameState.rally.push({ ...gameState.currentAction });

            // Passer √† la phase passe
            gameState.passAutoSelected = false;
            gameState.phase = 'pass';
            updatePhase();
            hideAllSections();
            highlightCourt(null);

            document.getElementById('outArea').classList.add('active');
            document.getElementById('outLabelTop').style.display = 'block';
            document.getElementById('outLabelBottom').style.display = 'block';
            activateNetZone(true);

            renderPassPlayerSelection();
        }

        function selectResult(result) {
            const lastAction = gameState.rally[gameState.rally.length - 1];
            lastAction.result = result;

            // Cacher les zones de d√©fense, la zone D+ et d√©sactiver la zone out
            hideDefenseZones();
            hideDefenseQualityZones();
            document.getElementById('outArea').classList.remove('active');

            // Nettoyer pendingDefenseClickData pour les cas non-defended
            if (result !== 'defended') {
                gameState.pendingDefenseClickData = null;
            }

            if (result === 'point') {
                // V20.15 : enregistrer FD pour le d√©fenseur s√©lectionn√©
                const defendingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                const fdPlayer = getEffectivePlayer() || gameState.defenseAutoPlayer;

                if (fdPlayer) {
                    const fdRole = getPlayerRole(defendingTeam, fdPlayer);
                    gameState.rally.push({
                        type: 'defense',
                        player: fdPlayer,
                        team: defendingTeam,
                        role: fdRole,
                        untouched: true,
                        result: 'fault'
                    });
                }

                gameState.defenseAutoSelected = false;
                gameState.defenseAutoPlayer = null;
                awardPoint(gameState.attackingTeam);
                endRally();
            } else if (result === 'defended') {
                // D√©fendu : l'autre √©quipe d√©fend et va contre-attaquer
                const attackerRole = lastAction.role;
                const newAttackingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                gameState.attackingTeam = newAttackingTeam;

                const pendingClick = gameState.pendingDefenseClickData;
                gameState.pendingDefenseClickData = null;

                if (pendingClick && gameState.defenseAutoSelected && gameState.defenseAutoPlayer) {
                    // Position D+/D- connue + d√©fenseur pr√©-s√©lectionn√© ‚Üí d√©fense compl√®te en 1 clic
                    // L'override permet de corriger le d√©fenseur pr√©-s√©lectionn√©
                    const effectiveDefender = getEffectivePlayer() || gameState.defenseAutoPlayer;
                    gameState.defenseAutoSelected = false;
                    gameState.defenseAutoPlayer = null;
                    completeDefenseFromResult(effectiveDefender, pendingClick);
                } else if (pendingClick) {
                    // Position D+/D- connue mais pas de d√©fenseur ‚Üí demander qui d√©fend
                    gameState.pendingDefenseClickData = pendingClick; // re-stocker pour selectDefender
                    gameState.defenseAutoSelected = false;
                    gameState.defenseAutoPlayer = null;
                    gameState.phase = 'defense';
                    renderDefenseSelection(newAttackingTeam, attackerRole);
                } else if (gameState.defenseAutoSelected && gameState.defenseAutoPlayer) {
                    // D√©fenseur pr√©-s√©lectionn√© mais pas de position ‚Üí afficher zone D+
                    const autoPlayer = gameState.defenseAutoPlayer;
                    gameState.defenseAutoSelected = false;
                    gameState.defenseAutoPlayer = null;
                    gameState.phase = 'defense';
                    updatePhase();
                    selectDefender(autoPlayer);
                } else {
                    // Rien de pr√©-s√©lectionn√© ‚Üí flux normal (s√©lection d√©fenseur + zone D+)
                    gameState.phase = 'defense';
                    renderDefenseSelection(newAttackingTeam, attackerRole);
                }
            } else if (result === 'defense_fault') {
                // D√©fense faute directe depuis le r√©sultat d'attaque
                // L'attaque a bien √©t√© d√©fendue, mais la d√©fense est en faute
                lastAction.result = 'defended';
                const attackerRole = lastAction.role;
                const newAttackingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                gameState.attackingTeam = newAttackingTeam;
                gameState.defenseFaultShortcut = true;

                if (gameState.defenseAutoSelected && gameState.defenseAutoPlayer) {
                    const autoPlayer = gameState.defenseAutoPlayer;
                    gameState.defenseAutoSelected = false;
                    gameState.defenseAutoPlayer = null;
                    gameState.phase = 'defense';
                    updatePhase();
                    selectDefender(autoPlayer);
                } else {
                    gameState.phase = 'defense';
                    renderDefenseSelection(newAttackingTeam, attackerRole);
                }
            } else if (result === 'blocked') {
                // Block√©e : on demande d'abord o√π arrive le block
                gameState.defenseAutoSelected = false;
                gameState.defenseAutoPlayer = null;
                gameState.currentAction = {
                    type: 'block',
                    team: gameState.attackingTeam === 'home' ? 'away' : 'home' // L'√©quipe qui a bloqu√©
                };
                gameState.phase = 'block_end';
                updatePhase();
                hideAllSections();
                // Le block arrive sur le terrain de l'attaquant
                highlightCourt(gameState.attackingTeam);
            }
        }

        // ==================== BLOC OUT ====================
        function selectBlocOutPlayer(playerName) {
            const blockingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
            const lastAttack = [...gameState.rally].reverse().find(a => a.type === 'attack');

            // Marquer l'attaque comme bloc_out
            if (lastAttack) {
                lastAttack.result = 'bloc_out';
            }

            // Enregistrer le block out dans le rally
            gameState.rally.push({
                type: 'block',
                player: playerName,
                team: blockingTeam,
                role: getPlayerRole(blockingTeam, playerName),
                result: 'bloc_out'
            });

            delete gameState.blocOutPending;
            // Passer en mode trajectoire pour enregistrer les coordonn√©es du bloc out
            startBlocOutTrajectory();
        }

        function startBlocOutTrajectory() {
            gameState.phase = 'bloc_out_trajectory';
            updatePhase();
            hideAllSections();
            document.getElementById('blocOutTrajectory').classList.remove('hidden');

            // Afficher les tags avec le bloqueur s√©lectionn√©
            const lastBlock = [...gameState.rally].reverse().find(a => a.type === 'block');
            if (lastBlock && lastBlock.player) {
                renderOverrideTags({
                    team: lastBlock.team,
                    phaseLabel: 'Bloc out',
                    autoPlayer: lastBlock.player,
                    autoRole: lastBlock.role,
                    eligiblePlayers: getLineupPlayers(lastBlock.team),
                    mode: 'override'
                });
            }

            // Activer les deux terrains et la zone out
            document.getElementById('outArea').classList.add('active');
            document.getElementById('outLabelTop').style.display = 'block';
            document.getElementById('outLabelBottom').style.display = 'block';
            highlightCourt(null);
        }

        function handleBlocOutTrajectoryEnd(clickData) {
            // Enregistrer les coordonn√©es du bloc out sur le dernier block du rally
            const lastBlock = [...gameState.rally].reverse().find(a => a.type === 'block');
            if (lastBlock) {
                lastBlock.endPos = clickData;
                // 2 fl√®ches : attaque ‚Üí filet + filet ‚Üí atterrissage bloc out
                const lastAttack = [...gameState.rally].reverse().find(a => a.type === 'attack');
                if (lastAttack && lastAttack.endPos) {
                    const netPos = getNetCenteredPos(lastAttack.endPos);
                    lastBlock.startPos = netPos;
                    drawArrow(lastAttack.endPos, netPos, getAttackArrowType(lastAttack.attackType));
                    drawArrow(netPos, clickData, 'block-touch');
                }
            }
            addMarker(clickData, 'block-touch');

            // D√©sactiver zones
            document.getElementById('outArea').classList.remove('active');
            document.getElementById('blocOutTrajectory').classList.add('hidden');

            // Terminer le point ‚Äî utiliser blocOutAttackingTeam si d√©fini (cas vue d√©fense)
            const pointWinner = gameState.blocOutAttackingTeam || gameState.attackingTeam;
            delete gameState.blocOutAttackingTeam;
            awardPoint(pointWinner);
            endRally();
        }

        function skipBlocOutTrajectory() {
            document.getElementById('outArea').classList.remove('active');
            document.getElementById('blocOutTrajectory').classList.add('hidden');
            const pointWinner = gameState.blocOutAttackingTeam || gameState.attackingTeam;
            delete gameState.blocOutAttackingTeam;
            awardPoint(pointWinner);
            endRally();
        }

        // ==================== BLOCK ====================
        function handleBlockEnd(clickData) {
            gameState.currentAction.endPos = clickData;
            addMarker(clickData, 'block-touch');

            // Tracer 2 fl√®ches : attaque ‚Üí filet (couleur attaque) + filet ‚Üí atterrissage (block-touch)
            const lastAttack = [...gameState.rally].reverse().find(a => a.type === 'attack');
            if (lastAttack && lastAttack.endPos) {
                const netPos = getNetCenteredPos(lastAttack.endPos);
                drawArrow(lastAttack.endPos, netPos, getAttackArrowType(lastAttack.attackType));
                drawArrow(netPos, clickData, 'block-touch');
            }

            gameState.rally.push({ ...gameState.currentAction });

            // Passer √† la d√©fense (m√™me √©quipe que l'attaquant)
            gameState.phase = 'defense';
            // Activer la zone out pour permettre l'auto-s√©lection du d√©fenseur hors terrain
            document.getElementById('outArea').classList.add('active');
            // Afficher les zones de d√©fense (bas√©es sur l'attaquant adverse)
            // Apr√®s un bloc : PAS de zones auto-select (soutien = al√©atoire)
            renderDefenseSelection(gameState.attackingTeam, null, true);
        }

        // ==================== D√âFENSE ====================
        function selectDefender(playerName) {
            hideDefenseZones();
            hideAttackZones();
            gameState.currentAction = {
                type: 'defense',
                player: playerName,
                team: gameState.attackingTeam,
                role: getPlayerRole(gameState.attackingTeam, playerName)
            };

            // Si on vient du raccourci "D√©fense faute" depuis le r√©sultat d'attaque
            if (gameState.defenseFaultShortcut) {
                gameState.defenseFaultShortcut = false;
                handleDefenseFault();
                return;
            }

            // Si on a une position D+/D- en attente (clic terrain en phase result)
            // ‚Üí compl√©ter la d√©fense directement sans passer par defense_end
            if (gameState.pendingDefenseClickData) {
                const pendingClick = gameState.pendingDefenseClickData;
                gameState.pendingDefenseClickData = null;
                completeDefenseFromResult(playerName, pendingClick);
                return;
            }

            gameState.phase = 'defense_end';
            updatePhase();
            hideAllSections();

            // Afficher les tags override avec le d√©fenseur s√©lectionn√©
            renderOverrideTags({
                team: gameState.attackingTeam,
                phaseLabel: 'D√©fense',
                autoPlayer: playerName,
                autoRole: gameState.currentAction.role,
                eligiblePlayers: getLineupPlayers(gameState.attackingTeam),
                mode: 'override'
            });

            // Afficher le bouton D√©fense faute
            document.getElementById('defenseFaultSection').classList.remove('hidden');

            // Afficher la zone de qualit√© D+
            showDefenseQualityZones();

            // Highlight terrain d√©fenseur (adverse gris√© mais cliquable pour retour direct)
            highlightCourt(gameState.attackingTeam);

            // Activer la zone out pour les d√©fenses hors terrain
            document.getElementById('outArea').classList.add('active');
            // Afficher tous les labels OUT sauf celui c√¥t√© adverse (la balle peut y aller mais pas en out)
            const defendingCourtSide = getCourtSideForTeam(gameState.attackingTeam);
            document.getElementById('outLabelTop').style.display = defendingCourtSide === 'top' ? 'block' : 'none';
            document.getElementById('outLabelBottom').style.display = defendingCourtSide === 'bottom' ? 'block' : 'none';
        }

        function handleDefenseEnd(clickData) {
            // D√©sactiver la zone out et cacher la zone D+
            document.getElementById('outArea').classList.remove('active');
            hideDefenseQualityZones();

            // V√©rifier si la d√©fense va dans le terrain adverse
            const defendingTeam = gameState.attackingTeam;
            const defendingCourtSide = getCourtSideForTeam(defendingTeam);
            const oppositeCourtSide = defendingCourtSide === 'top' ? 'bottom' : 'top';

            // Si le clic est sur le terrain adverse, c'est un retour direct de d√©fense
            if (clickData.courtSide === oppositeCourtSide) {
                handleDefenseDirectReturn(clickData);
                return;
            }

            // Calculer la qualit√© de la d√©fense (D+ ou D-)
            if (clickData.courtSide === 'out') {
                gameState.currentAction.defenseQuality = 'negative'; // D-
            } else {
                gameState.currentAction.defenseQuality = calculateDefenseQuality(clickData);
            }

            gameState.currentAction.endPos = clickData;
            // startPos = arrivee de l'attaque/block/retour direct precedent
            const prevActionForDefStart = gameState.rally[gameState.rally.length - 1];
            if (prevActionForDefStart && prevActionForDefStart.isDirectReturn && prevActionForDefStart.directReturnEndPos) {
                gameState.currentAction.startPos = prevActionForDefStart.directReturnEndPos;
            } else if (prevActionForDefStart && prevActionForDefStart.endPos) {
                gameState.currentAction.startPos = prevActionForDefStart.endPos;
            }
            addMarker(clickData, 'defense');

            // Tracer fl√®che depuis l'action pr√©c√©dente
            const prevAction = gameState.rally[gameState.rally.length - 1];
            
            if (prevAction && prevAction.type === 'reception' && prevAction.isDirectReturn && prevAction.directReturnEndPos) {
                // Cas du retour direct : la fl√®che part du point d'arriv√©e du retour direct
                drawArrow(prevAction.directReturnEndPos, clickData, 'defense');
            } else if (prevAction && prevAction.type === 'defense' && prevAction.isDirectReturn && prevAction.directReturnEndPos) {
                // Cas du retour direct de d√©fense pr√©c√©dente
                drawArrow(prevAction.directReturnEndPos, clickData, 'defense');
            } else if (prevAction && prevAction.endPos) {
                if (prevAction.type === 'block') {
                    drawArrow(prevAction.endPos, clickData, 'defense');
                } else if (prevAction.type === 'attack') {
                    drawArrow(prevAction.endPos, clickData, 'defense');
                }
            }

            gameState.rally.push({ ...gameState.currentAction });
            
            // Passer √† la passe (nouveau flow combin√©)
            gameState.passAutoSelected = false;
            gameState.phase = 'pass';
            updatePhase();
            hideAllSections();
            highlightCourt(null);
            
            // Activer le terrain et la zone out
            document.getElementById('outArea').classList.add('active');
            document.getElementById('outLabelTop').style.display = 'block';
            document.getElementById('outLabelBottom').style.display = 'block';
            activateNetZone(true);

            renderPassPlayerSelection();
        }

        function handleDefenseDirectReturn(clickData) {
            // La d√©fense va directement dans le terrain adverse ‚Äî afficher le popup de choix
            gameState.currentAction.isDirectReturn = true;
            gameState.currentAction.directReturnEndPos = clickData;

            // Trouver le point de d√©part de la d√©fense (depuis l'action pr√©c√©dente)
            const prevAction = gameState.rally[gameState.rally.length - 1];
            let defenseStartPos = null;

            if (prevAction && prevAction.type === 'reception' && prevAction.isDirectReturn && prevAction.directReturnEndPos) {
                defenseStartPos = prevAction.directReturnEndPos;
            } else if (prevAction && prevAction.type === 'defense' && prevAction.isDirectReturn && prevAction.directReturnEndPos) {
                defenseStartPos = prevAction.directReturnEndPos;
            } else if (prevAction && prevAction.endPos) {
                defenseStartPos = prevAction.endPos;
            }

            gameState.currentAction.endPos = defenseStartPos;
            gameState.currentAction.startPos = defenseStartPos;

            // Ajouter markers et fl√®che
            if (defenseStartPos) {
                addMarker(defenseStartPos, 'defense');
            }
            addMarker(clickData, 'defense');
            if (defenseStartPos) {
                drawArrow(defenseStartPos, clickData, 'defense');
            }

            // Sauvegarder les donn√©es pour les choix ult√©rieurs
            gameState.defenseDirectReturnClickData = clickData;

            // Afficher le popup de choix
            gameState.phase = 'defense_direct_return_choice';
            updatePhase();
            hideAllSections();
            document.getElementById('defenseDirectReturnChoice').classList.remove('hidden');
        }

        function handleDefenseDirectReturnChoice(choice) {
            hideAllSections();

            if (choice === 'winner') {
                // Retour gagnant = D- + point direct
                gameState.currentAction.isDirectReturnWinner = true;
                gameState.currentAction.defenseQuality = 'negative';
                gameState.rally.push({ ...gameState.currentAction });

                // Point pour l'√©quipe qui d√©fend
                awardPoint(gameState.attackingTeam);
                endRally();

            } else if (choice === 'direct_attack') {
                // Attaque directe = D- + l'adversaire attaque directement la balle
                gameState.currentAction.defenseQuality = 'negative';
                gameState.rally.push({ ...gameState.currentAction });

                // L'√©quipe adverse passe en attaque directe
                const attackingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                gameState.attackingTeam = attackingTeam;
                gameState.defenseDirectAttack = true;
                gameState.defenseDirectReturnAttackSource = true;

                gameState.phase = 'attack_player';
                updatePhase();
                renderAttackPlayerSelection();

            } else if (choice === 'defense') {
                // D√©fendu = D- + l'adversaire d√©fend
                gameState.currentAction.defenseQuality = 'negative';
                gameState.rally.push({ ...gameState.currentAction });

                // L'√©quipe adverse doit maintenant d√©fendre
                const newDefendingTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';
                gameState.attackingTeam = newDefendingTeam;

                highlightCourt(newDefendingTeam);
                gameState.phase = 'defense';
                renderDefenseSelection(newDefendingTeam, null);
            }
        }


        function handleDefensePoint() {
            // Point adverse : l'attaque a travers√© le block et touch√© le sol
            // En phase defense_end, attackingTeam = l'√©quipe qui d√©fend (apr√®s le block)
            // L'attaquant original (qui a marqu√© le point) est l'√©quipe adverse
            hideDefenseQualityZones();
            hideAllSections();

            const scoringTeam = gameState.attackingTeam === 'home' ? 'away' : 'home';

            // Marquer l'attaque comme point
            const lastAttack = [...gameState.rally].reverse().find(a => a.type === 'attack');
            if (lastAttack) {
                lastAttack.result = 'point';
            }

            // V20.15 : enregistrer FD si un d√©fenseur est s√©lectionn√©
            const effectivePlayer = getEffectivePlayer() || gameState.currentAction.player;
            if (effectivePlayer) {
                const effectiveRole = getPlayerRole(gameState.attackingTeam, effectivePlayer);
                gameState.rally.push({
                    type: 'defense',
                    player: effectivePlayer,
                    team: gameState.attackingTeam,
                    role: effectiveRole,
                    untouched: true,
                    result: 'fault'
                });
            }

            gameState.currentAction = {};
            awardPoint(scoringTeam);
            endRally();
        }

        function handleDefenseFault() {
            // Cacher la zone D+
            hideDefenseQualityZones();
            // D√©fense faute = passer en mode trajectoire pour savoir o√π va la balle
            gameState.currentAction.result = 'fault';

            // Masquer les sections et passer en mode trajectoire
            hideAllSections();
            document.getElementById('defenseFaultTrajectory').classList.remove('hidden');

            gameState.phase = 'defense_fault_trajectory';
            updatePhase();

            // Activer les deux terrains et la zone out pour cliquer o√π va la balle
            document.getElementById('outArea').classList.add('active');
            document.getElementById('outLabelTop').style.display = 'block';
            document.getElementById('outLabelBottom').style.display = 'block';
            highlightCourt(null);
        }

        function handleDefenseFaultTrajectoryEnd(clickData) {
            // Enregistrer la trajectoire de la faute de d√©fense
            gameState.currentAction.faultTrajectory = clickData;

            // Tracer la fl√®che de la trajectoire de faute depuis l'action pr√©c√©dente
            const prevAction = gameState.rally[gameState.rally.length - 1];
            if (prevAction && prevAction.isDirectReturn && prevAction.directReturnEndPos) {
                drawArrow(prevAction.directReturnEndPos, clickData, 'defense');
                addMarker(prevAction.directReturnEndPos, 'defense');
            } else if (prevAction && prevAction.endPos) {
                drawArrow(prevAction.endPos, clickData, 'defense');
                addMarker(prevAction.endPos, 'defense');
            }
            addMarker(clickData, 'defense');

            // D√©sactiver zones
            document.getElementById('outArea').classList.remove('active');
            document.getElementById('defenseFaultTrajectory').classList.add('hidden');

            // Finaliser la faute de d√©fense
            finalizeDefenseFault();
        }

        function skipDefenseFaultTrajectory() {
            // Passer la trajectoire, finaliser directement
            document.getElementById('outArea').classList.remove('active');
            document.getElementById('defenseFaultTrajectory').classList.add('hidden');
            finalizeDefenseFault();
        }

        function finalizeDefenseFault() {
            const defendingTeam = gameState.attackingTeam;
            const scoringTeam = defendingTeam === 'home' ? 'away' : 'home';

            gameState.currentAction.endPos = gameState.currentAction.faultTrajectory || null;
            // startPos = arrivee de l'attaque/block precedent
            const prevForDefFault = gameState.rally[gameState.rally.length - 1];
            if (prevForDefFault && prevForDefFault.isDirectReturn && prevForDefFault.directReturnEndPos) {
                gameState.currentAction.startPos = prevForDefFault.directReturnEndPos;
            } else if (prevForDefFault && prevForDefFault.endPos) {
                gameState.currentAction.startPos = prevForDefFault.endPos;
            }
            gameState.rally.push({ ...gameState.currentAction });

            awardPoint(scoringTeam);
            endRally();
        }

        function handleDefenseDirectAttack() {
            hideDefenseZones();
            // Attaque directe depuis la d√©fense (sans passe)
            // On passe directement √† la s√©lection de l'attaquant
            gameState.defenseDirectAttack = true; // Flag pour savoir qu'on vient de la d√©fense
            gameState.phase = 'attack_player';
            updatePhase();
            hideAllSections();
            renderAttackPlayerSelection();
        }

        // ==================== GESTION DES POINTS ====================
        function awardPoint(team) {
            if (team === 'home') {
                gameState.homeScore++;
            } else {
                gameState.awayScore++;
            }
            updateScore();

            // Changement de service si l'√©quipe qui re√ßoit gagne le point
            if (team !== gameState.servingTeam) {
                gameState.servingTeam = team;
                gameState.currentServer = null; // Nouveau serveur √† choisir
            }
            // Si team === servingTeam, currentServer reste (m√™me serveur continue)

            // Sauvegarder
            saveCurrentSet();

            // V√©rifier fin de set (met le flag setEnded si c'est fini)
            gameState.setEnded = false;
            checkSetEnd();
        }

        function checkSetEnd() {
            const home = gameState.homeScore;
            const away = gameState.awayScore;

            // Tie-break (set 5 quand 2-2) = 15 pts, sinon 25 pts
            const target = Storage.getTargetScore(currentMatch);

            // Set gagn√© √† 25 avec 2 points d'√©cart
            if ((home >= target || away >= target) && Math.abs(home - away) >= 2) {
                gameState.setEnded = true;
                openEndSetModal('auto');
            }
        }

        // ==================== FIN DU SET ====================
        let endSetState = {
            mode: null,     // 'auto', 'manual'
            reason: null,   // null, 'camera', 'time'
        };

        function openEndSetModal(mode) {
            endSetState.mode = mode;
            endSetState.reason = null;

            const opponent = currentMatch.opponent || 'Adversaire';
            const home = gameState.homeScore;
            const away = gameState.awayScore;

            // Mettre √† jour les noms
            document.getElementById('endSetAwayName').textContent = opponent;
            document.getElementById('realScoreAwayLabel').textContent = opponent;

            // Score
            const homeEl = document.getElementById('endSetHomeScore');
            const awayEl = document.getElementById('endSetAwayScore');
            homeEl.textContent = home;
            awayEl.textContent = away;

            // Reset des classes winner/loser
            homeEl.classList.remove('winner', 'loser');
            awayEl.classList.remove('winner', 'loser');

            if (mode === 'auto') {
                // Fin automatique ‚Äî on sait qui a gagn√©
                const winner = home > away ? 'home' : 'away';
                const winnerName = winner === 'home' ? 'Jen et ses Saints' : opponent;
                
                homeEl.classList.add(home > away ? 'winner' : 'loser');
                awayEl.classList.add(away > home ? 'winner' : 'loser');

                document.getElementById('endSetIcon').textContent = 'üèÜ';
                document.getElementById('endSetTitle').textContent = 'Fin du Set !';
                document.getElementById('endSetSubtitle').textContent = `Set ${setIndex + 1} termin√© ‚Äî ${Storage.getTargetScore(currentMatch)} points atteints`;
                document.getElementById('endSetWinner').textContent = `üéâ ${winnerName} remporte le set`;
                document.getElementById('endSetWinner').style.display = 'block';
                document.getElementById('endSetReasons').style.display = 'none';
                document.getElementById('endSetRealScore').classList.remove('visible');
                document.getElementById('endSetCancelBtn').style.display = 'none';
                document.getElementById('endSetBackBtn').style.display = 'block';
                // Match termin√© ?
            const tempSet = { ...currentSet, completed: true, winner: home > away ? 'home' : 'away', finalHomeScore: home, finalAwayScore: away };
            const tempMatch = { ...currentMatch, sets: currentMatch.sets.map((s, i) => i === setIndex ? tempSet : s) };
            if (Storage.isMatchOver(tempMatch)) {
                document.getElementById('endSetConfirmBtn').textContent = 'Fin du match \u2192';
            } else if (Storage.isTieBreak(tempMatch)) {
                document.getElementById('endSetConfirmBtn').textContent = 'Tie-break \u2192';
            } else {
                document.getElementById('endSetConfirmBtn').textContent = 'Set suivant \u2192';
            }
                document.getElementById('endSetConfirmBtn').disabled = false;
            } else {
                // Mode manuel
                document.getElementById('endSetIcon').textContent = 'üëç';
                document.getElementById('endSetTitle').textContent = 'Terminer le set ?';
                document.getElementById('endSetSubtitle').textContent = `Set ${setIndex + 1} ‚Äî Score actuel`;
                document.getElementById('endSetWinner').style.display = 'none';
                document.getElementById('endSetReasons').style.display = 'flex';
                document.getElementById('endSetRealScore').classList.remove('visible');
                document.getElementById('endSetCancelBtn').style.display = 'block';
                document.getElementById('endSetBackBtn').style.display = 'none';
                document.getElementById('endSetConfirmBtn').textContent = 'Terminer le set';
                document.getElementById('endSetConfirmBtn').disabled = true; // Attendre le choix de raison

                // Reset les boutons raison
                document.querySelectorAll('.end-set-reason-btn').forEach(b => b.classList.remove('selected'));
            }

            // Stats recap
            buildEndSetStatsRecap();

            // Pr√©-remplir score r√©el avec score actuel
            document.getElementById('realScoreHome').value = home;
            document.getElementById('realScoreAway').value = away;

            document.getElementById('endSetOverlay').classList.add('active');
        }

        function selectEndReason(reason) {
            endSetState.reason = reason;

            // Highlight du bouton
            document.querySelectorAll('.end-set-reason-btn').forEach(b => b.classList.remove('selected'));
            event.currentTarget.classList.add('selected');

            if (reason === 'camera') {
                document.getElementById('endSetRealScore').classList.add('visible');
                document.getElementById('endSetConfirmBtn').textContent = 'Terminer avec score r√©el';
                document.getElementById('endSetConfirmBtn').disabled = false;
            } else if (reason === 'time') {
                // Fin du cr√©neau = fin du match imm√©diate
                // Fermer le modal de fin de set et ouvrir le modal de fin de cr√©neau
                closeEndSetModal();
                showTimeEndModal();
            }
        }

        function closeEndSetModal() {
            document.getElementById('endSetOverlay').classList.remove('active');
        }

        function returnToGameForCorrection() {
            // Fermer la modal
            closeEndSetModal();
            
            // R√©initialiser le flag de fin de set
            gameState.setEnded = false;
            
            // Retour √† la s√©lection du serveur pour pouvoir utiliser "Annuler point"
            gameState.rally = [];
            gameState.currentAction = {};
            gameState.currentServer = null;
            
            clearMarkers();
            clearArrows();
            hideServiceZones();
            hideReceptionQualityZones();
            highlightCourt(null);
            
            gameState.phase = 'server_selection';
            updatePhase();
            renderServerSelection();
        }

        // ==================== MODAL FIN DE MATCH ====================

        function showEndMatchModal() {
            const sc = Storage.getSetScore(currentMatch);
            const opponent = currentMatch.opponent || 'Adversaire';
            const isWin = sc.homeWins > sc.awayWins;
            const isDraw = sc.homeWins === sc.awayWins;

            // Ic√¥ne et titre
            document.getElementById('endMatchIcon').textContent = isWin ? 'üèÜ' : (isDraw ? 'ü§ù' : 'üòî');
            document.getElementById('endMatchTitle').textContent = isWin ? 'Victoire !' : (isDraw ? 'Match nul' : 'D√©faite');

            // Score sets
            const scoreEl = document.getElementById('endMatchFinalScore');
            scoreEl.textContent = sc.homeWins + ' ‚Äì ' + sc.awayWins;
            scoreEl.className = 'match-final-score ' + (isWin ? 'win' : (isDraw ? 'draw' : 'loss'));

            // Versus
            document.getElementById('endMatchVs').textContent = 'Jen et ses Saints vs ' + opponent;

            // D√©tail des sets
            const setsDetail = document.getElementById('endMatchSetsDetail');
            let setsHtml = '';
            currentMatch.sets.forEach((s, i) => {
                if (s.completed) {
                    const h = s.finalHomeScore || 0;
                    const a = s.finalAwayScore || 0;
                    const won = h > a;
                    setsHtml += '<div>Set ' + (i + 1) + ' : <span class="' + (won ? 'set-won' : 'set-lost') + '">' + h + ' ‚Äì ' + a + '</span></div>';
                }
            });
            setsDetail.innerHTML = setsHtml;

            // Stats r√©sum√© du match
            buildEndMatchStats();

            // Afficher la modal
            document.getElementById('endMatchOverlay').style.display = 'flex';
        }

        function buildEndMatchStats() {
            // Agr√©ger les stats de tous les sets (noms unifi√©s)
            let totalAces = 0, totalFautesServ = 0, totalKills = 0, totalBlocks = 0;
            let totalServiceTot = 0, totalReceptionTot = 0, totalAttackTot = 0;
            let totalReceptionExc = 0;

            currentMatch.sets.forEach(s => {
                if (s.stats && s.stats.home) {
                    Object.values(s.stats.home).forEach(p => {
                        totalServiceTot += (p.service && p.service.tot) || 0;
                        totalAces += (p.service && p.service.ace) || 0;
                        totalFautesServ += (p.service && (p.service.fser || p.service.fs)) || 0;
                        totalReceptionTot += (p.reception && p.reception.tot) || 0;
                        totalReceptionExc += (p.reception && (p.reception.rplus || p.reception.positive)) || 0;
                        totalAttackTot += (p.attack && p.attack.tot) || 0;
                        totalKills += (p.attack && (p.attack.attplus || p.attack.fd)) || 0;
                        totalBlocks += (p.block && (p.block.blcplus || p.block.bl)) || 0;
                    });
                }
            });

            // Also add current set stats if they exist
            if (setStats && setStats.home) {
                Object.values(setStats.home).forEach(p => {
                    totalServiceTot += (p.service && p.service.tot) || 0;
                    totalAces += (p.service && p.service.ace) || 0;
                    totalFautesServ += (p.service && p.service.fser) || 0;
                    totalReceptionTot += (p.reception && p.reception.tot) || 0;
                    totalReceptionExc += (p.reception && p.reception.rplus) || 0;
                    totalAttackTot += (p.attack && p.attack.tot) || 0;
                    totalKills += (p.attack && p.attack.attplus) || 0;
                    totalBlocks += (p.block && p.block.blcplus) || 0;
                });
            }

            const grid = document.getElementById('endMatchStatsGrid');
            grid.innerHTML = 
                '<div class="match-stat-item"><span class="stat-value">' + totalAces + '</span><span class="stat-label">Aces</span></div>' +
                '<div class="match-stat-item"><span class="stat-value">' + totalKills + '</span><span class="stat-label">Attaques gagnantes</span></div>' +
                '<div class="match-stat-item"><span class="stat-value">' + totalBlocks + '</span><span class="stat-label">Contres</span></div>' +
                '<div class="match-stat-item"><span class="stat-value">' + totalFautesServ + '</span><span class="stat-label">Fautes service</span></div>';
        }

        function returnToGameFromEndMatch() {
            // Fermer la modal fin de match
            document.getElementById('endMatchOverlay').style.display = 'none';

            // R√©initialiser le flag de fin de set pour permettre la correction
            gameState.setEnded = false;

            // Annuler la validation du dernier set
            currentSet.completed = false;
            delete currentSet.finalHomeScore;
            delete currentSet.finalAwayScore;
            delete currentSet.endReason;
            delete currentSet.winner;

            Storage.saveCurrentMatch(currentMatch);

            // Retour √† la s√©lection du serveur
            gameState.rally = [];
            gameState.currentAction = {};
            gameState.currentServer = null;

            clearMarkers();
            clearArrows();
            hideServiceZones();
            hideReceptionQualityZones();
            highlightCourt(null);

            gameState.phase = 'server_selection';
            updatePhase();
            renderServerSelection();
        }

        function confirmEndMatch() {
            // Sauvegarder les stats du set courant dans le match
            if (setStats) {
                currentSet.stats = { home: {}, away: {} };
                // Deep copy des stats
                for (const team of ['home', 'away']) {
                    for (const [name, data] of Object.entries(setStats[team] || {})) {
                        currentSet.stats[team][name] = JSON.parse(JSON.stringify(data));
                    }
                }
            }

            currentMatch.sets[setIndex] = currentSet;

            // Finaliser le match (change le statut en 'completed', calcule le r√©sultat)
            Storage.finalizeMatch(currentMatch, 'normal');

            // Upload vers Firebase en arri√®re-plan (non-bloquant)
            if (typeof FirebaseSync !== 'undefined' && FirebaseSync.isConfigured()) {
                FirebaseSync.uploadMatch(currentMatch).catch(function(err) {
                    console.warn('[Firebase] Upload √©chou√© (sera rattrap√© au chargement historique) :', err.message);
                });
            }

            // Fermer la modal
            document.getElementById('endMatchOverlay').style.display = 'none';

            // Rediriger vers l'historique
            window.location.href = 'historique.html';
        }

        // ==================== FIN DE CR√âNEAU (temps √©coul√©) ====================

        function showTimeEndModal() {
            const opponent = currentMatch.opponent || 'Adversaire';

            // Calculer le score des sets en comptant le set en cours
            // Le set en cours est gagn√© par l'√©quipe en t√™te (ou nul si √©galit√©)
            const home = gameState.homeScore;
            const away = gameState.awayScore;

            let homeWins = 0;
            let awayWins = 0;

            // Compter les sets pr√©c√©dents
            currentMatch.sets.forEach((s, i) => {
                if (i < setIndex && s.completed) {
                    if (s.winner === 'home') homeWins++;
                    else if (s.winner === 'away') awayWins++;
                }
            });

            // Ajouter le set en cours (celui qui est en t√™te gagne)
            if (home > away) homeWins++;
            else if (away > home) awayWins++;
            // Si √©galit√©, personne ne gagne ce set

            const isWin = homeWins > awayWins;
            const isDraw = homeWins === awayWins;

            // Score sets
            const scoreEl = document.getElementById('timeEndFinalScore');
            scoreEl.textContent = homeWins + ' ‚Äì ' + awayWins;
            scoreEl.className = 'match-final-score ' + (isWin ? 'win' : (isDraw ? 'draw' : 'loss'));

            // Versus
            document.getElementById('timeEndVs').textContent = 'Jen et ses Saints vs ' + opponent;

            // D√©tail des sets (incluant le set en cours)
            const setsDetail = document.getElementById('timeEndSetsDetail');
            let setsHtml = '';

            // Sets pr√©c√©dents
            currentMatch.sets.forEach((s, i) => {
                if (i < setIndex && s.completed) {
                    const h = s.finalHomeScore || 0;
                    const a = s.finalAwayScore || 0;
                    const won = h > a;
                    setsHtml += '<div>Set ' + (i + 1) + ' : <span class="' + (won ? 'set-won' : 'set-lost') + '">' + h + ' ‚Äì ' + a + '</span></div>';
                }
            });

            // Set en cours
            const currentSetWon = home > away;
            const currentSetClass = home === away ? '' : (currentSetWon ? 'set-won' : 'set-lost');
            setsHtml += '<div>Set ' + (setIndex + 1) + ' (en cours) : <span class="' + currentSetClass + '">' + home + ' ‚Äì ' + away + '</span></div>';

            setsDetail.innerHTML = setsHtml;

            // Stats r√©sum√© du match
            buildTimeEndStats();

            // Afficher la modal
            document.getElementById('timeEndOverlay').style.display = 'flex';
        }

        function closeTimeEndModal() {
            document.getElementById('timeEndOverlay').style.display = 'none';
        }

        function buildTimeEndStats() {
            // Agr√©ger les stats de tous les sets pr√©c√©dents + set en cours (noms unifi√©s)
            let totalAces = 0, totalFautesServ = 0, totalKills = 0, totalBlocks = 0;

            // Sets pr√©c√©dents
            currentMatch.sets.forEach((s, i) => {
                if (i < setIndex && s.stats && s.stats.home) {
                    Object.values(s.stats.home).forEach(p => {
                        totalAces += (p.service && p.service.ace) || 0;
                        totalFautesServ += (p.service && (p.service.fser || p.service.fs)) || 0;
                        totalKills += (p.attack && (p.attack.attplus || p.attack.fd)) || 0;
                        totalBlocks += (p.block && (p.block.blcplus || p.block.bl)) || 0;
                    });
                }
            });

            // Set en cours
            if (setStats && setStats.home) {
                Object.values(setStats.home).forEach(p => {
                    totalAces += (p.service && p.service.ace) || 0;
                    totalFautesServ += (p.service && p.service.fser) || 0;
                    totalKills += (p.attack && p.attack.attplus) || 0;
                    totalBlocks += (p.block && p.block.blcplus) || 0;
                });
            }

            const grid = document.getElementById('timeEndStatsGrid');
            grid.innerHTML =
                '<div class="match-stat-item"><span class="stat-value">' + totalAces + '</span><span class="stat-label">Aces</span></div>' +
                '<div class="match-stat-item"><span class="stat-value">' + totalKills + '</span><span class="stat-label">Attaques gagnantes</span></div>' +
                '<div class="match-stat-item"><span class="stat-value">' + totalBlocks + '</span><span class="stat-label">Contres</span></div>' +
                '<div class="match-stat-item"><span class="stat-value">' + totalFautesServ + '</span><span class="stat-label">Fautes service</span></div>';
        }

        function confirmTimeEndMatch() {
            const home = gameState.homeScore;
            const away = gameState.awayScore;

            // Sauvegarder le set en cours
            currentSet.finalHomeScore = home;
            currentSet.finalAwayScore = away;
            currentSet.endReason = 'time';
            currentSet.completed = true;
            currentSet.winner = home > away ? 'home' : (away > home ? 'away' : 'draw');
            currentSet.statsHomeScore = home;
            currentSet.statsAwayScore = away;

            // Sauvegarder les stats du set courant
            if (setStats) {
                currentSet.stats = { home: {}, away: {} };
                for (const team of ['home', 'away']) {
                    for (const [name, data] of Object.entries(setStats[team] || {})) {
                        currentSet.stats[team][name] = JSON.parse(JSON.stringify(data));
                    }
                }
            }

            currentMatch.sets[setIndex] = currentSet;

            // Finaliser le match avec raison 'time'
            Storage.finalizeMatch(currentMatch, 'time');

            // Upload vers Firebase en arri√®re-plan (non-bloquant)
            if (typeof FirebaseSync !== 'undefined' && FirebaseSync.isConfigured()) {
                FirebaseSync.uploadMatch(currentMatch).catch(function(err) {
                    console.warn('[Firebase] Upload √©chou√© (sera rattrap√© au chargement historique) :', err.message);
                });
            }

            // Fermer la modal
            document.getElementById('timeEndOverlay').style.display = 'none';

            // Rediriger vers l'historique
            window.location.href = 'historique.html';
        }

        function buildEndSetStatsRecap() {
            const points = currentSet.points || [];
            const totalPoints = points.length;
            
            if (totalPoints === 0) {
                document.getElementById('endSetStatsRecap').innerHTML = 'Aucun point enregistr√© dans ce set.';
                return;
            }

            // Compter les aces et fautes de service
            let aces = 0, faultesServ = 0;
            for (const pt of points) {
                for (const action of pt.rally) {
                    if (action.type === 'service' && action.result === 'ace') aces++;
                    if (action.type === 'service' && (action.result === 'fault' || action.result === 'fault_out' || action.result === 'fault_net')) faultesServ++;
                }
            }

            document.getElementById('endSetStatsRecap').innerHTML = `
                <span class="stat-highlight">${totalPoints}</span> points jou√©s
                ${aces > 0 ? ` ‚Ä¢ <span class="stat-highlight">${aces}</span> ace${aces > 1 ? 's' : ''}` : ''}
                ${faultesServ > 0 ? ` ‚Ä¢ <span class="stat-highlight">${faultesServ}</span> faute${faultesServ > 1 ? 's' : ''} au service` : ''}
            `;
        }

        function confirmEndSet() {
            let finalHome = gameState.homeScore;
            let finalAway = gameState.awayScore;
            let endReason = 'auto';

            if (endSetState.mode === 'manual') {
                if (!endSetState.reason) return;
                endReason = endSetState.reason;

                if (endSetState.reason === 'camera') {
                    finalHome = parseInt(document.getElementById('realScoreHome').value) || 0;
                    finalAway = parseInt(document.getElementById('realScoreAway').value) || 0;

                    // Validation d'un score valide de fin de set
                    const target = Storage.getTargetScore(currentMatch); // 25 ou 15 pour tie-break
                    const maxScore = Math.max(finalHome, finalAway);
                    const minScore = Math.min(finalHome, finalAway);
                    const diff = maxScore - minScore;

                    if (finalHome === finalAway) {
                        alert('Le score ne peut pas √™tre √† √©galit√© en fin de set.');
                        return;
                    }

                    if (maxScore < target) {
                        alert(`Le score gagnant doit √™tre d'au moins ${target} points.`);
                        return;
                    }

                    if (diff < 2) {
                        alert('Il faut au moins 2 points d\'√©cart pour gagner un set.');
                        return;
                    }

                    // Si score au-del√† du target, v√©rifier que l'√©cart est exactement 2
                    if (maxScore > target && diff !== 2) {
                        alert(`Avec un score au-del√† de ${target}, l'√©cart doit √™tre exactement de 2 points (ex: ${maxScore}-${maxScore - 2}).`);
                        return;
                    }
                }
                // Note: 'time' est g√©r√© directement dans selectEndReason() -> showTimeEndModal()
            }

            // Sauvegarder le r√©sultat du set
            currentSet.finalHomeScore = finalHome;
            currentSet.finalAwayScore = finalAway;
            currentSet.endReason = endReason;
            currentSet.completed = true;
            currentSet.winner = finalHome > finalAway ? 'home' : 'away';
            currentSet.statsHomeScore = gameState.homeScore;
            currentSet.statsAwayScore = gameState.awayScore;

            // D√©terminer le prochain serveur (alternance entre sets)
            // Le premier serveur du set change √† chaque set
            const firstServerThisSet = currentSet.firstServingTeam || currentSet.servingTeam;
            const nextServingTeam = firstServerThisSet === 'home' ? 'away' : 'home';

            // Sauvegarder qui a servi en premier dans ce set
            if (!currentSet.firstServingTeam) {
                currentSet.firstServingTeam = currentSet.servingTeam;
            }

            // Changement de c√¥t√© terrain (la cam√©ra reste fixe)
            const currentCameraSide = currentSet.cameraSide || 'home';
            const nextCameraSide = currentCameraSide === 'home' ? 'away' : 'home';

            // Pr√©parer le squelette du set suivant (sans composition pr√©-remplie)
            const nextSetNumber = (currentSet.setNumber || 1) + 1;
            const nextSet = {
                setNumber: nextSetNumber,
                homeLineup: {},  // Sera rempli dans match-set-composition
                awayLineup: {},
                homeScore: 0,
                awayScore: 0,
                points: [],
                cameraSide: nextCameraSide,
                servingTeam: nextServingTeam,
                firstServingTeam: nextServingTeam,
                youtubeUrl: currentSet.youtubeUrl || ''
            };

            // Sauvegarder le set courant d'abord
            currentMatch.sets[setIndex] = currentSet;

            // V√©rifier si le match est termin√©
            if (Storage.isMatchOver(currentMatch)) {
                // Sauvegarder les stats du set courant
                if (setStats) {
                    currentSet.stats = { home: {}, away: {} };
                    for (const team of ['home', 'away']) {
                        for (const [name, data] of Object.entries(setStats[team] || {})) {
                            currentSet.stats[team][name] = JSON.parse(JSON.stringify(data));
                        }
                    }
                }
                currentMatch.sets[setIndex] = currentSet;
                Storage.saveCurrentMatch(currentMatch);
                closeEndSetModal();
                showEndMatchModal();
                return;
            }

            // Sauvegarder les stats du set courant
            if (setStats) {
                currentSet.stats = { home: {}, away: {} };
                for (const team of ['home', 'away']) {
                    for (const [name, data] of Object.entries(setStats[team] || {})) {
                        currentSet.stats[team][name] = JSON.parse(JSON.stringify(data));
                    }
                }
            }

            // Ajouter le set suivant au match
            currentMatch.sets.push(nextSet);

            // Sauvegarder
            currentMatch.sets[setIndex] = currentSet;
            Storage.saveCurrentMatch(currentMatch);

            // Fermer la modal
            closeEndSetModal();

            // Aller √† la composition du set suivant
            window.location.href = 'match-set-composition.html';
        }

        function endRally() {
            // Sauvegarder le rally
            if (!currentSet.points) currentSet.points = [];
            currentSet.points.push({
                rally: [...gameState.rally],
                homeScore: gameState.homeScore,
                awayScore: gameState.awayScore,
                servingTeam: gameState.rally[0]?.team || gameState.servingTeam,
                server: gameState.rally[0]?.player || null,
                timestamp: Date.now()
            });

            // Mettre √† jour les statistiques
            recalculateAllStats();

            // Si le set est termin√©, ne pas pr√©parer le prochain point
            if (gameState.setEnded) {
                gameState.rally = [];
                gameState.currentAction = {};
                gameState.defenseAutoSelected = false;
                gameState.defenseAutoPlayer = null;
                gameState.defenseFaultShortcut = false;
                clearMarkers();
                clearArrows();
                hideAttackZones();
                hideDefenseZones();
                return;
            }

            // Reset pour le prochain point
            gameState.rally = [];
            gameState.currentAction = {};
            gameState.passAutoSelected = false;
            gameState.attackAutoSelected = false;
            gameState.receptionAutoSelected = false;
            gameState.defenseAutoSelected = false;
            gameState.defenseAutoPlayer = null;
            gameState.defenseFaultShortcut = false;
            gameState.defenseDirectAttack = false;
            gameState.netDirectAttack = false;
            gameState.receptionDirectAttackSource = false;
            gameState.defenseDirectReturnAttackSource = false;
            gameState.defenseDirectReturnClickData = null;
            gameState.passDirectReturnAttackSource = false;
            gameState.passDirectReturnClickData = null;
            clearMarkers();
            clearArrows();
            hideServiceZones();
            hideReceptionQualityZones();
            hideAttackZones();
            hideDefenseZones();

            if (gameState.currentServer) {
                // M√™me serveur continue ‚Äî skip la s√©lection
                gameState.phase = 'serve_start';
                gameState.currentAction = {
                    type: 'service',
                    player: gameState.currentServer,
                    team: gameState.servingTeam
                };
                updatePhase();
                hideAllSections();
                showServerContinueBanner();
                highlightCourt(null);
                showServiceZone();
            } else {
                // Nouveau serveur √† choisir
                gameState.phase = 'server_selection';
                updatePhase();
                renderServerSelection();
            }
        }

        function recalculateAllStats() {
            // R√©initialiser les stats
            initSetStats();

            // Parcourir tous les points enregistr√©s
            if (currentSet.points) {
                for (const point of currentSet.points) {
                    updateStatsFromRally(point.rally);
                }
            }

            renderStatsTables();
            renderMiniTimeline();
        }

        // ==================== MINI-TIMELINE ====================

        function buildTimelineData(set) {
            const points = set.points || [];
            if (points.length === 0) return [];

            const initialHome = set.initialHomeScore || 0;
            const runs = [];
            let currentRun = null;

            for (let i = 0; i < points.length; i++) {
                const pt = points[i];
                const prevHome = i > 0 ? points[i - 1].homeScore : initialHome;
                const scorer = pt.homeScore > prevHome ? 'home' : 'away';
                const teamScore = scorer === 'home' ? pt.homeScore : pt.awayScore;

                if (currentRun && currentRun.team === scorer) {
                    currentRun.points.push({ teamScore: teamScore });
                } else {
                    currentRun = { team: scorer, points: [{ teamScore: teamScore }] };
                    runs.push(currentRun);
                }
            }
            return runs;
        }

        function renderMiniTimeline() {
            const container = document.getElementById('miniTimelineChart');
            if (!container || !currentSet) { if (container) container.innerHTML = ''; return; }

            const mixHome = currentSet.mixiteHome || 0;
            const mixAway = currentSet.mixiteAway || 0;
            const hasMix = mixHome > 0 || mixAway > 0;
            const hasPoints = currentSet.points && currentSet.points.length > 0;

            if (!hasMix && !hasPoints) { container.innerHTML = ''; return; }

            const runs = hasPoints ? buildTimelineData(currentSet) : [];
            if (!hasMix && runs.length === 0) { container.innerHTML = ''; return; }

            const totalPoints = runs.reduce(function(sum, r) { return sum + r.points.length; }, 0);
            const totalMixBlocks = mixHome + mixAway;
            const totalAll = totalPoints + totalMixBlocks;
            const mixRuns = (mixHome > 0 ? 1 : 0) + (mixAway > 0 ? 1 : 0);
            const availableWidth = 576;
            const totalRuns = runs.length + mixRuns;
            const gapWidth = Math.max(0, totalRuns - 1) * 3;
            const internalGaps = totalAll - totalRuns;
            const blockSize = Math.max(6, Math.min(16, Math.floor((availableWidth - gapWidth - internalGaps) / totalAll)));
            const fontSize = blockSize >= 12 ? 7 : (blockSize >= 9 ? 6 : 0);
            const blockHeight = 14;

            let html = '';

            // Blocs mixit√© gris au d√©but
            if (mixHome > 0) {
                html += '<div class="mini-tl-run">';
                html += '<div class="mini-tl-row">';
                for (var m = 1; m <= mixHome; m++) {
                    html += '<div class="mini-tl-block mixite" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;font-size:' + fontSize + 'px;">' + (fontSize > 0 ? m : '') + '</div>';
                }
                html += '</div><div class="mini-tl-row">';
                for (var m = 0; m < mixHome; m++) {
                    html += '<div class="mini-tl-block empty" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;"></div>';
                }
                html += '</div></div>';
            }
            if (mixAway > 0) {
                html += '<div class="mini-tl-run">';
                html += '<div class="mini-tl-row">';
                for (var m = 0; m < mixAway; m++) {
                    html += '<div class="mini-tl-block empty" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;"></div>';
                }
                html += '</div><div class="mini-tl-row">';
                for (var m = 1; m <= mixAway; m++) {
                    html += '<div class="mini-tl-block mixite" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;font-size:' + fontSize + 'px;">' + (fontSize > 0 ? m : '') + '</div>';
                }
                html += '</div></div>';
            }

            runs.forEach(function(run) {
                html += '<div class="mini-tl-run">';
                html += '<div class="mini-tl-row">';
                run.points.forEach(function(pt) {
                    if (run.team === 'home') {
                        html += '<div class="mini-tl-block home" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;font-size:' + fontSize + 'px;">' + (fontSize > 0 ? pt.teamScore : '') + '</div>';
                    } else {
                        html += '<div class="mini-tl-block empty" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;"></div>';
                    }
                });
                html += '</div><div class="mini-tl-row">';
                run.points.forEach(function(pt) {
                    if (run.team === 'away') {
                        html += '<div class="mini-tl-block away" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;font-size:' + fontSize + 'px;">' + (fontSize > 0 ? pt.teamScore : '') + '</div>';
                    } else {
                        html += '<div class="mini-tl-block empty" style="width:' + blockSize + 'px;height:' + blockHeight + 'px;"></div>';
                    }
                });
                html += '</div></div>';
            });

            container.innerHTML = html;
        }

        // Helper : obtenir les stats d'un joueur (avec init auto)
        function getPlayerStats(team, player) {
            if (!team || !player) return null;
            if (!setStats[team][player]) {
                setStats[team][player] = initPlayerStats();
            }
            return setStats[team][player];
        }

        // Qualit√© de r√©ception ‚Üí note num√©rique (pour Moy serveur)
        function receptionQualityToNote(quality) {
            if (!quality || !quality.label) return null;
            switch (quality.label) {
                case 'Excellente': return 4;
                case 'Positive':   return 3;
                case 'Jouable':    return 2;
                case 'N√©gative':   return 1;
                case 'Faute':      return 0;
                default:
                    // Labels sp√©ciaux : utiliser le score directement si disponible
                    return (typeof quality.score === 'number') ? quality.score : null;
            }
        }

        // Chercher la prochaine action d'un certain type apr√®s l'index donn√© dans le rally
        function findNextAction(rally, afterIndex, type) {
            for (let i = afterIndex + 1; i < rally.length; i++) {
                if (rally[i].type === type) return { action: rally[i], index: i };
            }
            return null;
        }

        // Analyser ce qui se passe apr√®s une attaque defended
        // Retourne : 'continued' (A-), 'blocked' (BP), 'ended' (A+)
        function analyzeAfterDefended(rally, afterIndex, oppositeTeam) {
            const attackingTeam = oppositeTeam === 'home' ? 'away' : 'home';
            for (let i = afterIndex + 1; i < rally.length; i++) {
                const a = rally[i];
                if (a.team === oppositeTeam) {
                    // Defense fault = l'adversaire rate sa d√©fense ‚Üí l'attaque a forc√© le point
                    if (a.type === 'defense' && a.result === 'fault') continue;
                    // Block = la balle revient chez l'attaquant
                    if (a.type === 'block') {
                        // Chercher si l'√©quipe attaquante r√©cup√®re r√©ellement apr√®s le block
                        for (let j = i + 1; j < rally.length; j++) {
                            if (rally[j].team === attackingTeam) {
                                if (rally[j].type === 'defense' && rally[j].result === 'fault') {
                                    return 'blocked'; // Defense fault apr√®s block = BP
                                }
                                return 'continued'; // L'√©quipe r√©cup√®re le block ‚Üí A-
                            }
                        }
                        return 'blocked'; // Personne ne r√©cup√®re ‚Üí BP
                    }
                    // Toute autre action adverse (pass, attack, defense r√©ussie, retour direct) = jeu continue
                    return 'continued';
                }
            }
            return 'ended';
        }

        // V√©rifie si un retour direct (r√©ception ou d√©fense) est "exploit√©" par l'adversaire
        // = l'adversaire marque directement apr√®s sans que l'√©quipe ait reconstruit (pas de passe/attaque de l'√©quipe entre-temps)
        // ET sans que l'adversaire ait organis√© son jeu (passe adverse = le DR a √©t√© absorb√©, la suite n'est plus li√©e)
        function isDirectReturnExploited(rally, index, team) {
            const oppositeTeam = team === 'home' ? 'away' : 'home';
            for (let j = index + 1; j < rally.length; j++) {
                const a = rally[j];
                // Si l'√©quipe du retour direct fait une passe ou attaque ‚Üí elle a reconstruit ‚Üí non exploit√©
                if (a.team === team && (a.type === 'pass' || a.type === 'attack')) return false;
                // Si l'adversaire fait une passe ‚Üí il a organis√© son jeu ‚Üí le DR a √©t√© absorb√© ‚Üí non exploit√©
                // (une attaque directe SANS passe = exploitation du DR, donc on ne stoppe pas sur attack)
                if (a.team === oppositeTeam && a.type === 'pass') return false;
                // Si l'adversaire marque directement (attaque gagnante, faute d√©fense de l'√©quipe)
                if (a.team === oppositeTeam && a.type === 'attack' && (a.result === 'point' || a.result === 'bloc_out')) return true;
                if (a.team === team && a.type === 'defense' && a.result === 'fault') return true;
            }
            // Si le rally se termine sans suite apr√®s le retour ‚Üí non exploit√© (ex: retour gagnant g√©r√© s√©par√©ment)
            return false;
        }

        function updateStatsFromRally(rally) {
            if (!rally || rally.length === 0) return;

            for (let i = 0; i < rally.length; i++) {
                const action = rally[i];
                const team = action.team;
                const player = action.player;

                if (!team || !player) continue;

                const stats = getPlayerStats(team, player);
                if (!stats) continue;

                switch (action.type) {
                    case 'service': {
                        stats.service.tot++;
                        if (action.result === 'ace') {
                            stats.service.ace++;
                            // Si une r√©ception est associ√©e √† l'ace, la compter dans recSumAdv/recCountAdv
                            const recActionAce = findNextAction(rally, i, 'reception');
                            if (recActionAce) {
                                const noteAce = receptionQualityToNote(recActionAce.action.quality);
                                if (noteAce !== null) {
                                    stats.service.recSumAdv += noteAce;
                                    stats.service.recCountAdv++;
                                }
                            }
                        } else if (action.result === 'fault' || action.result === 'fault_out' || action.result === 'fault_net') {
                            stats.service.fser++;
                        } else {
                            // Service in : chercher la r√©ception adverse pour S+ et Moy
                            const recAction = findNextAction(rally, i, 'reception');
                            if (recAction) {
                                const rec = recAction.action;
                                let note = receptionQualityToNote(rec.quality);
                                if (note !== null) {
                                    // Retour direct gagnant = pire outcome pour le serveur ‚Üí note 0 (FR)
                                    if (rec.isDirectReturnWinner) {
                                        note = 0;
                                    }
                                    // Retour direct exploit√© par le serveur = r√©ception catastrophique ‚Üí note 0 (FR) + S+
                                    else if (rec.isDirectReturn && !rec.isDirectReturnWinner) {
                                        const exploited = isDirectReturnExploited(rally, recAction.index, rec.team);
                                        if (exploited) {
                                            note = 0;
                                        }
                                    }
                                    stats.service.recSumAdv += note;
                                    stats.service.recCountAdv++;
                                    // S+ = faute de r√©ception adverse (note 0)
                                    if (note === 0) {
                                        stats.service.splus++;
                                    }
                                }
                            }
                        }
                        break;
                    }

                    case 'reception': {
                        stats.reception.tot++;
                        // Retour direct exploit√© : R1 ‚Üí FR (l'adversaire marque directement apr√®s)
                        const recExploited = action.isDirectReturn && !action.isDirectReturnWinner
                            && isDirectReturnExploited(rally, i, action.team);
                        if (recExploited) {
                            stats.reception.frec++;
                        } else if (action.quality) {
                            switch (action.quality.label) {
                                case 'Excellente': stats.reception.r4++; break;
                                case 'Positive':   stats.reception.r3++; break;
                                case 'Jouable':    stats.reception.r2++; break;
                                case 'N√©gative':   stats.reception.r1++; break;
                                case 'Faute':      stats.reception.frec++; break;
                                default:
                                    if (action.quality.score === 0) stats.reception.frec++;
                                    break;
                            }
                        }
                        break;
                    }

                    case 'pass': {
                        // V20.0b : Relance passe ‚Äî geste de survie, pas comptabilise en stats passe
                        // Mais r√©trograde la r√©ception/d√©fense pr√©c√©dente et compte une relance R-
                        if (action.passType === 'relance') {
                            // V20.18 : relance out = pas de stats (faute brute, point perdu)
                            if (action.result === 'out') {
                                break;
                            }
                            // Chercher la derni√®re r√©ception ou d√©fense de la m√™me √©quipe en amont
                            for (let j = i - 1; j >= 0; j--) {
                                const prev = rally[j];
                                if (prev.team !== action.team) continue;
                                const prevPlayer = prev.player;
                                if (!prevPlayer) continue;
                                const prevStats = setStats[team][prevPlayer];
                                if (!prevStats) break;

                                if (prev.type === 'reception' && prev.quality) {
                                    // Annuler le score pr√©c√©dent et forcer R1
                                    switch (prev.quality.label) {
                                        case 'Excellente': prevStats.reception.r4--; break;
                                        case 'Positive':   prevStats.reception.r3--; break;
                                        case 'Jouable':    prevStats.reception.r2--; break;
                                        case 'N√©gative':   /* d√©j√† R1 */ break;
                                        case 'Faute':      prevStats.reception.frec--; break;
                                    }
                                    if (prev.quality.label !== 'N√©gative') {
                                        prevStats.reception.r1++;
                                    }
                                    break;
                                }
                                if (prev.type === 'defense') {
                                    // Annuler le score pr√©c√©dent et forcer D (V20.15)
                                    if (prev.defenseQuality === 'positive') {
                                        prevStats.defense.defplus--;
                                        prevStats.defense.defneutral++;
                                    }
                                    // Si d√©j√† D/D-/FD, on ne change rien
                                    break;
                                }
                            }
                            // Compter une relance R- pour le passeur
                            stats.relance.tot++;
                            stats.relance.relminus++;
                            break;
                        }

                        // V19.2 : qualite de passe + ventilation par contexte
                        const passerRoleP = action.role || 'transition';
                        const passCtxObj = getPassContext(rally.slice(0, i), passerRoleP);
                        const pType = passCtxObj.playerType === 'Passeur' ? 'passeur' : 'autre';
                        const pCtx = passCtxObj.context;

                        // Helper : incrementer tot + score dans un bucket
                        function _incPass(bucket, scoreKey) {
                            bucket.tot++;
                            if (scoreKey === 'fp') bucket.fp++;
                            else if (bucket[scoreKey] !== undefined) bucket[scoreKey]++;
                        }

                        // Retour direct : compter comme FP si exploite
                        if (action.isDirectReturn) {
                            if (!action.isDirectReturnWinner) {
                                const passExploited = isDirectReturnExploited(rally, i, action.team);
                                if (passExploited) {
                                    _incPass(stats.pass, 'fp');
                                    _incPass(stats.pass[pType], 'fp');
                                    if (stats.pass[pType][pCtx]) _incPass(stats.pass[pType][pCtx], 'fp');
                                }
                            }
                            break;
                        }
                        // Passe sans endPos ou filet ‚Üí FP
                        if (!action.endPos || action.endPos.courtSide === 'net') {
                            _incPass(stats.pass, 'fp');
                            _incPass(stats.pass[pType], 'fp');
                            if (stats.pass[pType][pCtx]) _incPass(stats.pass[pType][pCtx], 'fp');
                            break;
                        }

                        // V20.0b : passe courtSide='out' = clic lat√©ral mais dans zone de jeu
                        // ‚Üí convertir vers le court-side de l'√©quipe pour √©valuer normalement
                        let passEndPos = action.endPos;
                        if (passEndPos.courtSide === 'out') {
                            const passCourtSide = getCourtSideForTeam(team);
                            passEndPos = { x: passEndPos.x, y: passEndPos.y, courtSide: passCourtSide };
                        }

                        // Determiner zone et evaluer la qualite
                        const passZone = getPassZone(passEndPos, team);
                        const passContext = passCtxObj.context;
                        const passEval = evaluatePassQuality(action.endPos, passZone, passContext, team);
                        const scoreKey = passEval.score === 4 ? 'p4' : passEval.score === 3 ? 'p3' : passEval.score === 2 ? 'p2' : 'p1';

                        _incPass(stats.pass, scoreKey);
                        _incPass(stats.pass[pType], scoreKey);
                        if (stats.pass[pType][pCtx]) _incPass(stats.pass[pType][pCtx], scoreKey);
                        break;
                    }

                    case 'attack': {
                        const isRelance = action.attackType === 'relance';
                        const oppositeTeam = team === 'home' ? 'away' : 'home';

                        if (isRelance) {
                            // ===== RELANCE : pas de stats c√¥t√© attaquant =====
                            // La relance n'est pas une vraie attaque ‚Äî les stats sont compt√©es
                            // c√¥t√© D√âFENSEUR (dans le case 'defense' quand l'attaque pr√©c√©dente est une relance)
                            break;
                        }

                        // ===== CAS STANDARD (smash/feinte/etc.) =====
                        stats.attack.tot++;

                        if (action.attackType === 'faute' || action.result === 'fault_net' || action.result === 'out') {
                            // FA : faute d'attaque (filet, out, faute technique)
                            stats.attack.fatt++;
                        } else if (action.result === 'point') {
                            // Kill direct ‚Üí A+
                            stats.attack.attplus++;
                        } else if (action.result === 'bloc_out') {
                            // Bloc out ‚Üí A+ (l'attaquant gagne le point)
                            stats.attack.attplus++;
                        } else if (action.result === 'blocked') {
                            // BP : bloc pris (la balle revient chez l'attaquant)
                            stats.attack.bp++;
                        } else if (action.result === 'defended') {
                            const outcome = analyzeAfterDefended(rally, i, oppositeTeam);
                            if (outcome === 'continued') {
                                stats.attack.attminus++; // Le jeu continue ‚Üí A-
                            } else if (outcome === 'blocked') {
                                stats.attack.bp++; // Bloc pris ‚Üí BP
                            } else {
                                stats.attack.attplus++; // L'attaque a forc√© le point ‚Üí A+
                            }
                        }
                        break;
                    }

                    case 'defense': {
                        // Chercher si l'attaque adverse pr√©c√©dente est une relance
                        const oppositeTeamDef = team === 'home' ? 'away' : 'home';
                        let isDefAfterRelance = false;
                        for (let j = i - 1; j >= 0; j--) {
                            if (rally[j].type === 'attack' && rally[j].team === oppositeTeamDef) {
                                isDefAfterRelance = rally[j].attackType === 'relance';
                                break;
                            }
                            // Si on trouve un block ou une defense de notre √©quipe avant l'attaque ‚Üí pas directement apr√®s relance
                            if (rally[j].type === 'block' || (rally[j].type === 'defense' && rally[j].team === team)) break;
                        }

                        if (isDefAfterRelance) {
                            // ===== RELANCE : stats compt√©es c√¥t√© d√©fenseur =====
                            // M√™me logique que D+/D-/FD mais dans les compteurs relance
                            stats.relance.tot++;

                            // Retour direct de relance exploit√© ‚Üí FR
                            const relExploited = action.isDirectReturn && !action.isDirectReturnWinner
                                && isDirectReturnExploited(rally, i, action.team);
                            if (relExploited) {
                                stats.relance.frel++;
                            } else if (action.isDirectReturn) {
                                // Retour direct non exploit√© ‚Üí R-
                                stats.relance.relminus++;
                            } else if (action.result === 'fault') {
                                // V√©rifier si un bloc pr√©c√®de
                                let hasBlockBeforeRel = false;
                                for (let j = i - 1; j >= 0; j--) {
                                    if (rally[j].type === 'block' && rally[j].team === team) {
                                        hasBlockBeforeRel = true;
                                        break;
                                    }
                                    if (rally[j].type === 'pass' && rally[j].team === team) break;
                                    if (rally[j].type === 'attack' && rally[j].team === team) break;
                                }
                                if (hasBlockBeforeRel) {
                                    stats.relance.relminus++; // Bloc avant ‚Üí R- (pas FR)
                                } else {
                                    stats.relance.frel++; // Pas de bloc ‚Üí FR
                                }
                            } else {
                                // Relance d√©fendue : utiliser defenseQuality
                                if (action.defenseQuality === 'positive') {
                                    stats.relance.relplus++; // Zone bleue claire ‚Üí R+
                                } else {
                                    stats.relance.relminus++; // Hors zone ‚Üí R-
                                }
                            }
                        } else {
                            // ===== DEFENSE NORMALE (V20.15 : D+/D/D-/FD) =====
                            stats.defense.tot++;

                            if (action.untouched) {
                                // Balle non-touch√©e dans la zone ‚Üí FD
                                stats.defense.fdef++;
                            } else {
                                // Retour direct de d√©fense exploit√© ‚Üí D- (touch√©e mais perdue)
                                const defExploited = action.isDirectReturn && !action.isDirectReturnWinner
                                    && isDirectReturnExploited(rally, i, action.team);
                                if (defExploited) {
                                    stats.defense.defminus++;
                                } else if (action.isDirectReturn) {
                                    // Retour direct gagnant ou non exploit√© ‚Üí D (touch√©e, pas optimale)
                                    stats.defense.defneutral++;
                                } else if (action.result === 'fault') {
                                    // V√©rifier si un bloc pr√©c√®de cette d√©fense dans le m√™me √©change
                                    let hasBlockBefore = false;
                                    for (let j = i - 1; j >= 0; j--) {
                                        if (rally[j].type === 'block' && rally[j].team === team) {
                                            hasBlockBefore = true;
                                            break;
                                        }
                                        if (rally[j].type === 'pass' && rally[j].team === team) break;
                                        if (rally[j].type === 'attack' && rally[j].team === team) break;
                                    }
                                    if (hasBlockBefore) {
                                        stats.defense.defneutral++; // Responsabilit√© partag√©e bloc ‚Üí D
                                    } else {
                                        stats.defense.defminus++; // Seul responsable ‚Üí D-
                                    }
                                } else {
                                    // D√©fense r√©ussie : utiliser defenseQuality si disponible
                                    if (action.defenseQuality === 'positive') {
                                        stats.defense.defplus++;
                                    } else if (action.defenseQuality === 'negative') {
                                        stats.defense.defneutral++; // Touch√©e mais pas optimale ‚Üí D
                                    } else {
                                        stats.defense.defplus++; // Fallback ‚Üí D+
                                    }
                                }
                            }
                        }
                        break;
                    }

                    case 'block': {
                        stats.block.tot++;
                        if (action.result === 'bloc_out') {
                            // FB : bloc out
                            stats.block.fblc++;
                        } else if (action.result === 'kill' || action.result === 'point') {
                            // B+ : bloc kill direct
                            stats.block.blcplus++;
                        } else {
                            // Bloc touch√© : analyser la suite du rally
                            // Chercher la premi√®re d√©fense apr√®s le bloc (peu importe l'√©quipe)
                            let blockOutcome = 'unknown';
                            for (let j = i + 1; j < rally.length; j++) {
                                if (rally[j].type === 'defense') {
                                    if (rally[j].result === 'fault') {
                                        // D√©fense rat√©e : qui a rat√© ?
                                        if (rally[j].team === team) {
                                            // L'√©quipe du bloqueur rate sa d√©fense ‚Üí FB
                                            blockOutcome = 'own_defense_fault';
                                        } else {
                                            // L'adversaire rate sa d√©fense ‚Üí B+ (bloc kill indirect)
                                            blockOutcome = 'opponent_defense_fault';
                                        }
                                    } else {
                                        // D√©fense r√©ussie ‚Üí B- (le jeu continue)
                                        blockOutcome = 'play_continues';
                                    }
                                    break;
                                }
                                // Si on trouve une passe ou attaque sans d√©fense pr√©alable
                                // ‚Üí le jeu a continu√© ‚Üí B-
                                if (rally[j].type === 'pass' || rally[j].type === 'attack') {
                                    blockOutcome = 'play_continues';
                                    break;
                                }
                            }
                            if (blockOutcome === 'play_continues') {
                                stats.block.blcminus++; // B- : bloc touch√©, neutre, le jeu continue
                            } else if (blockOutcome === 'own_defense_fault') {
                                stats.block.fblc++; // FB : bloc qui n'a pas permis la d√©fense de son √©quipe
                            } else if (blockOutcome === 'opponent_defense_fault') {
                                stats.block.blcplus++; // B+ : bloc kill (adversaire rate sa d√©fense)
                            } else {
                                // unknown = fin du rally apr√®s le bloc sans suite claire
                                // V√©rifier qui a gagn√© le point : chercher la derni√®re attaque avant le bloc
                                const lastAttackBeforeBlock = (() => {
                                    for (let j = i - 1; j >= 0; j--) {
                                        if (rally[j].type === 'attack') return rally[j];
                                    }
                                    return null;
                                })();
                                if (lastAttackBeforeBlock && lastAttackBeforeBlock.result === 'point' && lastAttackBeforeBlock.team !== team) {
                                    // L'attaquant adverse a fait le point malgr√© le bloc ‚Üí B- (bloc ralenti mais pas d√©cisif)
                                    stats.block.blcminus++;
                                } else {
                                    // Le bloc a fait le point ‚Üí B+
                                    stats.block.blcplus++;
                                }
                            }
                        }
                        break;
                    }
                }
            }
        }

        // ==================== INIT ====================
        init();
    </script>
</body>
</html>
